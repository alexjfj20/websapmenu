{"version":3,"file":"js/226.2f25ca18.js","mappings":"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","sources":["webpack://websap/./src/services/menuService.js"],"sourcesContent":["import { getBusinessInfo, compressImage, checkItemAvailability } from './storageService';\n\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\nconst SHARED_MENU_STORE = 'sharedMenus';\nconst IMAGE_STORE = 'menuImages';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n        \n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        \n        if (!existingStores.includes(SHARED_MENU_STORE)) {\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\n          return;\n        }\n        \n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n        \n        // Crear almacén para menús compartidos si no existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.log('Creando almacén:', SHARED_MENU_STORE);\n          db.createObjectStore(SHARED_MENU_STORE, { keyPath: 'id' });\n        }\n        \n        // Crear almacén para imágenes si no existe\n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('Creando almacén:', IMAGE_STORE);\n          db.createObjectStore(IMAGE_STORE, { keyPath: 'id' });\n        }\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n/**\n * Genera un ID único para un menú\n * @returns {string} Un ID único\n */\nfunction generateMenuId() {\n  return Math.random().toString(36).substring(2, 10) + \n         Math.random().toString(36).substring(2, 10);\n}\n\n/**\n * Guarda un menú compartido y devuelve su ID\n * @param {Array} menuItems - Elementos del menú a guardar\n * @returns {Promise<String>} - ID del menú compartido\n */\nexport async function saveMenu(menuItems) {\n  try {\n    // Generar un ID único para el menú compartido\n    const menuId = generateMenuId();\n    \n    // Obtener información del negocio para incluirla en el menú compartido\n    const businessInfo = await getBusinessInfo();\n    \n    // Preprocesar los elementos del menú - comprimir imágenes y normalizar isSpecial\n    const processedItems = await Promise.all(menuItems.map(async (item) => {\n      const processedItem = { ...item };\n      processedItem.isSpecial = Boolean(item.isSpecial);\n      console.log(`[saveMenu] Guardando ${item.name} con isSpecial=${processedItem.isSpecial}`);\n      \n      // Comprimir la imagen si existe\n      if (processedItem.image && typeof processedItem.image === 'string' && processedItem.image.length > 0) {\n        try {\n          // Usar una calidad más baja para compartir\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\n        } catch (err) {\n          console.warn('Error al comprimir imagen:', err);\n          processedItem.image = null;\n        }\n      }\n      \n      return processedItem;\n    }));\n    \n    // Crear objeto del menú con información del negocio incluida\n    const menuData = {\n      id: menuId,\n      items: processedItems,\n      businessInfo: businessInfo, // Incluir la información del negocio (con datos de pago)\n      createdAt: new Date().toISOString()\n    };\n    \n    // Verificar tamaño del objeto\n    try {\n      const jsonSize = JSON.stringify(menuData).length / (1024 * 1024); // Tamaño en MB\n      console.log(`Tamaño del menú a guardar: ${jsonSize.toFixed(2)} MB`);\n      \n      if (jsonSize > 50) {\n        throw new Error(`El menú es demasiado grande (${jsonSize.toFixed(2)} MB). Reduce el tamaño de las imágenes.`);\n      }\n    } catch (error) {\n      console.error('Error al verificar tamaño del menú:', error);\n      throw new Error('Error al verificar tamaño del menú');\n    }\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú guardado exitosamente con ID: ${menuId}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Añadir logs de depuración\n    console.log('[saveMenu] Items a guardar:', menuItems.length);\n    console.log('[saveMenu] Items especiales:', menuItems.filter(item => item.isSpecial).length);\n    console.log('[saveMenu] Items regulares:', menuItems.filter(item => !item.isSpecial).length);\n    \n    // Sincronizar información del negocio con el backend\n    await syncBusinessInfoWithBackend();\n    \n    return menuId;\n  } catch (error) {\n    console.error('Error al guardar el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene un menú compartido por su ID\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getSharedMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\n    \n    // Verificar que tenemos un ID válido\n    if (!menuId) {\n      console.error('ID de menú no proporcionado');\n      return null;\n    }\n\n    // Intentar primero recuperar el menú desde IndexedDB como respaldo\n    let menuData = null;\n    try {\n      const menuUtils = await import('./menuUtils');\n      const localMenu = await menuUtils.getMenuFromIndexedDB(menuId);\n      if (localMenu && localMenu.items && localMenu.items.length > 0) {\n        console.log('Menú recuperado desde IndexedDB:', localMenu);\n        menuData = localMenu;\n      }\n    } catch (localError) {\n      console.warn('No se pudo obtener el menú desde IndexedDB:', localError);\n    }\n\n    // Si no hay datos locales o queremos asegurarnos de tener la versión más reciente,\n    // intentamos obtener el menú desde el servidor\n    if (!menuData || !menuData.items || menuData.items.length === 0) {\n      console.log(`Obteniendo menú desde el servidor con ID: ${menuId}`);\n      \n      try {\n        // Importamos apiService usando import dinámico para evitar problemas de dependencia circular\n        const apiService = await import('./apiService');\n        \n        // Hacemos la petición al servidor para obtener el menú\n        const response = await apiService.default.get(`/platos/menu/${menuId}`);\n        \n        if (response && response.success && response.data) {\n          console.log('Menú recuperado desde el servidor:', response.data);\n          menuData = response.data;\n        } else {\n          console.warn('No se pudo obtener el menú desde el servidor:', response);\n          \n          // Si no pudimos obtener el menú desde el servidor y tenemos datos locales, usamos los datos locales\n          if (!menuData) {\n            throw new Error('No se pudo obtener el menú');\n          }\n        }\n      } catch (serverError) {\n        console.error('Error al obtener el menú desde el servidor:', serverError);\n        \n        // Si no pudimos obtener el menú desde el servidor y no tenemos datos locales, intentamos obtenerlo desde la caché\n        if (!menuData) {\n          // Intentar recuperar de localStorage como último recurso\n          try {\n            const cachedMenu = localStorage.getItem(`menu_${menuId}`);\n            if (cachedMenu) {\n              menuData = JSON.parse(cachedMenu);\n              console.log('Menú recuperado desde localStorage:', menuData);\n            } else {\n              throw new Error('No se encontró el menú en la caché');\n            }\n          } catch (cacheError) {\n            console.error('Error al recuperar menú desde la caché:', cacheError);\n            throw new Error('No se pudo obtener el menú');\n          }\n        }\n      }\n    }\n    \n    // Si el menú no tiene información de negocio, intentar obtenerla\n    if (menuData && !menuData.businessInfo) {\n      try {\n        const businessInfo = await getBusinessInfo();\n        menuData.businessInfo = businessInfo;\n      } catch (businessError) {\n        console.warn('No se pudo obtener información del negocio:', businessError);\n        // Usar información por defecto si no se puede obtener\n        menuData.businessInfo = {\n          name: 'Restaurante WebSAP',\n          description: 'Deliciosa comida para todos los gustos',\n          contact: 'info@websap.com',\n          address: 'Calle Principal #123',\n          logo: null,\n          paymentInfo: {\n            qrImage: null,\n            qrTitle: 'Escanea para pagar',\n            nequiNumber: null,\n            nequiImage: null,\n            bankInfo: 'Banco XYZ - Cuenta 123456789',\n            otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n          }\n        };\n      }\n    }\n    \n    // Asegurarse de que businessInfo siempre tenga un objeto paymentInfo\n    if (menuData && menuData.businessInfo && !menuData.businessInfo.paymentInfo) {\n      menuData.businessInfo.paymentInfo = {\n        qrImage: null,\n        qrTitle: 'Escanea para pagar',\n        nequiNumber: null,\n        nequiImage: null,\n        bankInfo: 'Banco XYZ - Cuenta 123456789',\n        otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n      };\n    }\n    \n    // Guardar en localStorage para tener un respaldo\n    try {\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify(menuData));\n    } catch (saveError) {\n      console.warn('No se pudo guardar el menú en localStorage:', saveError);\n    }\n    \n    // Añadir logs de depuración con verificaciones de seguridad\n    console.log('[getSharedMenu] Menú recuperado:', menuData);\n    \n    // Usar el operador de encadenamiento opcional para evitar errores\n    const specialItems = menuData?.items?.filter(i => i.isSpecial) || [];\n    const regularItems = menuData?.items?.filter(i => !i.isSpecial) || [];\n    \n    console.log('[getSharedMenu] Items especiales:', specialItems.length);\n    console.log('[getSharedMenu] Items regulares:', regularItems.length);\n    \n    return menuData;\n  } catch (error) {\n    console.error('Error al obtener el menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Alias para getSharedMenu para mantener compatibilidad con código existente\n * @param {String} menuId - ID del menú compartido\n * @returns {Promise<Object>} - Datos del menú compartido\n */\nexport async function getMenu(menuId) {\n  console.log('Intentando recuperar menú con ID:', menuId);\n  try {\n    const db = await openDatabase();\n    const tx = db.transaction('sharedMenus', 'readonly');\n    const store = tx.objectStore('sharedMenus');\n    \n    // Obtener el menú de la base de datos\n    const request = store.get(menuId);\n    const result = await new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        console.log('Resultado de búsqueda del menú:', request.result);\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al recuperar el menú:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Verificar si se encontró el menú\n    if (!result) {\n      console.warn(`No se encontró menú con ID: ${menuId}`);\n      return null;\n    }\n    \n    // Verificar si el menú tiene items y es un array\n    if (result && result.items && Array.isArray(result.items)) {\n      console.log('[menuService] Procesando items en getMenu()');\n      \n      // Procesar cada item para normalizar isSpecial\n      const processedItems = result.items.map(item => {\n        // Si isSpecial no existe, asignar false por defecto\n        if (item.isSpecial === undefined) {\n          console.log(`[menuService] Item ${item.name || 'sin nombre'} sin propiedad isSpecial, asignando false`);\n          return { ...item, isSpecial: false };\n        }\n        \n        // Normalizar isSpecial a un valor booleano\n        const normalizedIsSpecial = \n          item.isSpecial === true || \n          item.isSpecial === 'true' || \n          item.isSpecial === 1 || \n          item.isSpecial === '1';\n        \n        if (typeof item.isSpecial !== 'boolean') {\n          console.log(`[menuService] Normalizando isSpecial para ${item.name}: ${item.isSpecial} (${typeof item.isSpecial}) → ${normalizedIsSpecial}`);\n        }\n        \n        return { ...item, isSpecial: normalizedIsSpecial };\n      });\n      \n      console.log(`[menuService] Procesados ${processedItems.length} items:`, \n        processedItems.map(i => ({ name: i.name, isSpecial: i.isSpecial })));\n      \n      // Devolver el objeto completo con los items procesados\n      return {\n        ...result,\n        items: processedItems\n      }; // Devuelve el objeto completo con los items procesados\n    } else {\n      console.warn('El menú no tiene items o no es un array:', result);\n      \n      // Si no tiene items, devolver el resultado tal cual\n      return result;\n    }\n  } catch (error) {\n    console.error('Error al obtener menú compartido:', error);\n    throw error;\n  }\n}\n\n/**\n * Guarda un menú compartido en IndexedDB\n * @param {Object} menuData - Datos del menú a guardar\n * @returns {Promise<void>}\n */\nexport async function saveSharedMenu(menuData) {\n  try {\n    if (!menuData || !menuData.id) {\n      throw new Error('Datos de menú inválidos');\n    }\n    \n    console.log(`Guardando menú compartido con ID: ${menuData.id}`);\n    \n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    await new Promise((resolve, reject) => {\n      const request = store.put(menuData);\n      \n      request.onsuccess = () => {\n        console.log(`Menú compartido guardado exitosamente con ID: ${menuData.id}`);\n        resolve();\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al guardar el menú compartido:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    console.log('[saveSharedMenu] Menú guardado en IndexedDB');\n    \n  } catch (error) {\n    console.error('Error al guardar el menú compartido en IndexedDB:', error);\n    throw error;\n  }\n}\n\n/**\n * Limpia menús antiguos que ya no son necesarios\n * @returns {Promise<void>}\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    \n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      \n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      \n      request.onerror = (e) => {\n        console.error('Error al obtener menús:', e.target.error);\n        reject(e.target.error);\n      };\n    });\n    \n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    \n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n    \n    console.log(`Se eliminaron ${menusToDelete.length} menús antiguos`);\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n// Añadir después de getSharedMenu\nexport async function syncMenuAvailability(menuId) {\n  try {\n    const sharedMenu = await getSharedMenu(menuId);\n    if (!sharedMenu || !sharedMenu.items) return null;\n\n    // Actualizar la disponibilidad de cada item\n    const updatedItems = await Promise.all(sharedMenu.items.map(async (item) => {\n      const availability = await checkItemAvailability(item.id);\n      return {\n        ...item,\n        availableQuantity: availability.quantity\n      };\n    }));\n\n    // Actualizar el menú con las nuevas disponibilidades\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n\n    const updatedMenu = {\n      ...sharedMenu,\n      items: updatedItems,\n      lastSync: new Date().toISOString()\n    };\n\n    await store.put(updatedMenu);\n    return updatedMenu;\n  } catch (error) {\n    console.error('Error al sincronizar disponibilidad:', error);\n    return null;\n  }\n}\n\n/**\n * Sincroniza la información del negocio con el backend\n * @param {Object} businessInfo - Información del negocio a sincronizar\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend(businessInfo) {\n  try {\n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n    \n    // Verificar que tenemos información válida\n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.error('No hay información del negocio para sincronizar');\n      return { success: false, message: 'No hay información del negocio para sincronizar' };\n    }\n    \n    // Importar apiService dinámicamente para evitar dependencias circulares\n    const apiServiceModule = await import('./apiService');\n    const apiService = apiServiceModule.default;\n    \n    // Asegurarse de que el token esté configurado\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return { success: false, message: 'No se pudo obtener el restaurante del usuario actual' };\n    }\n    \n    const restauranteId = userResponse.user.restaurante_id;\n    \n    // Asegurarse de que paymentInfo sea un objeto válido\n    const paymentInfo = businessInfo.paymentInfo || {\n      qrImage: null,\n      qrTitle: 'Escanea para pagar',\n      nequiNumber: null,\n      nequiImage: null,\n      bankInfo: 'Banco XYZ - Cuenta 123456789',\n      otherPaymentMethods: 'Aceptamos efectivo y tarjetas'\n    };\n    \n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name || '',\n      descripcion: businessInfo.description || '',\n      direccion: businessInfo.address || '',\n      telefono: businessInfo.contact || '',\n      logo: businessInfo.logo || null,\n      informacion_pago: JSON.stringify(paymentInfo)\n    };\n    \n    console.log('Datos a enviar al backend:', restauranteData);\n    \n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    \n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      return { success: true, message: 'Información del negocio sincronizada con éxito' };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return { success: false, message: response.message || 'Error al sincronizar información del negocio' };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return { success: false, message: error.message || 'Error al sincronizar información del negocio' };\n  }\n}\n"],"names":["DB_NAME","DB_VERSION","SHARED_MENU_STORE","IMAGE_STORE","openDatabase","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","target","errorCode","onsuccess","db","result","version","existingStores","Array","from","objectStoreNames","includes","Error","onupgradeneeded","newVersion","contains","createObjectStore","keyPath","generateMenuId","Math","random","toString","substring","async","saveMenu","menuItems","menuId","businessInfo","getBusinessInfo","processedItems","all","map","processedItem","item","isSpecial","Boolean","name","image","length","compressImage","err","warn","menuData","id","items","createdAt","Date","toISOString","jsonSize","JSON","stringify","toFixed","transaction","store","objectStore","put","e","filter","syncBusinessInfoWithBackend","getSharedMenu","menuUtils","localMenu","getMenuFromIndexedDB","localError","apiService","response","default","get","success","data","serverError","cachedMenu","localStorage","getItem","parse","cacheError","businessError","description","contact","address","logo","paymentInfo","qrImage","qrTitle","nequiNumber","nequiImage","bankInfo","otherPaymentMethods","setItem","saveError","specialItems","i","regularItems","Object","keys","message","apiServiceModule","token","setToken","userResponse","user","restaurante_id","restauranteId","restauranteData","nombre","descripcion","direccion","telefono","informacion_pago"],"sourceRoot":""}