{"version":3,"file":"js/982.42cce96a.js","mappings":"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","sources":["webpack://websap/./src/services/storageService.js"],"sourcesContent":["const DB_NAME = 'websapDatabase';\n// Incrementar la versión de la base de datos para forzar la actualización\nconst DB_VERSION = 3; // Incrementado a 3 para forzar upgradeneeded\nconst MENU_STORE = 'menuItems';\nconst IMAGE_STORE = 'menuImages';\nconst SOLD_ITEMS_STORE = 'soldItems'; \nconst BUSINESS_INFO_STORE = 'businessInfo';\nconst USERS_STORE = 'users';\nconst SHARED_MENU_STORE = 'sharedMenus';\n\n// Abrir la conexión a la base de datos con manejo mejorado de errores\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n        \n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        \n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n        \n        // Crear todos los almacenes necesarios si no existen\n        const requiredStores = [\n          { name: USERS_STORE, keyPath: 'id' },\n          { name: MENU_STORE, keyPath: 'id' },\n          { name: IMAGE_STORE, keyPath: 'id' },\n          { name: SOLD_ITEMS_STORE, keyPath: 'id' },\n          { name: BUSINESS_INFO_STORE, keyPath: 'id' },\n          { name: SHARED_MENU_STORE, keyPath: 'id' }\n        ];\n        \n        // Crear cada almacén\n        requiredStores.forEach(store => {\n          if (!db.objectStoreNames.contains(store.name)) {\n            console.log(`Creando almacén: ${store.name}`);\n            db.createObjectStore(store.name, { keyPath: store.keyPath });\n          }\n        });\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Guardar elementos del menú\nexport async function saveMenuItems(items, areSpecial = false) {\n  try {\n    // Primero procesamos todas las imágenes y creamos copias de los objetos\n    const processedItems = [];\n    for (const item of items) {\n      // Crear una copia del elemento\n      const itemToStore = { ...item };\n      \n      // Asegurarse de que el elemento tiene un id\n      if (!itemToStore.id) {\n        itemToStore.id = Date.now() + Math.random().toString(36).substring(2, 10);\n      }\n      \n      // Añadir la propiedad isSpecial (asumiendo que viene del formulario)\n      itemToStore.isSpecial = item.isSpecial || false; // Valor por defecto: false\n      \n      // Si tiene imagen, guardarla por separado antes de la transacción principal\n      if (itemToStore.image && typeof itemToStore.image === 'string' && itemToStore.image.length > 0) {\n        try {\n          await saveMenuImage(itemToStore.id, itemToStore.image);\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = true;\n        } catch (imageError) {\n          console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n          // Si hay error al guardar la imagen, continuamos sin ella\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = false;\n        }\n      }\n      \n      processedItems.push(itemToStore);\n    }\n    \n    // Ahora guardamos todos los items en una sola transacción\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    // Usamos Promise.all para manejar todas las operaciones put juntas\n    const putPromises = processedItems.map(item => {\n      return new Promise((resolve, reject) => {\n        const request = store.put(item);\n        request.onsuccess = () => resolve();\n        request.onerror = (e) => reject(e.target.error);\n      });\n    });\n    \n    // Esperamos a que se completen todas las operaciones put\n    await Promise.all(putPromises);\n    \n    // Esperamos a que se complete la transacción\n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos del menú:', error);\n    throw error;\n  }\n}\n\n// Guardar imagen de un elemento del menú\nexport async function saveMenuImage(itemId, imageData) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readwrite');\n    const store = transaction.objectStore(IMAGE_STORE);\n    \n    store.put({ id: itemId, data: imageData });\n    \n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar imagen:', error);\n    throw error;\n  }\n}\n\n// Obtener todos los elementos del menú\nexport async function getMenuItems() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(MENU_STORE)) {\n      console.error(`El almacén ${MENU_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    const request = store.getAll();\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = async () => {\n        let items = request.result;\n        \n        // Verificar que todos los elementos tengan IDs únicos\n        const uniqueItems = [];\n        const seenIds = new Set();\n        \n        for (const item of items) {\n          // Si el elemento no tiene ID o es un ID duplicado, generamos uno nuevo\n          if (!item.id || seenIds.has(item.id)) {\n            item.id = Date.now() + '-' + Math.random().toString(36).substring(2, 10);\n          }\n          \n          // Marcar este ID como visto\n          seenIds.add(item.id);\n          uniqueItems.push(item);\n        }\n        \n        // Recuperar imágenes para cada elemento\n        for (const item of uniqueItems) {\n          if (item.hasStoredImage) {\n            item.image = await getMenuImage(item.id);\n          }\n        }\n        \n        resolve(uniqueItems);\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    return []; // Devolver array vacío en caso de error\n  }\n}\n\n// Eliminar un elemento del menú - RENOMBRANDO LA FUNCIÓN\nexport async function deleteMenuItemFromDB(itemId) {\n  try {\n    console.log(`Intentando eliminar elemento con ID: ${itemId}`);\n    \n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE, IMAGE_STORE], 'readwrite');\n    const menuStore = transaction.objectStore(MENU_STORE);\n    const imageStore = transaction.objectStore(IMAGE_STORE);\n    \n    // Verificar primero si el elemento existe\n    const getRequest = menuStore.get(itemId);\n    \n    return new Promise((resolve, reject) => {\n      getRequest.onsuccess = () => {\n        if (!getRequest.result) {\n          console.warn(`No se encontró el elemento con ID: ${itemId}`);\n          // Resolver con éxito incluso si el elemento no existe\n          resolve(true);\n          return;\n        }\n        \n        // Eliminar el elemento\n        const deleteRequest = menuStore.delete(itemId);\n        deleteRequest.onsuccess = () => {\n          console.log(`Elemento con ID ${itemId} eliminado correctamente`);\n          \n          // Intentar eliminar la imagen asociada (no falla si no existe)\n          const imageRequest = imageStore.delete(itemId);\n          imageRequest.onsuccess = () => {\n            console.log(`Imagen para elemento ${itemId} eliminada (si existía)`);\n            resolve(true);\n          };\n          imageRequest.onerror = (e) => {\n            // No fallar si la imagen no existe\n            console.warn(`Error al eliminar imagen para ${itemId}:`, e.target.error);\n            resolve(true);\n          };\n        };\n        \n        deleteRequest.onerror = (e) => {\n          console.error(`Error al eliminar elemento ${itemId}:`, e.target.error);\n          reject(e.target.error);\n        };\n      };\n      \n      getRequest.onerror = (event) => {\n        console.error(`Error al verificar existencia del elemento ${itemId}:`, event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al eliminar elemento del menú:', error);\n    throw error;\n  }\n}\n\n// Mantener la función original por compatibilidad, pero que use la nueva\nexport async function deleteMenuItem(itemId) {\n  console.warn('La función deleteMenuItem está obsoleta, use deleteMenuItemFromDB en su lugar');\n  return deleteMenuItemFromDB(itemId);\n}\n\n// Obtener imagen de un elemento del menú\nexport async function getMenuImage(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\n    const store = transaction.objectStore(IMAGE_STORE);\n    \n    const request = store.get(itemId);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.data);\n        } else {\n          resolve(null);\n        }\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener imagen:', error);\n    throw error;\n  }\n}\n\n// Guardar información del negocio - MEJORADA\nexport async function saveBusinessInfo(businessInfo) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction(['businessInfo'], 'readwrite');\n    const store = transaction.objectStore('businessInfo');\n\n    // Crear una copia limpia del objeto sin referencias circulares o propiedades no serializables\n    const cleanBusinessInfo = {\n      id: businessInfo.id || 'business_info_1', // Usar un ID consistente\n      name: businessInfo.name || '',\n      description: businessInfo.description || '',\n      contact: businessInfo.contact || '',\n      address: businessInfo.address || '',\n      logo: businessInfo.logo || ''\n    };\n\n    // Manejar información de pago por separado si existe\n    if (businessInfo.paymentInfo) {\n      cleanBusinessInfo.paymentInfo = {\n        qrTitle: businessInfo.paymentInfo.qrTitle || '',\n        qrImage: businessInfo.paymentInfo.qrImage || '',\n        nequiNumber: businessInfo.paymentInfo.nequiNumber || '',\n        nequiImage: businessInfo.paymentInfo.nequiImage || '',\n        bankInfo: businessInfo.paymentInfo.bankInfo || '',\n        otherPaymentMethods: businessInfo.paymentInfo.otherPaymentMethods || ''\n      };\n    }\n\n    // Para debugging, verificamos que es serializable\n    try {\n      JSON.stringify(cleanBusinessInfo);\n    } catch (e) {\n      console.error('El objeto businessInfo no es serializable:', e);\n      throw new Error('El objeto businessInfo no es serializable');\n    }\n\n    // Guardar el objeto limpio\n    const request = store.put(cleanBusinessInfo);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => {\n        console.error('Error específico al guardar businessInfo:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar información del negocio:', error);\n    throw error;\n  }\n}\n\n// Obtener información del negocio\nexport async function getBusinessInfo() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(BUSINESS_INFO_STORE)) {\n      console.error(`El almacén ${BUSINESS_INFO_STORE} no existe en la base de datos`);\n      return {}; // Devolver objeto vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([BUSINESS_INFO_STORE], 'readonly');\n    const store = transaction.objectStore(BUSINESS_INFO_STORE);\n    \n    const request = store.get('business_info_1');\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve(request.result || {});\n      };\n      request.onerror = (event) => {\n        console.error('Error en request:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al obtener información del negocio:', error);\n    // Devolvemos un objeto vacío en lugar de fallar\n    return {};\n  }\n}\n\n// Guardar elementos vendidos\nexport async function saveSoldItems(items) {\n  try {\n    // Asegurarse de que items sea un array y que cada elemento sea serializable\n    if (!Array.isArray(items)) {\n      console.warn('saveSoldItems recibió un valor que no es array:', items);\n      items = [];\n    }\n    \n    // Limpiar los objetos para asegurar que sean serializables\n    const cleanItems = items.map(item => {\n      // Si el item no es un objeto, crear uno básico\n      if (!item || typeof item !== 'object') {\n        return {\n          name: 'Producto desconocido',\n          quantity: 1,\n          price: 0,\n          includesDrink: false\n        };\n      }\n      \n      // Crear una copia limpia con solo las propiedades necesarias\n      return {\n        name: String(item.name || 'Producto desconocido'),\n        quantity: Number(item.quantity) || 1,\n        price: Number(item.price) || 0,\n        includesDrink: Boolean(item.includesDrink)\n      };\n    });\n    \n    const db = await openDatabase();\n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readwrite');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n    \n    // Asegurarnos de que estamos guardando un objeto serializable\n    const soldItemsObject = { \n      id: 'sold_items_1', \n      items: cleanItems\n    };\n    \n    // Verificar que el objeto es serializable antes de guardarlo\n    try {\n      // Esto lanzará error si el objeto no es serializable\n      JSON.stringify(soldItemsObject);\n    } catch (e) {\n      console.error('El objeto soldItems no es serializable:', e);\n      throw new Error('El objeto soldItems no es serializable');\n    }\n    \n    const request = store.put(soldItemsObject);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => {\n        console.error('Error específico al guardar soldItems:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos vendidos:', error);\n    throw error;\n  }\n}\n\n// Obtener elementos vendidos\nexport async function getSoldItems() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(SOLD_ITEMS_STORE)) {\n      console.error(`El almacén ${SOLD_ITEMS_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readonly');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n    \n    const request = store.get('sold_items_1');\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.items);\n        } else {\n          resolve([]);\n        }\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    return [];\n  }\n}\n\n// Eliminar completamente la función migrateFromLocalStorage ya que no queremos usar localStorage\nexport async function migrateFromLocalStorage() {\n  console.log(\"Función migrateFromLocalStorage en desuso - no se utilizará localStorage\");\n  return true; // Solo para mantener la compatibilidad con el código existente\n}\n\n// Comprimir imagen\nexport function compressImage(base64Image, maxWidth = 800, maxHeight = 600, quality = 0.7) {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      // Crear un canvas para comprimir la imagen\n      const canvas = document.createElement('canvas');\n      \n      let width = img.width;\n      let height = img.height;\n      \n      // Calcular nuevas dimensiones manteniendo proporción\n      if (width > height) {\n        if (width > maxWidth) {\n          height = Math.round((height * maxWidth) / width);\n          width = maxWidth;\n        }\n      } else {\n        if (height > maxHeight) {\n          width = Math.round((width * maxHeight) / height);\n          height = maxHeight;\n        }\n      }\n      \n      canvas.width = width;\n      canvas.height = height;\n      \n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n      \n      // Obtener imagen comprimida como JPEG con calidad reducida\n      const compressedImage = canvas.toDataURL('image/jpeg', quality);\n      resolve(compressedImage);\n    };\n    img.src = base64Image;\n  });\n}\n\n// Mejorar la función resetDatabase para asegurarnos de que no use localStorage\nexport async function resetDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Iniciando proceso de eliminación de la base de datos...\");\n      \n      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);\n      \n      deleteRequest.onsuccess = () => {\n        console.log(\"Base de datos eliminada con éxito\");\n        \n        console.log(\"Limpieza completa. La aplicación está lista para comenzar de nuevo.\");\n        resolve(true);\n      };\n      \n      deleteRequest.onerror = (event) => {\n        console.error(\"Error al eliminar la base de datos:\", event.target.error);\n        reject(event.target.error);\n      };\n    } catch (error) {\n      console.error(\"Error al intentar resetear la base de datos:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Añadir nueva función para validar disponibilidad\nexport async function checkItemAvailability(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    const item = await store.get(itemId);\n    \n    return {\n      isAvailable: item && item.availableQuantity > 0,\n      quantity: item ? item.availableQuantity : 0\n    };\n  } catch (error) {\n    console.error('Error al verificar disponibilidad:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza la cantidad disponible de un plato en el inventario.\n * @param {string} itemId - ID del plato a actualizar\n * @param {number|string} newQuantity - Nueva cantidad disponible\n * @returns {Promise<boolean>} - Resultado de la operación\n */\nexport async function updateItemAvailability(itemId, newQuantity) {\n  try {\n    // Validar parámetros de entrada\n    if (!itemId) {\n      console.error('Error: ID del item no proporcionado');\n      return false;\n    }\n    \n    // Asegurarse de que newQuantity sea un número entero válido\n    // Usar parseInt en lugar de Math.floor para asegurar una conversión correcta a entero\n    const quantity = parseInt(Number(newQuantity), 10);\n    if (isNaN(quantity)) {\n      console.error(`Error: Cantidad inválida proporcionada: ${newQuantity} (${typeof newQuantity})`);\n      return false;\n    }\n    \n    console.log(`Actualizando disponibilidad para item ${itemId} a ${quantity} unidades (valor original: ${newQuantity}, tipo: ${typeof newQuantity})`);\n    \n    // Usar una transacción específica solo para este item\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    return new Promise((resolve, reject) => {\n      // Primero obtenemos el item actual\n      const getRequest = store.get(itemId);\n      \n      getRequest.onsuccess = (event) => {\n        const item = event.target.result;\n        \n        if (!item) {\n          console.error(`No se encontró el elemento con ID: ${itemId}`);\n          resolve(false);\n          return;\n        }\n        \n        // Guardar valores anteriores para mejor logging\n        const oldQuantity = parseInt(Number(item.availableQuantity) || 0, 10);\n        \n        // Actualizar la cantidad disponible, asegurando que sea un número entero\n        item.availableQuantity = quantity;\n        \n        // Guardar el item actualizado\n        const putRequest = store.put(item);\n        \n        putRequest.onsuccess = () => {\n          console.log(`Disponibilidad actualizada para ${item.name} (ID: ${itemId}): ${oldQuantity} → ${quantity} (diferencia: ${oldQuantity - quantity})`);\n          \n          // Intentar sincronizar con el backend (opcional, no bloquea)\n          try {\n            fetch('https://websapmenu.onrender.com/actualizar-disponibilidad', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                id: itemId,\n                availableQuantity: quantity\n              })\n            }).catch(syncError => {\n              // Simplemente registrar el error, no bloqueamos la operación principal\n              console.warn('Error al sincronizar con backend:', syncError);\n            });\n          } catch (syncError) {\n            console.warn('Error al sincronizar con el backend:', syncError);\n            // No bloqueamos la función principal por errores de sincronización\n          }\n          \n          resolve(true);\n        };\n        \n        putRequest.onerror = (error) => {\n          console.error(`Error al actualizar disponibilidad para ${itemId}:`, error);\n          reject(error);\n        };\n      };\n      \n      getRequest.onerror = (error) => {\n        console.error(`Error al obtener elemento ${itemId}:`, error);\n        reject(error);\n      };\n      \n      // Manejar errores de transacción\n      transaction.onerror = (error) => {\n        console.error('Error en transacción de actualización:', error);\n        reject(error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al actualizar disponibilidad:', error);\n    return false;\n  }\n}\n\n// Guardar un elemento del menú individual\nexport async function saveMenuItem(item) {\n  try {\n    // Validar que el item sea un objeto y tenga id\n    if (!item || typeof item !== 'object') {\n      throw new Error('El item no es un objeto válido');\n    }\n    \n    if (!item.id) {\n      item.id = Date.now() + Math.random().toString(36).substring(2, 10);\n    }\n    \n    // Si tiene imagen y es un string largo, procesarla\n    if (item.image && typeof item.image === 'string' && item.image.length > 0 && !item.hasStoredImage) {\n      try {\n        await saveMenuImage(item.id, item.image);\n        item.image = null;\n        item.hasStoredImage = true;\n      } catch (imageError) {\n        console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n        item.image = null;\n        item.hasStoredImage = false;\n      }\n    }\n    \n    // Guardar el item en la base de datos\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.put(item);\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elemento del menú:', error);\n    throw error;\n  }\n}"],"names":["DB_NAME","DB_VERSION","MENU_STORE","IMAGE_STORE","SOLD_ITEMS_STORE","BUSINESS_INFO_STORE","USERS_STORE","SHARED_MENU_STORE","openDatabase","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","target","errorCode","onsuccess","db","result","version","existingStores","Array","from","objectStoreNames","onupgradeneeded","newVersion","requiredStores","name","keyPath","forEach","store","contains","createObjectStore","async","saveMenuItems","items","areSpecial","processedItems","item","itemToStore","id","Date","now","Math","random","toString","substring","isSpecial","image","length","saveMenuImage","hasStoredImage","imageError","warn","push","transaction","objectStore","putPromises","map","put","e","all","oncomplete","itemId","imageData","data","getMenuItems","includes","getAll","uniqueItems","seenIds","Set","has","add","getMenuImage","deleteMenuItemFromDB","menuStore","imageStore","getRequest","get","deleteRequest","delete","imageRequest","saveBusinessInfo","businessInfo","cleanBusinessInfo","description","contact","address","logo","paymentInfo","qrTitle","qrImage","nequiNumber","nequiImage","bankInfo","otherPaymentMethods","JSON","stringify","Error","getBusinessInfo","saveSoldItems","isArray","cleanItems","String","quantity","Number","price","includesDrink","Boolean","soldItemsObject","getSoldItems","migrateFromLocalStorage","compressImage","base64Image","maxWidth","maxHeight","quality","img","Image","onload","canvas","document","createElement","width","height","round","ctx","getContext","drawImage","compressedImage","toDataURL","src","updateItemAvailability","newQuantity","parseInt","isNaN","oldQuantity","availableQuantity","putRequest","fetch","method","headers","body","catch","syncError"],"sourceRoot":""}