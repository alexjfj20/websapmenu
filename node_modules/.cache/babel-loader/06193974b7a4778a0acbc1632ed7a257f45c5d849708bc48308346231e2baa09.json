{"ast":null,"code":"import { ref, reactive } from 'vue';\n\n// Estado reactivo para usar en componentes\nexport const webSocketState = reactive({\n  connected: ref(false),\n  error: ref(null),\n  lastMessage: ref(null),\n  reconnecting: ref(false),\n  reconnectAttempts: ref(0),\n  maxReconnectAttempts: 5\n});\nlet wsClient = null;\nlet reconnectTimer = null;\n\n/**\r\n * Inicializar la conexión WebSocket\r\n * @param {String} url - URL del servidor WebSocket\r\n * @param {Object} options - Opciones de configuración\r\n */\nexport function initializeWebSocket(url, options = {}) {\n  // Limpiar timer existente si hay uno\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n  }\n\n  // Si ya existe una conexión, la desconectamos\n  if (wsClient) {\n    try {\n      wsClient.close();\n    } catch (e) {\n      console.error('Error al cerrar WebSocket existente:', e);\n    }\n  }\n\n  // Restablecer estado\n  webSocketState.connected = false;\n  webSocketState.error = null;\n  webSocketState.reconnecting = false;\n  webSocketState.reconnectAttempts = 0;\n\n  // Configurar máximos intentos de reconexión\n  webSocketState.maxReconnectAttempts = options.reconnectAttempts || 5;\n\n  // Crear una nueva conexión WebSocket\n  try {\n    console.log('Conectando a WebSocket:', url);\n    wsClient = new WebSocket(url);\n\n    // Configurar manejadores de eventos\n    wsClient.onopen = handleOpen;\n    wsClient.onmessage = handleMessage;\n    wsClient.onclose = event => handleClose(event, options.reconnectInterval || 2000);\n    wsClient.onerror = handleError;\n  } catch (error) {\n    console.error('Error al crear WebSocket:', error);\n    webSocketState.error = 'Error al crear la conexión WebSocket';\n    webSocketState.reconnecting = true;\n    attemptReconnect(options.reconnectInterval || 2000);\n  }\n}\nfunction handleOpen(event) {\n  console.log('WebSocket conectado');\n  webSocketState.connected = true;\n  webSocketState.error = null;\n  webSocketState.reconnecting = false;\n  webSocketState.reconnectAttempts = 0;\n}\nfunction handleMessage(event) {\n  try {\n    const message = JSON.parse(event.data);\n    webSocketState.lastMessage = message;\n  } catch (error) {\n    webSocketState.lastMessage = event.data;\n  }\n}\nfunction handleClose(event, reconnectInterval) {\n  console.log(`WebSocket cerrado (Código: ${event.code})`);\n  webSocketState.connected = false;\n\n  // No reconectar si fue un cierre limpio\n  if (event.code === 1000 || event.code === 1001) {\n    webSocketState.reconnecting = false;\n    return;\n  }\n\n  // Reconectar automáticamente\n  webSocketState.reconnecting = true;\n  attemptReconnect(reconnectInterval);\n}\nfunction handleError(event) {\n  console.error('Error en WebSocket:', event);\n  webSocketState.error = 'Error en la conexión WebSocket';\n}\nfunction attemptReconnect(interval) {\n  // No intentar reconectar si ya alcanzamos el máximo\n  if (webSocketState.reconnectAttempts >= webSocketState.maxReconnectAttempts) {\n    console.log('Máximo de intentos de reconexión alcanzado');\n    webSocketState.reconnecting = false;\n    webSocketState.error = 'No se pudo conectar después de varios intentos';\n    return;\n  }\n\n  // Incrementar contador\n  webSocketState.reconnectAttempts++;\n  console.log(`Intento de reconexión ${webSocketState.reconnectAttempts}/${webSocketState.maxReconnectAttempts} en ${interval}ms...`);\n\n  // Programar reconexión\n  reconnectTimer = setTimeout(() => {\n    if (!wsClient || wsClient.readyState === WebSocket.CLOSED) {\n      try {\n        console.log('Intentando reconectar...');\n        wsClient = new WebSocket(wsClient.url);\n        wsClient.onopen = handleOpen;\n        wsClient.onmessage = handleMessage;\n        wsClient.onclose = event => handleClose(event, interval);\n        wsClient.onerror = handleError;\n      } catch (error) {\n        console.error('Error al reconectar:', error);\n        attemptReconnect(interval);\n      }\n    }\n  }, interval);\n}\n\n/**\r\n * Enviar mensaje a través del WebSocket\r\n * @param {any} data - Datos a enviar\r\n * @returns {boolean} - true si se envió correctamente\r\n */\nexport function sendMessage(data) {\n  if (!wsClient || wsClient.readyState !== WebSocket.OPEN) {\n    console.error('WebSocket no está abierto para enviar mensajes');\n    return false;\n  }\n  try {\n    // Si es un objeto, lo convertimos a JSON\n    const message = typeof data === 'object' ? JSON.stringify(data) : data;\n    wsClient.send(message);\n    return true;\n  } catch (error) {\n    console.error('Error al enviar mensaje por WebSocket:', error);\n    return false;\n  }\n}\n\n/**\r\n * Cerrar la conexión WebSocket\r\n */\nexport function closeWebSocket() {\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  if (wsClient) {\n    try {\n      wsClient.close(1000, 'Cierre manual');\n      webSocketState.connected = false;\n      webSocketState.reconnecting = false;\n    } catch (error) {\n      console.error('Error al cerrar WebSocket:', error);\n    } finally {\n      wsClient = null;\n    }\n  }\n}\n\n/**\r\n * Forzar reconexión manual\r\n */\nexport function reconnect() {\n  // Solo si hay una URL disponible\n  if (wsClient && wsClient.url) {\n    initializeWebSocket(wsClient.url);\n  } else {\n    webSocketState.error = 'No se puede reconectar: URL no disponible';\n  }\n}\n\n/**\r\n * Detener los intentos de reconexión\r\n */\nexport function stopReconnecting() {\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n  webSocketState.reconnecting = false;\n}\nexport default {\n  initializeWebSocket,\n  sendMessage,\n  closeWebSocket,\n  reconnect,\n  stopReconnecting,\n  state: webSocketState\n};","map":{"version":3,"names":["ref","reactive","webSocketState","connected","error","lastMessage","reconnecting","reconnectAttempts","maxReconnectAttempts","wsClient","reconnectTimer","initializeWebSocket","url","options","clearTimeout","close","e","console","log","WebSocket","onopen","handleOpen","onmessage","handleMessage","onclose","event","handleClose","reconnectInterval","onerror","handleError","attemptReconnect","message","JSON","parse","data","code","interval","setTimeout","readyState","CLOSED","sendMessage","OPEN","stringify","send","closeWebSocket","reconnect","stopReconnecting","state"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/webSocketService.js"],"sourcesContent":["import { ref, reactive } from 'vue';\r\n\r\n// Estado reactivo para usar en componentes\r\nexport const webSocketState = reactive({\r\n  connected: ref(false),\r\n  error: ref(null),\r\n  lastMessage: ref(null),\r\n  reconnecting: ref(false),\r\n  reconnectAttempts: ref(0),\r\n  maxReconnectAttempts: 5\r\n});\r\n\r\nlet wsClient = null;\r\nlet reconnectTimer = null;\r\n\r\n/**\r\n * Inicializar la conexión WebSocket\r\n * @param {String} url - URL del servidor WebSocket\r\n * @param {Object} options - Opciones de configuración\r\n */\r\nexport function initializeWebSocket(url, options = {}) {\r\n  // Limpiar timer existente si hay uno\r\n  if (reconnectTimer) {\r\n    clearTimeout(reconnectTimer);\r\n  }\r\n\r\n  // Si ya existe una conexión, la desconectamos\r\n  if (wsClient) {\r\n    try {\r\n      wsClient.close();\r\n    } catch (e) {\r\n      console.error('Error al cerrar WebSocket existente:', e);\r\n    }\r\n  }\r\n\r\n  // Restablecer estado\r\n  webSocketState.connected = false;\r\n  webSocketState.error = null;\r\n  webSocketState.reconnecting = false;\r\n  webSocketState.reconnectAttempts = 0;\r\n  \r\n  // Configurar máximos intentos de reconexión\r\n  webSocketState.maxReconnectAttempts = options.reconnectAttempts || 5;\r\n\r\n  // Crear una nueva conexión WebSocket\r\n  try {\r\n    console.log('Conectando a WebSocket:', url);\r\n    wsClient = new WebSocket(url);\r\n\r\n    // Configurar manejadores de eventos\r\n    wsClient.onopen = handleOpen;\r\n    wsClient.onmessage = handleMessage;\r\n    wsClient.onclose = (event) => handleClose(event, options.reconnectInterval || 2000);\r\n    wsClient.onerror = handleError;\r\n\r\n  } catch (error) {\r\n    console.error('Error al crear WebSocket:', error);\r\n    webSocketState.error = 'Error al crear la conexión WebSocket';\r\n    webSocketState.reconnecting = true;\r\n    attemptReconnect(options.reconnectInterval || 2000);\r\n  }\r\n}\r\n\r\nfunction handleOpen(event) {\r\n  console.log('WebSocket conectado');\r\n  webSocketState.connected = true;\r\n  webSocketState.error = null;\r\n  webSocketState.reconnecting = false;\r\n  webSocketState.reconnectAttempts = 0;\r\n}\r\n\r\nfunction handleMessage(event) {\r\n  try {\r\n    const message = JSON.parse(event.data);\r\n    webSocketState.lastMessage = message;\r\n  } catch (error) {\r\n    webSocketState.lastMessage = event.data;\r\n  }\r\n}\r\n\r\nfunction handleClose(event, reconnectInterval) {\r\n  console.log(`WebSocket cerrado (Código: ${event.code})`);\r\n  webSocketState.connected = false;\r\n  \r\n  // No reconectar si fue un cierre limpio\r\n  if (event.code === 1000 || event.code === 1001) {\r\n    webSocketState.reconnecting = false;\r\n    return;\r\n  }\r\n  \r\n  // Reconectar automáticamente\r\n  webSocketState.reconnecting = true;\r\n  attemptReconnect(reconnectInterval);\r\n}\r\n\r\nfunction handleError(event) {\r\n  console.error('Error en WebSocket:', event);\r\n  webSocketState.error = 'Error en la conexión WebSocket';\r\n}\r\n\r\nfunction attemptReconnect(interval) {\r\n  // No intentar reconectar si ya alcanzamos el máximo\r\n  if (webSocketState.reconnectAttempts >= webSocketState.maxReconnectAttempts) {\r\n    console.log('Máximo de intentos de reconexión alcanzado');\r\n    webSocketState.reconnecting = false;\r\n    webSocketState.error = 'No se pudo conectar después de varios intentos';\r\n    return;\r\n  }\r\n  \r\n  // Incrementar contador\r\n  webSocketState.reconnectAttempts++;\r\n  \r\n  console.log(`Intento de reconexión ${webSocketState.reconnectAttempts}/${webSocketState.maxReconnectAttempts} en ${interval}ms...`);\r\n  \r\n  // Programar reconexión\r\n  reconnectTimer = setTimeout(() => {\r\n    if (!wsClient || wsClient.readyState === WebSocket.CLOSED) {\r\n      try {\r\n        console.log('Intentando reconectar...');\r\n        wsClient = new WebSocket(wsClient.url);\r\n        wsClient.onopen = handleOpen;\r\n        wsClient.onmessage = handleMessage;\r\n        wsClient.onclose = (event) => handleClose(event, interval);\r\n        wsClient.onerror = handleError;\r\n      } catch (error) {\r\n        console.error('Error al reconectar:', error);\r\n        attemptReconnect(interval);\r\n      }\r\n    }\r\n  }, interval);\r\n}\r\n\r\n/**\r\n * Enviar mensaje a través del WebSocket\r\n * @param {any} data - Datos a enviar\r\n * @returns {boolean} - true si se envió correctamente\r\n */\r\nexport function sendMessage(data) {\r\n  if (!wsClient || wsClient.readyState !== WebSocket.OPEN) {\r\n    console.error('WebSocket no está abierto para enviar mensajes');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    // Si es un objeto, lo convertimos a JSON\r\n    const message = typeof data === 'object' ? JSON.stringify(data) : data;\r\n    wsClient.send(message);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error al enviar mensaje por WebSocket:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Cerrar la conexión WebSocket\r\n */\r\nexport function closeWebSocket() {\r\n  if (reconnectTimer) {\r\n    clearTimeout(reconnectTimer);\r\n    reconnectTimer = null;\r\n  }\r\n  \r\n  if (wsClient) {\r\n    try {\r\n      wsClient.close(1000, 'Cierre manual');\r\n      webSocketState.connected = false;\r\n      webSocketState.reconnecting = false;\r\n    } catch (error) {\r\n      console.error('Error al cerrar WebSocket:', error);\r\n    } finally {\r\n      wsClient = null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Forzar reconexión manual\r\n */\r\nexport function reconnect() {\r\n  // Solo si hay una URL disponible\r\n  if (wsClient && wsClient.url) {\r\n    initializeWebSocket(wsClient.url);\r\n  } else {\r\n    webSocketState.error = 'No se puede reconectar: URL no disponible';\r\n  }\r\n}\r\n\r\n/**\r\n * Detener los intentos de reconexión\r\n */\r\nexport function stopReconnecting() {\r\n  if (reconnectTimer) {\r\n    clearTimeout(reconnectTimer);\r\n    reconnectTimer = null;\r\n  }\r\n  webSocketState.reconnecting = false;\r\n}\r\n\r\nexport default {\r\n  initializeWebSocket,\r\n  sendMessage,\r\n  closeWebSocket,\r\n  reconnect,\r\n  stopReconnecting,\r\n  state: webSocketState\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}