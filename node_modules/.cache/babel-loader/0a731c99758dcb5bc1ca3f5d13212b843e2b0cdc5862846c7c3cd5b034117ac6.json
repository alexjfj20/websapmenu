{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\n// src/services/indexedDBService.js\n\n// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id'\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n\n        // Si necesitamos modificar un almacén existente, primero hay que eliminarlo\n        // y luego volver a crearlo con la nueva configuración\n        try {\n          db.deleteObjectStore(PLATOS_STORE);\n          console.log('Almacén de platos eliminado para recreación');\n          const platosStore = db.createObjectStore(PLATOS_STORE, {\n            keyPath: 'id'\n          });\n          platosStore.createIndex('name', 'name', {\n            unique: false\n          });\n          platosStore.createIndex('syncStatus', 'syncStatus', {\n            unique: false\n          });\n          console.log('Almacén de platos recreado con nueva configuración');\n        } catch (error) {\n          console.error('Error al intentar modificar el almacén de platos:', error);\n        }\n      }\n\n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        syncQueueStore.createIndex('type', 'type', {\n          unique: false\n        });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificar almacenamiento después de completar la transacción\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = event => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const platos = event.target.result;\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\n        resolve(platos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      request.onsuccess = event => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronización\n          plato.syncStatus = status;\n\n          // Si es pending_deletion, marcar como no disponible también\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async id => {\n  try {\n    // Primero eliminamos el plato de IndexedDB\n    const localDeleteResult = await deleteFromIndexedDB(id);\n\n    // Luego intentamos sincronizar con el servidor\n    try {\n      console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n      const response = await fetch(`${API_BASE_URL}/api/sync/platos/${id}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const data = await response.json();\n      if (response.ok) {\n        console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n      } else {\n        console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n        // Aunque falle la sincronización con el servidor, ya eliminamos localmente\n        // En una futura sincronización se intentará eliminar de nuevo\n      }\n    } catch (syncError) {\n      console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n      // Añadir a la cola de sincronización para intentar más tarde\n      await addToSyncQueue({\n        type: 'delete',\n        id: id,\n        timestamp: new Date().toISOString()\n      });\n    }\n    return localDeleteResult;\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  try {\n    // Validación más estricta de datos antes de intentar abrir la BD\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    console.log('✅ Validación inicial del plato exitosa');\n\n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n\n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n\n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        request.onsuccess = async event => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n\n          // Crear objeto completo con el ID\n          const createdPlato = {\n            ...platoToCreate\n          };\n\n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n\n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n\n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        request.onerror = event => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        transaction.onerror = event => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n\n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n\n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n\n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = {\n    ...platoData\n  };\n\n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' ? parseFloat(normalizedData.price) || 0 : normalizedData.price || 0;\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n\n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n\n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n\n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && normalizedData.image.length > 200000) {\n    // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n\n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n\n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n\n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n\n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n\n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n\n  // Crear una copia para no modificar el objeto original\n  const syncPlato = {\n    ...plato\n  };\n\n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n\n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n\n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n\n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n\n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n\n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n\n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n\n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n\n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n\n    // Crear una versión mínima que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n\n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n\n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async id => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\nexport { openDB, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato, debugIndexedDB, normalizePlatoData, guardarPlato,\n// Exportar la nueva función\npreparePlatoForSync, compressImageForSync, getPlato };\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,\n  // Exportar la nueva función\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","onupgradeneeded","objectStoreNames","contains","platosStore","createObjectStore","keyPath","createIndex","unique","deleteObjectStore","syncQueueStore","autoIncrement","openDB","savePlato","platoData","name","Error","transaction","store","objectStore","platoToSave","syncStatus","localTimestamp","Date","getTime","add","savedId","savedPlato","id","addToSyncQueue","type","entityType","entityId","data","timestamp","syncError","setTimeout","verificationResult","verifyPlatoStorage","warn","verifyError","message","oncomplete","getAllPlatos","getAll","platos","length","getPendingPlatos","index","pendingPlatos","updatePlatoSyncStatus","status","validStatuses","includes","join","getRequest","get","plato","is_available","updateRequest","put","close","item","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","localDeleteResult","deleteFromIndexedDB","response","fetch","API_BASE_URL","method","headers","json","ok","toISOString","deleteRequest","logDB","version","Array","from","setInterval","createPlato","trim","platoToCreate","createdAt","updatedAt","now","Math","floor","random","createdPlato","found","find","p","listError","verified","transactionError","debugIndexedDB","databases","window","syncQueue","stores","normalizePlatoData","normalizedData","price","parseFloat","availableQuantity","parseInt","includesDrink","image","image_thumbnail","compressImageForSync","has_local_image","imageDataUrl","startsWith","match","maxLength","actualData","substring","preparePlatoForSync","syncPlato","needsSimplification","_id","imageSize","maxImageSize","imageType","base64Data","reducedData","imageError","image_error","description","Number","Boolean","serializedSize","JSON","stringify","minimalPlato","oversized","guardarPlato","platoParaGuardar","platoGuardado","debugDB","getPlato"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/indexedDBService.js"],"sourcesContent":["// src/services/indexedDBService.js\n\n// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versión para forzar una actualización del esquema\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n      \n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n        platosStore.createIndex('name', 'name', { unique: false });\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n        \n        // Si necesitamos modificar un almacén existente, primero hay que eliminarlo\n        // y luego volver a crearlo con la nueva configuración\n        try {\n          db.deleteObjectStore(PLATOS_STORE);\n          console.log('Almacén de platos eliminado para recreación');\n          \n          const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n          platosStore.createIndex('name', 'name', { unique: false });\n          platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n          console.log('Almacén de platos recreado con nueva configuración');\n        } catch (error) {\n          console.error('Error al intentar modificar el almacén de platos:', error);\n        }\n      }\n      \n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\n        syncQueueStore.createIndex('type', 'type', { unique: false });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Guardar un plato en IndexedDB\nconst savePlato = async (platoData) => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n      \n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      \n      const db = await openDB();\n      \n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n      \n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      \n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      \n      request.onsuccess = async (event) => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n        \n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = { ...platoToSave, id: savedId };\n        \n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n        \n        // Verificar almacenamiento después de completar la transacción\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        \n        resolve(savedPlato);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n      \n      // Manejar errores de transacción\n      transaction.onerror = (event) => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n      \n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const platos = event.target.result;\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\n        resolve(platos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      \n      request.onsuccess = (event) => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n  \n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  \n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        \n        getRequest.onerror = (event) => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        \n        getRequest.onsuccess = (event) => {\n          const plato = event.target.result;\n          \n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n          \n          // Actualizar el estado de sincronización\n          plato.syncStatus = status;\n          \n          // Si es pending_deletion, marcar como no disponible también\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n          \n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          \n          updateRequest.onerror = (event) => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          \n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async (item) => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.add(item);\n      \n      request.onsuccess = (event) => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async (id) => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.delete(id);\n      \n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async (id) => {\n  try {\n    // Primero eliminamos el plato de IndexedDB\n    const localDeleteResult = await deleteFromIndexedDB(id);\n    \n    // Luego intentamos sincronizar con el servidor\n    try {\n      console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n      const response = await fetch(`${API_BASE_URL}/api/sync/platos/${id}`, {\n        method: 'DELETE',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      const data = await response.json();\n      \n      if (response.ok) {\n        console.log(`✅ Plato ID ${id} eliminado con éxito del servidor:`, data);\n      } else {\n        console.error(`❌ Error al eliminar plato ID ${id} del servidor:`, data);\n        // Aunque falle la sincronización con el servidor, ya eliminamos localmente\n        // En una futura sincronización se intentará eliminar de nuevo\n      }\n    } catch (syncError) {\n      console.error(`❌ Error de red al sincronizar eliminación del plato ID ${id}:`, syncError);\n      // Añadir a la cola de sincronización para intentar más tarde\n      await addToSyncQueue({\n        type: 'delete',\n        id: id,\n        timestamp: new Date().toISOString()\n      });\n    }\n    \n    return localDeleteResult;\n  } catch (error) {\n    console.error(`❌ Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Función auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async (id) => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        const deleteRequest = platosStore.delete(id);\n        \n        deleteRequest.onerror = (event) => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        \n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async (id) => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  \n  try {\n    // Validación más estricta de datos antes de intentar abrir la BD\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    \n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    console.log('✅ Validación inicial del plato exitosa');\n    \n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    \n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        \n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n        \n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n        \n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`🆔 Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        \n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        \n        request.onsuccess = async (event) => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`✅ ÉXITO: Plato guardado con ID: ${id}`);\n          \n          // Crear objeto completo con el ID\n          const createdPlato = { ...platoToCreate };\n          \n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n          \n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            \n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n          \n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          \n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        \n        request.onerror = (event) => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        \n        transaction.onerror = (event) => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        \n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Función de depuración para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  \n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n    \n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n    \n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n    \n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    \n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\n * Función auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = { ...platoData };\n  \n  // Asegurar que los campos necesarios tengan valores válidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' \n    ? parseFloat(normalizedData.price) || 0 \n    : (normalizedData.price || 0);\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n  \n  // Asegurar que los campos de fecha estén presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n  \n  // Añadir estado de sincronización si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n  \n  // Limitar el tamaño de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && \n      normalizedData.image.length > 200000) { // Si es mayor a ~200KB\n    console.warn('⚠️ Imagen demasiado grande, se reducirá para evitar problemas de sincronización');\n    \n    // Crear miniatura para sincronización\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n    \n    // Marcar que la imagen original está almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  \n  return normalizedData;\n}\n\n/**\n * Función para comprimir imágenes y reducir su tamaño para sincronización\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como está\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n    \n    // Extraer información de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('⚠️ Formato de imagen no válido para compresión');\n      return imageDataUrl;\n    }\n    \n    // Crear una versión reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una solución temporal; una implementación adecuada usaría canvas\n    // para redimensionar la imagen manteniendo la proporción\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    \n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente pequeña\n    }\n    \n    // Crear una versión recortada para sincronización\n    // Nota: En producción, sería mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n    \n  } catch (error) {\n    console.error('❌ Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronización con el servidor\n * @param {Object} plato - Plato a preparar para sincronización\n * @returns {Object} Plato optimizado para envío al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la función no existe, implementarla\n  if (!plato) {\n    console.error('❌ Error: Se intentó preparar un plato nulo para sincronización');\n    return {};\n  }\n  \n  console.log('🔄 Preparando plato para sincronización:', plato.id);\n  \n  // Crear una copia para no modificar el objeto original\n  const syncPlato = { ...plato };\n  \n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versión comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n  \n  // PASO 2: Ser aún más agresivos con el tamaño de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`📊 Tamaño original de imagen: ${imageSize} bytes`);\n    \n    // Establecer un límite mucho más estricto (50KB máximo)\n    const maxImageSize = 50000; // 50KB\n    \n    if (imageSize > maxImageSize) {\n      console.warn('⚠️ Imagen demasiado grande, reduciendo drásticamente...');\n      \n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n            \n            // Crear una versión muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            \n            console.log(`📊 Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podríamos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que debería ser pequeña\n        }\n      } catch (imageError) {\n        console.error('❌ Error al procesar imagen para sincronización:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronización\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronización';\n      }\n    }\n  }\n  \n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  \n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n  \n  // PASO 4: Asegurar que todos los campos numéricos sean realmente números\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n  \n  // PASO 5: Verificar el tamaño final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`📊 Tamaño final del plato serializado: ${serializedSize} bytes`);\n  \n  // Si aún es mayor a 100KB, tomamos medidas drásticas\n  if (serializedSize > 100000) {\n    console.warn('⚠️ ADVERTENCIA: Plato demasiado grande incluso después de optimizaciones');\n    \n    // Crear una versión mínima que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    \n    console.log('🔄 Usando versión mínima del plato para sincronización');\n    return minimalPlato;\n  }\n  \n  console.log('✅ Plato preparado para sincronización');\n  return syncPlato;\n}\n\n/**\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  \n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    \n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    \n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('✅ Datos normalizados:', platoParaGuardar);\n    \n    // Usar la función createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    \n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async (id) => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontró plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\nexport {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  // Exportar la nueva función\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};\n\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  // Exportar la nueva función\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}