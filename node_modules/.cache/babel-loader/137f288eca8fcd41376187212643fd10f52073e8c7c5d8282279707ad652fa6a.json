{"ast":null,"code":"// src/services/syncService.js\n\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\nimport { getPendingPlatos, updatePlatoSyncStatus, getSyncQueue, removeFromSyncQueue, getPlato } from './indexedDBService';\nimport { adaptPlatoData } from '../utils/dataAdapters';\n\n// Constantes desde el servicio IndexedDB\nconst API_URL = 'http://localhost:3000/api';\nconst RAW_URL = 'http://localhost:3000/raw';\n\n// Configuraci√≥n espec√≠fica para mejorar la sincronizaci√≥n\nconst SYNC_CONFIG = {\n  skipServerAvailabilityCheck: true,\n  maxPlatoSize: 30000,\n  // 30KB m√°ximo\n  retryIntervals: [5000, 15000, 30000],\n  maxRetries: 2,\n  platoUrl: `${API_URL}/platos`,\n  emergencyPlatoUrl: `${API_URL}/platos/minimal`,\n  useEmergencyEndpoint: true\n};\n\n// Estado de la sincronizaci√≥n\nlet isSyncing = false;\nlet _isOnline = navigator.onLine;\n\n// Alternativa m√°s simple para verificar la conexi√≥n\nconst isOnline = async () => {\n  // Primero comprobamos el estado de navigator.onLine\n  if (!navigator.onLine) {\n    return false;\n  }\n\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\n  try {\n    const response = await fetch(`${API_URL}/favicon.ico`, {\n      method: 'HEAD',\n      mode: 'no-cors',\n      cache: 'no-store',\n      credentials: 'omit'\n    });\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\n  } catch (error) {\n    console.error('Error al verificar estado de conexi√≥n:', error);\n    return false;\n  }\n};\n\n// Configurar escuchas para eventos de conexi√≥n\nconst setupConnectionListeners = () => {\n  window.addEventListener('online', async () => {\n    console.log('Evento online detectado');\n    _isOnline = await isOnline();\n    if (_isOnline) {\n      console.log('Conexi√≥n a Internet restablecida');\n      // Sincronizar cuando se recupera la conexi√≥n\n      syncData();\n    }\n  });\n  window.addEventListener('offline', () => {\n    console.log('Evento offline detectado');\n    _isOnline = false;\n    console.log('Conexi√≥n a Internet perdida');\n  });\n\n  // Verificar estado inicial\n  isOnline().then(online => {\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\n  });\n};\n\n// Funci√≥n para probar la conexi√≥n con el servidor (modo ultra-ligero)\nconst testServerConnection = async () => {\n  console.log('üîÑ Probando conexi√≥n con el servidor (modo emergencia)...');\n  try {\n    // Usar XMLHttpRequest sin cookies ni headers personalizados\n    const xhr = new XMLHttpRequest();\n    const responsePromise = new Promise(resolve => {\n      const timeoutId = setTimeout(() => {\n        console.warn('‚è±Ô∏è Timeout en la prueba de conexi√≥n');\n        xhr.abort();\n        resolve(false);\n      }, 5000);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          clearTimeout(timeoutId);\n          if (xhr.status >= 200 && xhr.status < 300) {\n            console.log('‚úÖ Conexi√≥n b√°sica establecida');\n            resolve(true);\n          } else if (xhr.status === 431) {\n            console.error('‚ùå Error 431: Request Header Fields Too Large');\n            console.log('üëâ Necesitas reducir el tama√±o de las cookies o headers');\n            resolve(false);\n          } else {\n            console.error(`‚ùå Error en prueba de conexi√≥n: ${xhr.status}`);\n            resolve(false);\n          }\n        }\n      };\n      xhr.onerror = function () {\n        clearTimeout(timeoutId);\n        console.error('‚ùå Error de red en prueba de conexi√≥n');\n        // Intentar con endpoint de emergencia sin headers\n        checkAlternativePort().then(resolve);\n      };\n\n      // Realizar una solicitud GET simple sin headers\n      xhr.open('GET', `${API_URL}/test/ping`, true);\n      // No a√±adir ning√∫n header\n      xhr.withCredentials = false; // Importante: evitar enviar cookies\n      xhr.send();\n    });\n    return await responsePromise;\n  } catch (error) {\n    console.error('‚ùå Error en prueba de conexi√≥n:', error);\n    return false;\n  }\n};\n\n// Comprobar puerto alternativo\nconst checkAlternativePort = async () => {\n  console.log('üîÑ Probando puertos alternativos...');\n\n  // Lista de puertos comunes para probar\n  const ports = [8080, 3000, 5000, 8000];\n  for (const port of ports) {\n    try {\n      console.log(`Probando en puerto: ${port}`);\n      const response = await fetch(`http://localhost:${port}/raw/ping`, {\n        method: 'GET',\n        mode: 'no-cors',\n        cache: 'no-store',\n        credentials: 'omit'\n      });\n      if (response.ok || response.status === 0) {\n        console.log(`‚úÖ Servidor encontrado en puerto ${port}`);\n        // Actualizar URL global para usar este puerto\n        window.SERVER_PORT = port;\n        return true;\n      }\n    } catch (error) {\n      console.log(`Puerto ${port} no disponible`);\n    }\n  }\n  console.error('‚ùå No se encontr√≥ el servidor en ning√∫n puerto com√∫n');\n  return false;\n};\n\n// Funci√≥n para probar la conexi√≥n a MySQL\nconst testMySQLConnection = async () => {\n  console.log('üîÑ Probando conexi√≥n a MySQL...');\n  try {\n    const response = await fetch(`${API_URL}/test/db`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('‚úÖ Conexi√≥n a MySQL establecida:', data);\n\n      // Mostrar informaci√≥n clara sobre la base de datos\n      if (data.data && data.data.database) {\n        console.log(`üìä Base de datos MySQL: ${data.data.database}`);\n        console.log(`üìä Tablas disponibles: ${data.data.tables.join(', ')}`);\n      }\n      return true;\n    } else {\n      console.error('‚ùå Error al conectar con MySQL:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('‚ùå Error de red al probar la conexi√≥n MySQL:', error);\n    return false;\n  }\n};\n\n// Funci√≥n para sincronizar datos entre IndexedDB y el servidor\nconst syncData = async () => {\n  console.log('‚ö†Ô∏è Sincronizaci√≥n desactivada temporalmente para evitar errores');\n  return true;\n};\n\n// M√©todo ultra-minimal usando XMLHttpRequest sin headers\nconst tryUltraMinimalSync = async (data, platoId) => {\n  try {\n    console.log('üö® Intentando sincronizaci√≥n ultra-minimal para plato:', platoId);\n\n    // Crear un objeto XMLHttpRequest directamente\n    const xhr = new XMLHttpRequest();\n\n    // Configurar una promesa para manejar la respuesta\n    const responsePromise = new Promise(resolve => {\n      // Configurar timeout\n      const timeoutId = setTimeout(() => {\n        console.warn('‚è±Ô∏è Timeout en sincronizaci√≥n ultra-minimal');\n        xhr.abort();\n        resolve(false);\n      }, 15000);\n      xhr.onreadystatechange = async function () {\n        if (xhr.readyState === 4) {\n          clearTimeout(timeoutId);\n          if (xhr.status >= 200 && xhr.status < 300) {\n            console.log('‚úÖ Sincronizaci√≥n ultra-minimal exitosa');\n            try {\n              await updatePlatoSyncStatus(platoId, 'synced');\n            } catch (dbError) {\n              console.error('Error al actualizar estado en BD:', dbError);\n            }\n            resolve(true);\n          } else {\n            console.error(`‚ùå Error en sincronizaci√≥n ultra-minimal: ${xhr.status}`);\n            resolve(false);\n          }\n        }\n      };\n      xhr.onerror = function () {\n        clearTimeout(timeoutId);\n        console.error('‚ùå Error de red en sincronizaci√≥n ultra-minimal');\n        resolve(false);\n      };\n    });\n\n    // Usar m√©todo POST con datos minimalistas\n    xhr.open('POST', `${API_URL}/platos/emergency-sync`, true);\n\n    // Solo agregar Content-Type, nada m√°s\n    xhr.setRequestHeader('Content-Type', 'application/json');\n\n    // Preparar datos ultra-minimalistas\n    const adaptedData = data; // Deshabilitado adaptPlatoData temporalmente\n    const minimalData = {\n      id: adaptedData.id,\n      name: (adaptedData.name || \"\").substring(0, 30),\n      price: Number(adaptedData.price) || 0\n    };\n\n    // Enviar los datos\n    xhr.send(JSON.stringify(minimalData));\n    return await responsePromise;\n  } catch (error) {\n    console.error('‚ùå Error en sincronizaci√≥n ultra-minimal:', error);\n    return false;\n  }\n};\n\n// Procesar la cola de sincronizaci√≥n\nconst processSyncQueue = async () => {\n  if (!(await isOnline()) || isSyncing) {\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\n    return false;\n  }\n  isSyncing = true;\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\n  try {\n    const syncItems = await getSyncQueue();\n    if (syncItems.length === 0) {\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\n      isSyncing = false;\n      return true;\n    }\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\n\n    // Procesar cada elemento de la cola\n    for (const item of syncItems) {\n      let syncSuccess = false;\n      if (item.type === 'create' && item.entityType === 'plato') {\n        syncSuccess = await syncPlatoToServer(item.data);\n      }\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\n\n      if (syncSuccess) {\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\n        await removeFromSyncQueue(item.id);\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\n      } else {\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\n      }\n    }\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\n    return true;\n  } catch (error) {\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// M√©todo de sincronizaci√≥n extremadamente simplificado para problemas persistentes\nconst syncMinimalDataOnly = async (data, platoId, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n\n  // Usar datos ultra-minimalistas para evitar problemas de tama√±o\n  const adaptedData = data; // Deshabilitado adaptPlatoData temporalmente\n  const minimalData = {\n    id: adaptedData.id,\n    name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n    price: Number(adaptedData.price) || 0,\n    description: adaptedData.description?.substring(0, 100) || '',\n    availableQuantity: Number(adaptedData.availableQuantity) || 0,\n    is_available: Boolean(adaptedData.is_available),\n    // Eliminar la imagen para esta sincronizaci√≥n\n    minimal_sync: true\n  };\n  return new Promise(resolve => {\n    // Establecer timeout para toda la operaci√≥n\n    const operationTimeoutId = setTimeout(() => {\n      console.warn('‚è±Ô∏è Timeout global de la operaci√≥n de sincronizaci√≥n');\n      resolve(false);\n    }, 30000);\n    const xhr = new XMLHttpRequest();\n\n    // Configurar timeouts m√°s estrictos\n    xhr.timeout = 15000;\n    xhr.onreadystatechange = async function () {\n      if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          clearTimeout(operationTimeoutId);\n          try {\n            await updatePlatoSyncStatus(platoId, 'synced');\n            console.log(`‚úÖ Sincronizaci√≥n exitosa para plato ${platoId}`);\n          } catch (error) {\n            console.error('Error al actualizar estado:', error);\n          }\n          resolve(true);\n        } else if (xhr.status === 0) {\n          // Conexi√≥n abortada o no establecida\n          console.warn('‚ö†Ô∏è Conexi√≥n interrumpida');\n          handleRetry();\n        } else if (xhr.status === 431) {\n          console.error(`‚ùå Error 431 (Headers demasiado grandes) - Intentando m√©todo ultraminimal`);\n          tryUltraMinimalSync(adaptedData, platoId).then(success => {\n            clearTimeout(operationTimeoutId);\n            resolve(success);\n          });\n        } else {\n          console.error(`‚ùå Error HTTP ${xhr.status} en sincronizaci√≥n`);\n          handleRetry();\n        }\n      }\n    };\n    xhr.ontimeout = function () {\n      console.warn('‚è±Ô∏è Timeout de la petici√≥n HTTP');\n      handleRetry();\n    };\n    xhr.onerror = function () {\n      console.error('‚ùå Error de red en sincronizaci√≥n');\n      handleRetry();\n    };\n\n    // Funci√≥n para manejar reintentos\n    const handleRetry = () => {\n      if (retryCount < maxRetries) {\n        const delay = SYNC_CONFIG.retryIntervals[retryCount] || 5000;\n        console.log(`üîÑ Reintentando en ${delay}ms... (${retryCount + 1}/${maxRetries})`);\n        setTimeout(() => {\n          clearTimeout(operationTimeoutId);\n          syncMinimalDataOnly(data, platoId, retryCount + 1).then(success => resolve(success));\n        }, delay);\n      } else {\n        clearTimeout(operationTimeoutId);\n        console.warn('‚ùå Agotados todos los reintentos de sincronizaci√≥n');\n        resolve(false);\n      }\n    };\n    try {\n      // Usar m√©todo POST con headers m√≠nimos\n      xhr.open('POST', `${API_URL}/platos`, true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n\n      // Enviar los datos minimalistas\n      xhr.send(JSON.stringify(minimalData));\n    } catch (error) {\n      console.error('‚ùå Error al iniciar la petici√≥n:', error);\n      handleRetry();\n    }\n  });\n};\n\n// Sincronizar un plato con el servidor\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\n  const maxRetries = SYNC_CONFIG.maxRetries;\n\n  // Si el plato est√° marcado como problem√°tico, omitirlo\n  if (plato.sync_problematic) {\n    console.warn(`‚ö†Ô∏è Omitiendo plato ${plato.id} marcado como problem√°tico para sincronizaci√≥n`);\n    return false;\n  }\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\n  try {\n    // Omitir verificaci√≥n si est√° desactivada\n    if (!SYNC_CONFIG.skipServerAvailabilityCheck) {\n      // Verificar si el servidor est√° disponible\n      const serverAvailable = await checkServerAvailability();\n      if (!serverAvailable) {\n        console.error('‚ùå El servidor no est√° disponible. Posponiendo sincronizaci√≥n.');\n        return false;\n      }\n    }\n\n    // Preparar datos ultra-minimalistas para sincronizaci√≥n\n    let adaptedData = plato; // Deshabilitado adaptPlatoData temporalmente\n    let syncData = {\n      id: adaptedData.id,\n      name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\n      price: Number(adaptedData.price) || 0,\n      description: adaptedData.description?.substring(0, 100) || '',\n      availableQuantity: Number(adaptedData.availableQuantity) || 0,\n      is_available: Boolean(adaptedData.is_available),\n      minimal_sync: true\n    };\n\n    // Usar el m√©todo m√°s confiable para sincronizaci√≥n\n    return await syncPlato(adaptedData);\n  } catch (error) {\n    console.error('‚ùå Error en sincronizaci√≥n:', error);\n    if (retryCount >= maxRetries) {\n      try {\n        await markPlatoAsSyncProblematic(plato.id);\n      } catch (markError) {\n        console.error('Error al marcar plato como problem√°tico:', markError);\n      }\n    }\n    return false;\n  }\n};\n\n// Verificar estado de sincronizaci√≥n con el backend\nconst checkSyncStatus = async () => {\n  try {\n    console.log('üîÑ Verificando estado de sincronizaci√≥n...');\n    const response = await fetch(`${API_URL}/sync/status`, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json'\n      },\n      credentials: 'omit' // Importante: no enviar cookies\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('üìä Estado de sincronizaci√≥n:', data);\n\n      // Si no existe la tabla, intentar crearla\n      if (!data.data.mysql.tablaPlatos) {\n        console.log('‚ö†Ô∏è La tabla platos no existe, intentando configurar...');\n        await setupSync();\n      }\n      return data.data;\n    } else {\n      console.error('‚ùå Error al verificar estado de sincronizaci√≥n:', await response.text());\n      return null;\n    }\n  } catch (error) {\n    console.error('‚ùå Error al verificar estado de sincronizaci√≥n:', error);\n    return null;\n  }\n};\n\n// Configurar la sincronizaci√≥n - crear tablas necesarias\nconst setupSync = async () => {\n  try {\n    console.log('üîÑ Configurando sincronizaci√≥n...');\n    const response = await fetch(`${API_URL}/sync/setup`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      credentials: 'omit',\n      body: JSON.stringify({\n        force: false\n      })\n    });\n    if (response.ok) {\n      const data = await response.json();\n      console.log('‚úÖ Configuraci√≥n de sincronizaci√≥n completada:', data);\n      return true;\n    } else {\n      console.error('‚ùå Error al configurar sincronizaci√≥n:', await response.text());\n      return false;\n    }\n  } catch (error) {\n    console.error('‚ùå Error al configurar sincronizaci√≥n:', error);\n    return false;\n  }\n};\n\n// Inicializar el servicio de sincronizaci√≥n\nconst initSyncService = () => {\n  console.log('üîÑ Inicializando servicio de sincronizaci√≥n...');\n\n  // Probar conexiones y configurar sincronizaci√≥n\n  Promise.all([testServerConnection(), checkSyncStatus()]).then(([isApiConnected, syncStatus]) => {\n    console.log(`‚úÖ Estado de conexi√≥n directa - API: ${isApiConnected}`);\n    if (isApiConnected) {\n      // Configurar escuchas para eventos de conexi√≥n\n      setupConnectionListeners();\n\n      // Si hay estado de sincronizaci√≥n, proceder con la sincronizaci√≥n\n      if (syncStatus && syncStatus.mysql && syncStatus.mysql.connected) {\n        console.log('üìä MySQL conectado, procediendo con sincronizaci√≥n');\n        syncData();\n\n        // Reactivar la sincronizaci√≥n peri√≥dica (cada 1 minuto)\n        const syncInterval = setInterval(syncData, 60000);\n      } else {\n        console.log('‚ö†Ô∏è MySQL no est√° configurado correctamente, intentando configurar...');\n        setupSync().then(success => {\n          if (success) {\n            console.log('‚úÖ Configuraci√≥n exitosa, iniciando sincronizaci√≥n');\n            syncData();\n\n            // Reactivar la sincronizaci√≥n peri√≥dica (cada 1 minuto)\n            const syncInterval = setInterval(syncData, 60000);\n          }\n        });\n      }\n    } else {\n      console.error('‚ùå No se pudo establecer conexi√≥n con el servidor.');\n    }\n  });\n  console.log('‚öôÔ∏è Servicio de sincronizaci√≥n inicializado');\n};\n\n// Exportar las funciones necesarias\nexport { initSyncService, syncData, isOnline, _isOnline, testServerConnection, testMySQLConnection, checkSyncStatus, setupSync };\n\n// Aseg√∫rate de que la funci√≥n que maneja la sincronizaci√≥n tenga un mejor manejo de errores\n\nconst syncPlato = async plato => {\n  console.log(`üîÑ Sincronizando plato: ${plato.name} (ID: ${plato.id})`);\n  try {\n    // Preparar los datos para enviar (omitir campos locales)\n    const platoToSync = {\n      name: plato.name,\n      description: plato.description || '',\n      price: parseFloat(plato.price) || 0,\n      category: plato.category || 'principal',\n      image_url: plato.image_url || '',\n      is_available: plato.is_available !== false\n    };\n    console.log('üì§ Datos a enviar:', platoToSync);\n\n    // Imprimir la URL exacta para depuraci√≥n\n    const url = `${API_URL}/menu-items`;\n    console.log(`üîó URL de sincronizaci√≥n: ${url}`);\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(platoToSync),\n      // Evitar que se incluyan cookies u otros datos de autenticaci√≥n si no son necesarios\n      credentials: 'omit'\n    });\n    console.log(`üì• Respuesta del servidor: ${response.status}`);\n    if (response.ok) {\n      const data = await response.json();\n      console.log('‚úÖ Sincronizaci√≥n exitosa:', data);\n\n      // Actualizar el estado del plato a 'synced'\n      await updatePlatoSyncStatus(plato.id, 'synced');\n      return {\n        success: true,\n        data\n      };\n    } else {\n      // Intentar obtener informaci√≥n de error\n      let errorText = '';\n      try {\n        errorText = await response.text();\n      } catch (e) {\n        errorText = 'No se pudo obtener texto de error';\n      }\n      console.error(`‚ùå Error en sincronizaci√≥n: ${response.status}`, errorText);\n\n      // Registrar informaci√≥n detallada para depuraci√≥n\n      console.log(`üìã Detalles de la sincronizaci√≥n:\n        - URL: ${url}\n        - M√©todo: POST\n        - Plato ID: ${plato.id}\n        - Nombre: ${plato.name}\n        - C√≥digo de respuesta: ${response.status}\n        - Texto de error: ${errorText}\n      `);\n      return {\n        success: false,\n        status: response.status,\n        error: errorText\n      };\n    }\n  } catch (error) {\n    console.error('‚ùå Error de red en sincronizaci√≥n:', error);\n    return {\n      success: false,\n      error: error.message || 'Error de red desconocido'\n    };\n  }\n};","map":{"version":3,"names":["getPendingPlatos","updatePlatoSyncStatus","getSyncQueue","removeFromSyncQueue","getPlato","adaptPlatoData","API_URL","RAW_URL","SYNC_CONFIG","skipServerAvailabilityCheck","maxPlatoSize","retryIntervals","maxRetries","platoUrl","emergencyPlatoUrl","useEmergencyEndpoint","isSyncing","_isOnline","navigator","onLine","isOnline","response","fetch","method","mode","cache","credentials","error","console","setupConnectionListeners","window","addEventListener","log","syncData","then","online","testServerConnection","xhr","XMLHttpRequest","responsePromise","Promise","resolve","timeoutId","setTimeout","warn","abort","onreadystatechange","readyState","clearTimeout","status","onerror","checkAlternativePort","open","withCredentials","send","ports","port","ok","SERVER_PORT","testMySQLConnection","headers","data","json","database","tables","join","text","tryUltraMinimalSync","platoId","dbError","setRequestHeader","adaptedData","minimalData","id","name","substring","price","Number","JSON","stringify","processSyncQueue","syncItems","length","item","syncSuccess","type","entityType","syncPlatoToServer","syncMinimalDataOnly","retryCount","description","availableQuantity","is_available","Boolean","minimal_sync","operationTimeoutId","timeout","handleRetry","success","ontimeout","delay","plato","sync_problematic","serverAvailable","checkServerAvailability","syncPlato","markPlatoAsSyncProblematic","markError","checkSyncStatus","mysql","tablaPlatos","setupSync","body","force","initSyncService","all","isApiConnected","syncStatus","connected","syncInterval","setInterval","platoToSync","parseFloat","category","image_url","url","errorText","e","message"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/syncService.js"],"sourcesContent":["// src/services/syncService.js\r\n\r\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\r\nimport { \r\n  getPendingPlatos, \r\n  updatePlatoSyncStatus, \r\n  getSyncQueue, \r\n  removeFromSyncQueue,\r\n  getPlato\r\n} from './indexedDBService';\r\nimport { adaptPlatoData } from '../utils/dataAdapters';\r\n\r\n// Constantes desde el servicio IndexedDB\r\nconst API_URL = 'http://localhost:3000/api';\r\nconst RAW_URL = 'http://localhost:3000/raw';\r\n\r\n// Configuraci√≥n espec√≠fica para mejorar la sincronizaci√≥n\r\nconst SYNC_CONFIG = {\r\n  skipServerAvailabilityCheck: true,\r\n  maxPlatoSize: 30000, // 30KB m√°ximo\r\n  retryIntervals: [5000, 15000, 30000],\r\n  maxRetries: 2,\r\n  platoUrl: `${API_URL}/platos`,\r\n  emergencyPlatoUrl: `${API_URL}/platos/minimal`,\r\n  useEmergencyEndpoint: true\r\n};\r\n\r\n// Estado de la sincronizaci√≥n\r\nlet isSyncing = false;\r\nlet _isOnline = navigator.onLine;\r\n\r\n// Alternativa m√°s simple para verificar la conexi√≥n\r\nconst isOnline = async () => {\r\n  // Primero comprobamos el estado de navigator.onLine\r\n  if (!navigator.onLine) {\r\n    return false;\r\n  }\r\n  \r\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\r\n  try {\r\n    const response = await fetch(`${API_URL}/favicon.ico`, {\r\n      method: 'HEAD',\r\n      mode: 'no-cors',\r\n      cache: 'no-store',\r\n      credentials: 'omit'\r\n    });\r\n    \r\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\r\n  } catch (error) {\r\n    console.error('Error al verificar estado de conexi√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Configurar escuchas para eventos de conexi√≥n\r\nconst setupConnectionListeners = () => {\r\n  window.addEventListener('online', async () => {\r\n    console.log('Evento online detectado');\r\n    _isOnline = await isOnline();\r\n    if (_isOnline) {\r\n      console.log('Conexi√≥n a Internet restablecida');\r\n      // Sincronizar cuando se recupera la conexi√≥n\r\n      syncData();\r\n    }\r\n  });\r\n  \r\n  window.addEventListener('offline', () => {\r\n    console.log('Evento offline detectado');\r\n    _isOnline = false;\r\n    console.log('Conexi√≥n a Internet perdida');\r\n  });\r\n  \r\n  // Verificar estado inicial\r\n  isOnline().then(online => {\r\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\r\n  });\r\n};\r\n\r\n// Funci√≥n para probar la conexi√≥n con el servidor (modo ultra-ligero)\r\nconst testServerConnection = async () => {\r\n  console.log('üîÑ Probando conexi√≥n con el servidor (modo emergencia)...');\r\n  \r\n  try {\r\n    // Usar XMLHttpRequest sin cookies ni headers personalizados\r\n    const xhr = new XMLHttpRequest();\r\n    \r\n    const responsePromise = new Promise((resolve) => {\r\n      const timeoutId = setTimeout(() => {\r\n        console.warn('‚è±Ô∏è Timeout en la prueba de conexi√≥n');\r\n        xhr.abort();\r\n        resolve(false);\r\n      }, 5000);\r\n      \r\n      xhr.onreadystatechange = function() {\r\n        if (xhr.readyState === 4) {\r\n          clearTimeout(timeoutId);\r\n          if (xhr.status >= 200 && xhr.status < 300) {\r\n            console.log('‚úÖ Conexi√≥n b√°sica establecida');\r\n            resolve(true);\r\n          } else if (xhr.status === 431) {\r\n            console.error('‚ùå Error 431: Request Header Fields Too Large');\r\n            console.log('üëâ Necesitas reducir el tama√±o de las cookies o headers');\r\n            resolve(false);\r\n          } else {\r\n            console.error(`‚ùå Error en prueba de conexi√≥n: ${xhr.status}`);\r\n            resolve(false);\r\n          }\r\n        }\r\n      };\r\n      \r\n      xhr.onerror = function() {\r\n        clearTimeout(timeoutId);\r\n        console.error('‚ùå Error de red en prueba de conexi√≥n');\r\n        // Intentar con endpoint de emergencia sin headers\r\n        checkAlternativePort().then(resolve);\r\n      };\r\n      \r\n      // Realizar una solicitud GET simple sin headers\r\n      xhr.open('GET', `${API_URL}/test/ping`, true);\r\n      // No a√±adir ning√∫n header\r\n      xhr.withCredentials = false; // Importante: evitar enviar cookies\r\n      xhr.send();\r\n    });\r\n    \r\n    return await responsePromise;\r\n  } catch (error) {\r\n    console.error('‚ùå Error en prueba de conexi√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Comprobar puerto alternativo\r\nconst checkAlternativePort = async () => {\r\n  console.log('üîÑ Probando puertos alternativos...');\r\n  \r\n  // Lista de puertos comunes para probar\r\n  const ports = [8080, 3000, 5000, 8000];\r\n  \r\n  for (const port of ports) {\r\n    try {\r\n      console.log(`Probando en puerto: ${port}`);\r\n      const response = await fetch(`http://localhost:${port}/raw/ping`, {\r\n        method: 'GET',\r\n        mode: 'no-cors',\r\n        cache: 'no-store',\r\n        credentials: 'omit'\r\n      });\r\n      \r\n      if (response.ok || response.status === 0) {\r\n        console.log(`‚úÖ Servidor encontrado en puerto ${port}`);\r\n        // Actualizar URL global para usar este puerto\r\n        window.SERVER_PORT = port;\r\n        return true;\r\n      }\r\n    } catch (error) {\r\n      console.log(`Puerto ${port} no disponible`);\r\n    }\r\n  }\r\n  \r\n  console.error('‚ùå No se encontr√≥ el servidor en ning√∫n puerto com√∫n');\r\n  return false;\r\n};\r\n\r\n// Funci√≥n para probar la conexi√≥n a MySQL\r\nconst testMySQLConnection = async () => {\r\n  console.log('üîÑ Probando conexi√≥n a MySQL...');\r\n  \r\n  try {\r\n    const response = await fetch(`${API_URL}/test/db`, {\r\n      method: 'GET',\r\n      headers: {\r\n        'Accept': 'application/json'\r\n      }\r\n    });\r\n    \r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      console.log('‚úÖ Conexi√≥n a MySQL establecida:', data);\r\n      \r\n      // Mostrar informaci√≥n clara sobre la base de datos\r\n      if (data.data && data.data.database) {\r\n        console.log(`üìä Base de datos MySQL: ${data.data.database}`);\r\n        console.log(`üìä Tablas disponibles: ${data.data.tables.join(', ')}`);\r\n      }\r\n      \r\n      return true;\r\n    } else {\r\n      console.error('‚ùå Error al conectar con MySQL:', await response.text());\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå Error de red al probar la conexi√≥n MySQL:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Funci√≥n para sincronizar datos entre IndexedDB y el servidor\r\nconst syncData = async () => {\r\n  console.log('‚ö†Ô∏è Sincronizaci√≥n desactivada temporalmente para evitar errores');\r\n  return true;\r\n};\r\n\r\n// M√©todo ultra-minimal usando XMLHttpRequest sin headers\r\nconst tryUltraMinimalSync = async (data, platoId) => {\r\n  try {\r\n    console.log('üö® Intentando sincronizaci√≥n ultra-minimal para plato:', platoId);\r\n    \r\n    // Crear un objeto XMLHttpRequest directamente\r\n    const xhr = new XMLHttpRequest();\r\n    \r\n    // Configurar una promesa para manejar la respuesta\r\n    const responsePromise = new Promise((resolve) => {\r\n      // Configurar timeout\r\n      const timeoutId = setTimeout(() => {\r\n        console.warn('‚è±Ô∏è Timeout en sincronizaci√≥n ultra-minimal');\r\n        xhr.abort();\r\n        resolve(false);\r\n      }, 15000);\r\n      \r\n      xhr.onreadystatechange = async function() {\r\n        if (xhr.readyState === 4) {\r\n          clearTimeout(timeoutId);\r\n          if (xhr.status >= 200 && xhr.status < 300) {\r\n            console.log('‚úÖ Sincronizaci√≥n ultra-minimal exitosa');\r\n            try {\r\n              await updatePlatoSyncStatus(platoId, 'synced');\r\n            } catch (dbError) {\r\n              console.error('Error al actualizar estado en BD:', dbError);\r\n            }\r\n            resolve(true);\r\n          } else {\r\n            console.error(`‚ùå Error en sincronizaci√≥n ultra-minimal: ${xhr.status}`);\r\n            resolve(false);\r\n          }\r\n        }\r\n      };\r\n      \r\n      xhr.onerror = function() {\r\n        clearTimeout(timeoutId);\r\n        console.error('‚ùå Error de red en sincronizaci√≥n ultra-minimal');\r\n        resolve(false);\r\n      };\r\n    });\r\n    \r\n    // Usar m√©todo POST con datos minimalistas\r\n    xhr.open('POST', `${API_URL}/platos/emergency-sync`, true);\r\n    \r\n    // Solo agregar Content-Type, nada m√°s\r\n    xhr.setRequestHeader('Content-Type', 'application/json');\r\n    \r\n    // Preparar datos ultra-minimalistas\r\n    const adaptedData = data; // Deshabilitado adaptPlatoData temporalmente\r\n    const minimalData = {\r\n      id: adaptedData.id,\r\n      name: (adaptedData.name || \"\").substring(0, 30),\r\n      price: Number(adaptedData.price) || 0\r\n    };\r\n    \r\n    // Enviar los datos\r\n    xhr.send(JSON.stringify(minimalData));\r\n    \r\n    return await responsePromise;\r\n  } catch (error) {\r\n    console.error('‚ùå Error en sincronizaci√≥n ultra-minimal:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Procesar la cola de sincronizaci√≥n\r\nconst processSyncQueue = async () => {\r\n  if (!await isOnline() || isSyncing) {\r\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\r\n    return false;\r\n  }\r\n  \r\n  isSyncing = true;\r\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\r\n  \r\n  try {\r\n    const syncItems = await getSyncQueue();\r\n    \r\n    if (syncItems.length === 0) {\r\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\r\n      isSyncing = false;\r\n      return true;\r\n    }\r\n    \r\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\r\n    \r\n    // Procesar cada elemento de la cola\r\n    for (const item of syncItems) {\r\n      let syncSuccess = false;\r\n      \r\n      if (item.type === 'create' && item.entityType === 'plato') {\r\n        syncSuccess = await syncPlatoToServer(item.data);\r\n      }\r\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\r\n      \r\n      if (syncSuccess) {\r\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\r\n        await removeFromSyncQueue(item.id);\r\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\r\n      } else {\r\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\r\n      }\r\n    }\r\n    \r\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\r\n    return false;\r\n  } finally {\r\n    isSyncing = false;\r\n  }\r\n};\r\n\r\n// M√©todo de sincronizaci√≥n extremadamente simplificado para problemas persistentes\r\nconst syncMinimalDataOnly = async (data, platoId, retryCount = 0) => {\r\n  const maxRetries = SYNC_CONFIG.maxRetries;\r\n  \r\n  // Usar datos ultra-minimalistas para evitar problemas de tama√±o\r\n  const adaptedData = data; // Deshabilitado adaptPlatoData temporalmente\r\n  const minimalData = {\r\n    id: adaptedData.id,\r\n    name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\r\n    price: Number(adaptedData.price) || 0,\r\n    description: adaptedData.description?.substring(0, 100) || '',\r\n    availableQuantity: Number(adaptedData.availableQuantity) || 0,\r\n    is_available: Boolean(adaptedData.is_available),\r\n    // Eliminar la imagen para esta sincronizaci√≥n\r\n    minimal_sync: true\r\n  };\r\n  \r\n  return new Promise((resolve) => {\r\n    // Establecer timeout para toda la operaci√≥n\r\n    const operationTimeoutId = setTimeout(() => {\r\n      console.warn('‚è±Ô∏è Timeout global de la operaci√≥n de sincronizaci√≥n');\r\n      resolve(false);\r\n    }, 30000);\r\n    \r\n    const xhr = new XMLHttpRequest();\r\n    \r\n    // Configurar timeouts m√°s estrictos\r\n    xhr.timeout = 15000;\r\n    \r\n    xhr.onreadystatechange = async function() {\r\n      if (xhr.readyState === 4) {\r\n        if (xhr.status >= 200 && xhr.status < 300) {\r\n          clearTimeout(operationTimeoutId);\r\n          try {\r\n            await updatePlatoSyncStatus(platoId, 'synced');\r\n            console.log(`‚úÖ Sincronizaci√≥n exitosa para plato ${platoId}`);\r\n          } catch (error) {\r\n            console.error('Error al actualizar estado:', error);\r\n          }\r\n          resolve(true);\r\n        } else if (xhr.status === 0) {\r\n          // Conexi√≥n abortada o no establecida\r\n          console.warn('‚ö†Ô∏è Conexi√≥n interrumpida');\r\n          handleRetry();\r\n        } else if (xhr.status === 431) {\r\n          console.error(`‚ùå Error 431 (Headers demasiado grandes) - Intentando m√©todo ultraminimal`);\r\n          tryUltraMinimalSync(adaptedData, platoId).then(success => {\r\n            clearTimeout(operationTimeoutId);\r\n            resolve(success);\r\n          });\r\n        } else {\r\n          console.error(`‚ùå Error HTTP ${xhr.status} en sincronizaci√≥n`);\r\n          handleRetry();\r\n        }\r\n      }\r\n    };\r\n    \r\n    xhr.ontimeout = function() {\r\n      console.warn('‚è±Ô∏è Timeout de la petici√≥n HTTP');\r\n      handleRetry();\r\n    };\r\n    \r\n    xhr.onerror = function() {\r\n      console.error('‚ùå Error de red en sincronizaci√≥n');\r\n      handleRetry();\r\n    };\r\n    \r\n    // Funci√≥n para manejar reintentos\r\n    const handleRetry = () => {\r\n      if (retryCount < maxRetries) {\r\n        const delay = SYNC_CONFIG.retryIntervals[retryCount] || 5000;\r\n        console.log(`üîÑ Reintentando en ${delay}ms... (${retryCount + 1}/${maxRetries})`);\r\n        \r\n        setTimeout(() => {\r\n          clearTimeout(operationTimeoutId);\r\n          syncMinimalDataOnly(data, platoId, retryCount + 1)\r\n            .then(success => resolve(success));\r\n        }, delay);\r\n      } else {\r\n        clearTimeout(operationTimeoutId);\r\n        console.warn('‚ùå Agotados todos los reintentos de sincronizaci√≥n');\r\n        resolve(false);\r\n      }\r\n    };\r\n    \r\n    try {\r\n      // Usar m√©todo POST con headers m√≠nimos\r\n      xhr.open('POST', `${API_URL}/platos`, true);\r\n      xhr.setRequestHeader('Content-Type', 'application/json');\r\n      \r\n      // Enviar los datos minimalistas\r\n      xhr.send(JSON.stringify(minimalData));\r\n    } catch (error) {\r\n      console.error('‚ùå Error al iniciar la petici√≥n:', error);\r\n      handleRetry();\r\n    }\r\n  });\r\n};\r\n\r\n// Sincronizar un plato con el servidor\r\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\r\n  const maxRetries = SYNC_CONFIG.maxRetries;\r\n  \r\n  // Si el plato est√° marcado como problem√°tico, omitirlo\r\n  if (plato.sync_problematic) {\r\n    console.warn(`‚ö†Ô∏è Omitiendo plato ${plato.id} marcado como problem√°tico para sincronizaci√≥n`);\r\n    return false;\r\n  }\r\n  \r\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\r\n  \r\n  try {\r\n    // Omitir verificaci√≥n si est√° desactivada\r\n    if (!SYNC_CONFIG.skipServerAvailabilityCheck) {\r\n      // Verificar si el servidor est√° disponible\r\n      const serverAvailable = await checkServerAvailability();\r\n      if (!serverAvailable) {\r\n        console.error('‚ùå El servidor no est√° disponible. Posponiendo sincronizaci√≥n.');\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    // Preparar datos ultra-minimalistas para sincronizaci√≥n\r\n    let adaptedData = plato; // Deshabilitado adaptPlatoData temporalmente\r\n    let syncData = {\r\n      id: adaptedData.id,\r\n      name: adaptedData.name?.substring(0, 50) || 'Plato sin nombre',\r\n      price: Number(adaptedData.price) || 0,\r\n      description: adaptedData.description?.substring(0, 100) || '',\r\n      availableQuantity: Number(adaptedData.availableQuantity) || 0,\r\n      is_available: Boolean(adaptedData.is_available),\r\n      minimal_sync: true\r\n    };\r\n    \r\n    // Usar el m√©todo m√°s confiable para sincronizaci√≥n\r\n    return await syncPlato(adaptedData);\r\n  } catch (error) {\r\n    console.error('‚ùå Error en sincronizaci√≥n:', error);\r\n    \r\n    if (retryCount >= maxRetries) {\r\n      try {\r\n        await markPlatoAsSyncProblematic(plato.id);\r\n      } catch (markError) {\r\n        console.error('Error al marcar plato como problem√°tico:', markError);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n};\r\n\r\n// Verificar estado de sincronizaci√≥n con el backend\r\nconst checkSyncStatus = async () => {\r\n  try {\r\n    console.log('üîÑ Verificando estado de sincronizaci√≥n...');\r\n    \r\n    const response = await fetch(`${API_URL}/sync/status`, {\r\n      method: 'GET',\r\n      headers: { 'Accept': 'application/json' },\r\n      credentials: 'omit' // Importante: no enviar cookies\r\n    });\r\n    \r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      console.log('üìä Estado de sincronizaci√≥n:', data);\r\n      \r\n      // Si no existe la tabla, intentar crearla\r\n      if (!data.data.mysql.tablaPlatos) {\r\n        console.log('‚ö†Ô∏è La tabla platos no existe, intentando configurar...');\r\n        await setupSync();\r\n      }\r\n      \r\n      return data.data;\r\n    } else {\r\n      console.error('‚ùå Error al verificar estado de sincronizaci√≥n:', await response.text());\r\n      return null;\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå Error al verificar estado de sincronizaci√≥n:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Configurar la sincronizaci√≥n - crear tablas necesarias\r\nconst setupSync = async () => {\r\n  try {\r\n    console.log('üîÑ Configurando sincronizaci√≥n...');\r\n    \r\n    const response = await fetch(`${API_URL}/sync/setup`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      credentials: 'omit',\r\n      body: JSON.stringify({ force: false })\r\n    });\r\n    \r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      console.log('‚úÖ Configuraci√≥n de sincronizaci√≥n completada:', data);\r\n      return true;\r\n    } else {\r\n      console.error('‚ùå Error al configurar sincronizaci√≥n:', await response.text());\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå Error al configurar sincronizaci√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Inicializar el servicio de sincronizaci√≥n\r\nconst initSyncService = () => {\r\n  console.log('üîÑ Inicializando servicio de sincronizaci√≥n...');\r\n  \r\n  // Probar conexiones y configurar sincronizaci√≥n\r\n  Promise.all([\r\n    testServerConnection(),\r\n    checkSyncStatus()\r\n  ]).then(([isApiConnected, syncStatus]) => {\r\n    console.log(`‚úÖ Estado de conexi√≥n directa - API: ${isApiConnected}`);\r\n    \r\n    if (isApiConnected) {\r\n      // Configurar escuchas para eventos de conexi√≥n\r\n      setupConnectionListeners();\r\n      \r\n      // Si hay estado de sincronizaci√≥n, proceder con la sincronizaci√≥n\r\n      if (syncStatus && syncStatus.mysql && syncStatus.mysql.connected) {\r\n        console.log('üìä MySQL conectado, procediendo con sincronizaci√≥n');\r\n        syncData();\r\n        \r\n        // Reactivar la sincronizaci√≥n peri√≥dica (cada 1 minuto)\r\n        const syncInterval = setInterval(syncData, 60000);\r\n      } else {\r\n        console.log('‚ö†Ô∏è MySQL no est√° configurado correctamente, intentando configurar...');\r\n        setupSync().then(success => {\r\n          if (success) {\r\n            console.log('‚úÖ Configuraci√≥n exitosa, iniciando sincronizaci√≥n');\r\n            syncData();\r\n            \r\n            // Reactivar la sincronizaci√≥n peri√≥dica (cada 1 minuto)\r\n            const syncInterval = setInterval(syncData, 60000);\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      console.error('‚ùå No se pudo establecer conexi√≥n con el servidor.');\r\n    }\r\n  });\r\n  \r\n  console.log('‚öôÔ∏è Servicio de sincronizaci√≥n inicializado');\r\n};\r\n\r\n// Exportar las funciones necesarias\r\nexport {\r\n  initSyncService,\r\n  syncData,\r\n  isOnline,\r\n  _isOnline,\r\n  testServerConnection,\r\n  testMySQLConnection,\r\n  checkSyncStatus,\r\n  setupSync\r\n};\r\n\r\n// Aseg√∫rate de que la funci√≥n que maneja la sincronizaci√≥n tenga un mejor manejo de errores\r\n\r\nconst syncPlato = async (plato) => {\r\n  console.log(`üîÑ Sincronizando plato: ${plato.name} (ID: ${plato.id})`);\r\n  \r\n  try {\r\n    // Preparar los datos para enviar (omitir campos locales)\r\n    const platoToSync = {\r\n      name: plato.name,\r\n      description: plato.description || '',\r\n      price: parseFloat(plato.price) || 0,\r\n      category: plato.category || 'principal',\r\n      image_url: plato.image_url || '',\r\n      is_available: plato.is_available !== false\r\n    };\r\n    \r\n    console.log('üì§ Datos a enviar:', platoToSync);\r\n    \r\n    // Imprimir la URL exacta para depuraci√≥n\r\n    const url = `${API_URL}/menu-items`;\r\n    console.log(`üîó URL de sincronizaci√≥n: ${url}`);\r\n    \r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(platoToSync),\r\n      // Evitar que se incluyan cookies u otros datos de autenticaci√≥n si no son necesarios\r\n      credentials: 'omit'\r\n    });\r\n    \r\n    console.log(`üì• Respuesta del servidor: ${response.status}`);\r\n    \r\n    if (response.ok) {\r\n      const data = await response.json();\r\n      console.log('‚úÖ Sincronizaci√≥n exitosa:', data);\r\n      \r\n      // Actualizar el estado del plato a 'synced'\r\n      await updatePlatoSyncStatus(plato.id, 'synced');\r\n      \r\n      return { success: true, data };\r\n    } else {\r\n      // Intentar obtener informaci√≥n de error\r\n      let errorText = '';\r\n      try {\r\n        errorText = await response.text();\r\n      } catch (e) {\r\n        errorText = 'No se pudo obtener texto de error';\r\n      }\r\n      \r\n      console.error(`‚ùå Error en sincronizaci√≥n: ${response.status}`, errorText);\r\n      \r\n      // Registrar informaci√≥n detallada para depuraci√≥n\r\n      console.log(`üìã Detalles de la sincronizaci√≥n:\r\n        - URL: ${url}\r\n        - M√©todo: POST\r\n        - Plato ID: ${plato.id}\r\n        - Nombre: ${plato.name}\r\n        - C√≥digo de respuesta: ${response.status}\r\n        - Texto de error: ${errorText}\r\n      `);\r\n      \r\n      return { \r\n        success: false, \r\n        status: response.status,\r\n        error: errorText\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå Error de red en sincronizaci√≥n:', error);\r\n    return { \r\n      success: false, \r\n      error: error.message || 'Error de red desconocido'\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}