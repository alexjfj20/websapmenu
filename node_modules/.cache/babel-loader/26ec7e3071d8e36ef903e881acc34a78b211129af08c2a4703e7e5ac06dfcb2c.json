{"ast":null,"code":"// src/services/businessInfoService.js\n\nimport apiService from './apiService';\nimport { getBusinessInfo, saveBusinessInfo } from './storageService';\nimport eventBus from '../utils/eventBus';\n\n// Constantes para la sincronización\nconst SYNC_INTERVAL = 30000; // 30 segundos\nconst CACHE_DURATION = 300000; // 5 minutos\nlet syncIntervalId = null;\nlet lastSyncTimestamp = 0;\nlet lastFetchTimestamp = 0;\nlet businessInfoCache = null;\nlet isInitialized = false;\n\n/**\n * Sincroniza la información del negocio guardada en IndexedDB con el backend\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend() {\n  try {\n    // Obtener la información del negocio desde IndexedDB\n    const businessInfo = await getBusinessInfo();\n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.log('No hay información del negocio para sincronizar');\n      return {\n        success: false,\n        message: 'No hay información del negocio para sincronizar'\n      };\n    }\n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n\n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n\n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return {\n        success: false,\n        message: 'No se pudo obtener el restaurante del usuario actual'\n      };\n    }\n    const restauranteId = userResponse.user.restaurante_id;\n\n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name,\n      descripcion: businessInfo.description,\n      direccion: businessInfo.address,\n      telefono: businessInfo.contact,\n      logo: businessInfo.logo,\n      // Guardar la información de pago como un campo JSON\n      informacion_pago: JSON.stringify(businessInfo.paymentInfo || {})\n    };\n\n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      lastSyncTimestamp = Date.now();\n\n      // Notificar a todos los componentes que la información ha sido sincronizada\n      eventBus.emit('business-info-updated', businessInfo);\n      return {\n        success: true,\n        message: 'Información del negocio sincronizada con éxito',\n        timestamp: lastSyncTimestamp\n      };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return {\n        success: false,\n        message: response.message || 'Error al sincronizar información del negocio'\n      };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al sincronizar información del negocio'\n    };\n  }\n}\n\n/**\n * Obtiene la información del negocio desde el backend y la guarda en IndexedDB\n * @param {boolean} forceUpdate - Forzar la actualización aunque esté en caché\n * @returns {Promise<Object>} - Información del negocio\n */\nexport async function fetchBusinessInfoFromBackend(forceUpdate = false) {\n  try {\n    // Si tenemos información en caché y no ha pasado el tiempo de caché, usarla\n    const now = Date.now();\n    if (businessInfoCache && !forceUpdate && now - lastFetchTimestamp < CACHE_DURATION) {\n      console.log('Usando información de negocio en caché');\n      return businessInfoCache;\n    }\n\n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n\n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      throw new Error('No se pudo obtener el restaurante del usuario actual');\n    }\n    const restauranteId = userResponse.user.restaurante_id;\n\n    // Obtener el restaurante del backend\n    const response = await apiService.get(`/restaurantes/${restauranteId}`);\n    if (response && response.success && response.restaurante) {\n      const restaurante = response.restaurante;\n\n      // Convertir la información a formato de negocio\n      let paymentInfo = {};\n      try {\n        if (restaurante.informacion_pago) {\n          paymentInfo = JSON.parse(restaurante.informacion_pago);\n        }\n      } catch (e) {\n        console.warn('Error al parsear información de pago:', e);\n      }\n      const businessInfo = {\n        name: restaurante.nombre,\n        description: restaurante.descripcion,\n        address: restaurante.direccion,\n        contact: restaurante.telefono,\n        logo: restaurante.logo,\n        paymentInfo\n      };\n\n      // Guardar en IndexedDB\n      await saveBusinessInfo(businessInfo);\n\n      // Actualizar caché y timestamp\n      businessInfoCache = businessInfo;\n      lastFetchTimestamp = now;\n\n      // Notificar a todos los componentes que la información ha sido actualizada\n      eventBus.emit('business-info-updated', businessInfo);\n      console.log('Información del negocio obtenida con éxito:', businessInfo);\n      return businessInfo;\n    } else {\n      console.warn('Error al obtener información del negocio:', response);\n      throw new Error(response?.message || 'Error al obtener información del negocio');\n    }\n  } catch (error) {\n    console.error('Error al obtener información del negocio desde el backend:', error);\n\n    // Si hay un error, intentar obtener la información desde IndexedDB\n    try {\n      const businessInfo = await getBusinessInfo();\n      if (businessInfo) {\n        return businessInfo;\n      }\n    } catch (localError) {\n      console.error('Error al obtener información local:', localError);\n    }\n    throw error;\n  }\n}\n\n/**\n * Actualiza la información del negocio en IndexedDB y la sincroniza con el backend\n * @param {Object} businessInfo - Nueva información del negocio\n * @returns {Promise<Object>} - Resultado de la actualización\n */\nexport async function updateBusinessInfo(businessInfo) {\n  try {\n    // Guardar en IndexedDB\n    await saveBusinessInfo(businessInfo);\n\n    // Actualizar caché y timestamp\n    businessInfoCache = businessInfo;\n    lastFetchTimestamp = Date.now();\n\n    // Notificar a todos los componentes que la información ha sido actualizada\n    eventBus.emit('business-info-updated', businessInfo);\n\n    // Sincronizar con el backend\n    const syncResult = await syncBusinessInfoWithBackend();\n    return {\n      success: true,\n      message: 'Información del negocio actualizada con éxito',\n      syncResult\n    };\n  } catch (error) {\n    console.error('Error al actualizar información del negocio:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar información del negocio'\n    };\n  }\n}\n\n/**\n * Verifica si hay cambios en la información del negocio\n * @returns {Promise<boolean>} - True si hay cambios, false si no\n */\nexport async function checkForBusinessInfoChanges() {\n  try {\n    // Obtener información actual desde IndexedDB\n    const localInfo = await getBusinessInfo();\n\n    // Obtener información desde el backend\n    const backendInfo = await fetchBusinessInfoFromBackend(true);\n\n    // Comparar ambas informaciones\n    const localString = JSON.stringify(localInfo);\n    const backendString = JSON.stringify(backendInfo);\n    const hasChanges = localString !== backendString;\n    if (hasChanges) {\n      console.log('Se detectaron cambios en la información del negocio');\n\n      // Actualizar la información local con la del backend\n      await saveBusinessInfo(backendInfo);\n\n      // Notificar a todos los componentes\n      eventBus.emit('business-info-updated', backendInfo);\n    }\n    return hasChanges;\n  } catch (error) {\n    console.error('Error al verificar cambios en información del negocio:', error);\n    return false;\n  }\n}\n\n/**\n * Inicia la verificación periódica de cambios en la información del negocio\n * @param {boolean} disableSync - Si es true, la sincronización se desactiva (útil para vistas compartidas)\n */\nexport function startBusinessInfoSyncInterval(disableSync = false) {\n  // Si se solicita deshabilitar la sincronización (por ejemplo, en vistas compartidas), salir\n  if (disableSync) {\n    console.log('Sincronización de información del negocio desactivada (modo vista compartida)');\n    return;\n  }\n  if (syncIntervalId) {\n    clearInterval(syncIntervalId);\n  }\n\n  // Inicializar con una primera sincronización\n  if (!isInitialized) {\n    fetchBusinessInfoFromBackend().catch(error => console.error('Error en sincronización inicial:', error));\n    isInitialized = true;\n  }\n  syncIntervalId = setInterval(() => {\n    checkForBusinessInfoChanges().catch(error => console.error('Error en verificación periódica:', error));\n  }, SYNC_INTERVAL);\n  console.log('Verificación periódica de información del negocio iniciada');\n}\n\n/**\n * Detiene la verificación periódica\n */\nexport function stopBusinessInfoSyncInterval() {\n  if (syncIntervalId) {\n    clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    console.log('Verificación periódica de información del negocio detenida');\n  }\n}\n\n/**\n * Ejecuta la migración para añadir la columna informacion_pago a la tabla restaurantes\n * @returns {Promise<Object>} - Resultado de la migración\n */\nexport async function runAddInformacionPagoMigration() {\n  try {\n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    const response = await apiService.get('/restaurantes/migrate/add-informacion-pago');\n    if (response && response.success) {\n      console.log('Migración ejecutada con éxito:', response.message);\n      return {\n        success: true,\n        message: response.message || 'Migración ejecutada con éxito'\n      };\n    } else {\n      console.warn('Error al ejecutar migración:', response);\n      return {\n        success: false,\n        message: response.message || 'Error al ejecutar migración'\n      };\n    }\n  } catch (error) {\n    console.error('Error al ejecutar migración:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al ejecutar migración'\n    };\n  }\n}\n\n/**\n * Limpia la caché y fuerza una nueva carga desde el backend\n */\nexport function invalidateBusinessInfoCache() {\n  businessInfoCache = null;\n  lastFetchTimestamp = 0;\n}\nexport default {\n  syncBusinessInfoWithBackend,\n  fetchBusinessInfoFromBackend,\n  updateBusinessInfo,\n  checkForBusinessInfoChanges,\n  startBusinessInfoSyncInterval,\n  stopBusinessInfoSyncInterval,\n  runAddInformacionPagoMigration,\n  invalidateBusinessInfoCache\n};","map":{"version":3,"names":["apiService","getBusinessInfo","saveBusinessInfo","eventBus","SYNC_INTERVAL","CACHE_DURATION","syncIntervalId","lastSyncTimestamp","lastFetchTimestamp","businessInfoCache","isInitialized","syncBusinessInfoWithBackend","businessInfo","Object","keys","length","console","log","success","message","token","localStorage","getItem","setToken","userResponse","get","user","restaurante_id","warn","restauranteId","restauranteData","nombre","name","descripcion","description","direccion","address","telefono","contact","logo","informacion_pago","JSON","stringify","paymentInfo","response","put","Date","now","emit","timestamp","error","fetchBusinessInfoFromBackend","forceUpdate","Error","restaurante","parse","e","localError","updateBusinessInfo","syncResult","checkForBusinessInfoChanges","localInfo","backendInfo","localString","backendString","hasChanges","startBusinessInfoSyncInterval","disableSync","clearInterval","catch","setInterval","stopBusinessInfoSyncInterval","runAddInformacionPagoMigration","invalidateBusinessInfoCache"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/businessInfoService.js"],"sourcesContent":["// src/services/businessInfoService.js\n\nimport apiService from './apiService';\nimport { getBusinessInfo, saveBusinessInfo } from './storageService';\nimport eventBus from '../utils/eventBus';\n\n// Constantes para la sincronización\nconst SYNC_INTERVAL = 30000; // 30 segundos\nconst CACHE_DURATION = 300000; // 5 minutos\nlet syncIntervalId = null;\nlet lastSyncTimestamp = 0;\nlet lastFetchTimestamp = 0;\nlet businessInfoCache = null;\nlet isInitialized = false;\n\n/**\n * Sincroniza la información del negocio guardada en IndexedDB con el backend\n * @returns {Promise<Object>} - Resultado de la sincronización\n */\nexport async function syncBusinessInfoWithBackend() {\n  try {\n    // Obtener la información del negocio desde IndexedDB\n    const businessInfo = await getBusinessInfo();\n    \n    if (!businessInfo || Object.keys(businessInfo).length === 0) {\n      console.log('No hay información del negocio para sincronizar');\n      return {\n        success: false,\n        message: 'No hay información del negocio para sincronizar'\n      };\n    }\n    \n    console.log('Sincronizando información del negocio con el backend:', businessInfo);\n    \n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      return {\n        success: false,\n        message: 'No se pudo obtener el restaurante del usuario actual'\n      };\n    }\n    \n    const restauranteId = userResponse.user.restaurante_id;\n    \n    // Preparar los datos para actualizar el restaurante\n    const restauranteData = {\n      nombre: businessInfo.name,\n      descripcion: businessInfo.description,\n      direccion: businessInfo.address,\n      telefono: businessInfo.contact,\n      logo: businessInfo.logo,\n      // Guardar la información de pago como un campo JSON\n      informacion_pago: JSON.stringify(businessInfo.paymentInfo || {})\n    };\n    \n    // Actualizar el restaurante en el backend\n    const response = await apiService.put(`/restaurantes/${restauranteId}`, restauranteData);\n    \n    if (response && response.success) {\n      console.log('Información del negocio sincronizada con éxito');\n      lastSyncTimestamp = Date.now();\n      \n      // Notificar a todos los componentes que la información ha sido sincronizada\n      eventBus.emit('business-info-updated', businessInfo);\n      \n      return {\n        success: true,\n        message: 'Información del negocio sincronizada con éxito',\n        timestamp: lastSyncTimestamp\n      };\n    } else {\n      console.warn('Error al sincronizar información del negocio:', response);\n      return {\n        success: false,\n        message: response.message || 'Error al sincronizar información del negocio'\n      };\n    }\n  } catch (error) {\n    console.error('Error al sincronizar información del negocio:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al sincronizar información del negocio'\n    };\n  }\n}\n\n/**\n * Obtiene la información del negocio desde el backend y la guarda en IndexedDB\n * @param {boolean} forceUpdate - Forzar la actualización aunque esté en caché\n * @returns {Promise<Object>} - Información del negocio\n */\nexport async function fetchBusinessInfoFromBackend(forceUpdate = false) {\n  try {\n    // Si tenemos información en caché y no ha pasado el tiempo de caché, usarla\n    const now = Date.now();\n    if (businessInfoCache && !forceUpdate && (now - lastFetchTimestamp) < CACHE_DURATION) {\n      console.log('Usando información de negocio en caché');\n      return businessInfoCache;\n    }\n    \n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    // Obtener el ID del restaurante del usuario actual\n    const userResponse = await apiService.get('/auth/me');\n    if (!userResponse || !userResponse.success || !userResponse.user || !userResponse.user.restaurante_id) {\n      console.warn('No se pudo obtener el restaurante del usuario actual');\n      throw new Error('No se pudo obtener el restaurante del usuario actual');\n    }\n    \n    const restauranteId = userResponse.user.restaurante_id;\n    \n    // Obtener el restaurante del backend\n    const response = await apiService.get(`/restaurantes/${restauranteId}`);\n    \n    if (response && response.success && response.restaurante) {\n      const restaurante = response.restaurante;\n      \n      // Convertir la información a formato de negocio\n      let paymentInfo = {};\n      try {\n        if (restaurante.informacion_pago) {\n          paymentInfo = JSON.parse(restaurante.informacion_pago);\n        }\n      } catch (e) {\n        console.warn('Error al parsear información de pago:', e);\n      }\n      \n      const businessInfo = {\n        name: restaurante.nombre,\n        description: restaurante.descripcion,\n        address: restaurante.direccion,\n        contact: restaurante.telefono,\n        logo: restaurante.logo,\n        paymentInfo\n      };\n      \n      // Guardar en IndexedDB\n      await saveBusinessInfo(businessInfo);\n      \n      // Actualizar caché y timestamp\n      businessInfoCache = businessInfo;\n      lastFetchTimestamp = now;\n      \n      // Notificar a todos los componentes que la información ha sido actualizada\n      eventBus.emit('business-info-updated', businessInfo);\n      \n      console.log('Información del negocio obtenida con éxito:', businessInfo);\n      return businessInfo;\n    } else {\n      console.warn('Error al obtener información del negocio:', response);\n      throw new Error(response?.message || 'Error al obtener información del negocio');\n    }\n  } catch (error) {\n    console.error('Error al obtener información del negocio desde el backend:', error);\n    \n    // Si hay un error, intentar obtener la información desde IndexedDB\n    try {\n      const businessInfo = await getBusinessInfo();\n      if (businessInfo) {\n        return businessInfo;\n      }\n    } catch (localError) {\n      console.error('Error al obtener información local:', localError);\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * Actualiza la información del negocio en IndexedDB y la sincroniza con el backend\n * @param {Object} businessInfo - Nueva información del negocio\n * @returns {Promise<Object>} - Resultado de la actualización\n */\nexport async function updateBusinessInfo(businessInfo) {\n  try {\n    // Guardar en IndexedDB\n    await saveBusinessInfo(businessInfo);\n    \n    // Actualizar caché y timestamp\n    businessInfoCache = businessInfo;\n    lastFetchTimestamp = Date.now();\n    \n    // Notificar a todos los componentes que la información ha sido actualizada\n    eventBus.emit('business-info-updated', businessInfo);\n    \n    // Sincronizar con el backend\n    const syncResult = await syncBusinessInfoWithBackend();\n    \n    return {\n      success: true,\n      message: 'Información del negocio actualizada con éxito',\n      syncResult\n    };\n  } catch (error) {\n    console.error('Error al actualizar información del negocio:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar información del negocio'\n    };\n  }\n}\n\n/**\n * Verifica si hay cambios en la información del negocio\n * @returns {Promise<boolean>} - True si hay cambios, false si no\n */\nexport async function checkForBusinessInfoChanges() {\n  try {\n    // Obtener información actual desde IndexedDB\n    const localInfo = await getBusinessInfo();\n    \n    // Obtener información desde el backend\n    const backendInfo = await fetchBusinessInfoFromBackend(true);\n    \n    // Comparar ambas informaciones\n    const localString = JSON.stringify(localInfo);\n    const backendString = JSON.stringify(backendInfo);\n    \n    const hasChanges = localString !== backendString;\n    \n    if (hasChanges) {\n      console.log('Se detectaron cambios en la información del negocio');\n      \n      // Actualizar la información local con la del backend\n      await saveBusinessInfo(backendInfo);\n      \n      // Notificar a todos los componentes\n      eventBus.emit('business-info-updated', backendInfo);\n    }\n    \n    return hasChanges;\n  } catch (error) {\n    console.error('Error al verificar cambios en información del negocio:', error);\n    return false;\n  }\n}\n\n/**\n * Inicia la verificación periódica de cambios en la información del negocio\n * @param {boolean} disableSync - Si es true, la sincronización se desactiva (útil para vistas compartidas)\n */\nexport function startBusinessInfoSyncInterval(disableSync = false) {\n  // Si se solicita deshabilitar la sincronización (por ejemplo, en vistas compartidas), salir\n  if (disableSync) {\n    console.log('Sincronización de información del negocio desactivada (modo vista compartida)');\n    return;\n  }\n\n  if (syncIntervalId) {\n    clearInterval(syncIntervalId);\n  }\n  \n  // Inicializar con una primera sincronización\n  if (!isInitialized) {\n    fetchBusinessInfoFromBackend()\n      .catch(error => console.error('Error en sincronización inicial:', error));\n    isInitialized = true;\n  }\n  \n  syncIntervalId = setInterval(() => {\n    checkForBusinessInfoChanges()\n      .catch(error => console.error('Error en verificación periódica:', error));\n  }, SYNC_INTERVAL);\n  \n  console.log('Verificación periódica de información del negocio iniciada');\n}\n\n/**\n * Detiene la verificación periódica\n */\nexport function stopBusinessInfoSyncInterval() {\n  if (syncIntervalId) {\n    clearInterval(syncIntervalId);\n    syncIntervalId = null;\n    console.log('Verificación periódica de información del negocio detenida');\n  }\n}\n\n/**\n * Ejecuta la migración para añadir la columna informacion_pago a la tabla restaurantes\n * @returns {Promise<Object>} - Resultado de la migración\n */\nexport async function runAddInformacionPagoMigration() {\n  try {\n    // Asegurarse de que el token esté configurado en apiService\n    const token = localStorage.getItem('token');\n    if (token) {\n      apiService.setToken(token);\n    }\n    \n    const response = await apiService.get('/restaurantes/migrate/add-informacion-pago');\n    \n    if (response && response.success) {\n      console.log('Migración ejecutada con éxito:', response.message);\n      return {\n        success: true,\n        message: response.message || 'Migración ejecutada con éxito'\n      };\n    } else {\n      console.warn('Error al ejecutar migración:', response);\n      return {\n        success: false,\n        message: response.message || 'Error al ejecutar migración'\n      };\n    }\n  } catch (error) {\n    console.error('Error al ejecutar migración:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al ejecutar migración'\n    };\n  }\n}\n\n/**\n * Limpia la caché y fuerza una nueva carga desde el backend\n */\nexport function invalidateBusinessInfoCache() {\n  businessInfoCache = null;\n  lastFetchTimestamp = 0;\n}\n\nexport default {\n  syncBusinessInfoWithBackend,\n  fetchBusinessInfoFromBackend,\n  updateBusinessInfo,\n  checkForBusinessInfoChanges,\n  startBusinessInfoSyncInterval,\n  stopBusinessInfoSyncInterval,\n  runAddInformacionPagoMigration,\n  invalidateBusinessInfoCache\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}