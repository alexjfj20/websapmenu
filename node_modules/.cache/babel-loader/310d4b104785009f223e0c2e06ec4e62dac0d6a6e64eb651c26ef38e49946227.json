{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\n// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versi√≥n para forzar una actualizaci√≥n del esquema\nconst API_BASE_URL = process.env.VUE_APP_API_URL || 'http://localhost:3000'; // URL base para la API\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versi√≥n: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almac√©n para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almac√©n de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id'\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almac√©n de platos creado');\n      } else {\n        console.log('El almac√©n de platos ya existe');\n\n        // Si necesitamos modificar un almac√©n existente, primero hay que eliminarlo\n        // y luego volver a crearlo con la nueva configuraci√≥n\n        try {\n          db.deleteObjectStore(PLATOS_STORE);\n          console.log('Almac√©n de platos eliminado para recreaci√≥n');\n          const platosStore = db.createObjectStore(PLATOS_STORE, {\n            keyPath: 'id'\n          });\n          platosStore.createIndex('name', 'name', {\n            unique: false\n          });\n          platosStore.createIndex('syncStatus', 'syncStatus', {\n            unique: false\n          });\n          console.log('Almac√©n de platos recreado con nueva configuraci√≥n');\n        } catch (error) {\n          console.error('Error al intentar modificar el almac√©n de platos:', error);\n        }\n      }\n\n      // Crear almac√©n para la cola de sincronizaci√≥n si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almac√©n de cola de sincronizaci√≥n...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        syncQueueStore.createIndex('type', 'type', {\n          unique: false\n        });\n        console.log('Almac√©n de cola de sincronizaci√≥n creado');\n      } else {\n        console.log('El almac√©n de cola de sincronizaci√≥n ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexi√≥n a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexi√≥n a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n\n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        resolve(activePlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronizaci√≥n\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronizaci√≥n...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      request.onsuccess = event => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\n        resolve(pendingPlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronizaci√≥n de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronizaci√≥n del plato ID ${id} a \"${status}\"...`);\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inv√°lido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontr√≥ plato con ID ${id}.`);\n            reject(new Error(`No se encontr√≥ plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronizaci√≥n\n          plato.syncStatus = status;\n\n          // Si es pending_deletion, marcar como no disponible tambi√©n\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronizaci√≥n del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacci√≥n:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronizaci√≥n\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronizaci√≥n:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronizaci√≥n');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronizaci√≥n:', event);\n        reject('Error al agregar a la cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronizaci√≥n\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronizaci√≥n...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronizaci√≥n`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronizaci√≥n:', event);\n        reject('Error al obtener cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronizaci√≥n\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronizaci√≥n...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronizaci√≥n`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronizaci√≥n:', event);\n        reject('Error al eliminar de la cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async id => {\n  try {\n    console.log(`Iniciando proceso de eliminaci√≥n para plato ID: ${id}`);\n\n    // Verificar si estamos en l√≠nea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n\n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/sync/platos/' + id;\n        console.log(`URL completa: ${serverUrl}`);\n        const response = await fetch(serverUrl, {\n          method: 'DELETE',\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n\n        // Registrar detalles completos de la respuesta para depuraci√≥n\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          if (response.ok) {\n            console.log(`‚úÖ Plato ID ${id} eliminado con √©xito del servidor:`, data);\n\n            // Si se elimin√≥ correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`‚ùå Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminaci√≥n y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`‚ùå Error de red al sincronizar eliminaci√≥n del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminaci√≥n y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexi√≥n a internet, marcando plato ID ${id} para eliminaci√≥n futura`);\n      // Si estamos offline, marcamos para eliminaci√≥n y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`‚ùå Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Funci√≥n auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con √©xito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacci√≥n:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Funci√≥n para marcar un plato para eliminaci√≥n\nconst markPlatoForDeletion = async id => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    return new Promise((resolve, reject) => {\n      request.onerror = event => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n\n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          getRequest.onerror = event => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          getRequest.onsuccess = event => {\n            const plato = event.target.result;\n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminaci√≥n`);\n              resolve(false);\n              return;\n            }\n\n            // Marcar para eliminaci√≥n\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n\n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            updateRequest.onerror = event => {\n              console.error(`Error al marcar plato ID ${id} para eliminaci√≥n:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminaci√≥n`));\n            };\n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminaci√≥n`);\n\n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronizaci√≥n)\n              // Esto se hace a√±adiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              finalUpdateRequest.onerror = event => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacci√≥n:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminaci√≥n:`, error);\n    throw error;\n  }\n};\n\n// A√±adir esto al principio del archivo para depuraci√≥n\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versi√≥n:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo peri√≥dicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificaci√≥n exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificaci√≥n fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacci√≥n de verificaci√≥n completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('üçΩÔ∏è INICIO - Creando nuevo plato en IndexedDB:', plato);\n  try {\n    // Validaci√≥n de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('‚ùå ERROR: El plato debe ser un objeto v√°lido', plato);\n      throw new Error('El plato debe ser un objeto v√°lido');\n    }\n    if (!plato.name || plato.name.trim() === '') {\n      console.error('‚ùå ERROR: El plato debe tener un nombre v√°lido', plato);\n      throw new Error('El plato debe tener un nombre v√°lido');\n    }\n    console.log('‚úÖ Validaci√≥n inicial del plato exitosa');\n\n    // Abrimos la BD con registro detallado\n    console.log('üîÑ Abriendo base de datos...');\n    const db = await openDB();\n    console.log('‚úÖ Base de datos abierta correctamente');\n    return new Promise((resolve, reject) => {\n      console.log('üîÑ Iniciando transacci√≥n para guardar plato...');\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('‚úÖ Transacci√≥n creada correctamente');\n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('‚úÖ Almac√©n obtenido correctamente');\n\n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n\n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`üÜî Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        console.log('üì¶ Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        request.onsuccess = async event => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`‚úÖ √âXITO: Plato guardado con ID: ${id}`);\n\n          // Crear objeto completo con el ID\n          const createdPlato = {\n            ...platoToCreate\n          };\n\n          // Agregar a la cola de sincronizaci√≥n\n          try {\n            console.log('üîÑ Agregando plato a cola de sincronizaci√≥n...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('‚úÖ Plato agregado a la cola de sincronizaci√≥n correctamente');\n          } catch (syncError) {\n            console.warn('‚ö†Ô∏è Error al agregar a cola de sincronizaci√≥n:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n\n          // Verificaci√≥n inmediata para depuraci√≥n\n          console.log('üîç Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`üìä Total de platos en BD: ${platos.length}`);\n            console.log('üìã Lista de platos:', platos);\n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('‚úÖ VERIFICACI√ìN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('‚ùå VERIFICACI√ìN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('‚ùå Error al listar platos para verificaci√≥n:', listError);\n          }\n\n          // Verificaci√≥n posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`üîç Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('‚úÖ VERIFICACI√ìN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('‚ùå VERIFICACI√ìN POSTERIOR FALLIDA: Plato no encontrado en verificaci√≥n');\n              }\n            } catch (verifyError) {\n              console.error('‚ùå Error en verificaci√≥n posterior:', verifyError);\n            }\n          }, 1000);\n          console.log('üèÅ Finalizando creaci√≥n del plato con √©xito');\n          resolve(createdPlato);\n        };\n        request.onerror = event => {\n          console.error('‚ùå ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        transaction.onerror = event => {\n          console.error('‚ùå ERROR en transacci√≥n:', event.target.error);\n          reject(new Error(`Error en transacci√≥n: ${event.target.error.message}`));\n        };\n        transaction.oncomplete = () => {\n          console.log('‚úÖ Transacci√≥n completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('‚ùå ERROR al crear transacci√≥n:', transactionError);\n        reject(new Error(`Error al crear transacci√≥n: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('‚ùå ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Funci√≥n de depuraci√≥n para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('üîç INICIANDO DEPURACI√ìN DE INDEXEDDB...');\n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('üìä Bases de datos disponibles:', databases);\n\n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('üì¶ Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n\n    // Verificar contenido del almac√©n de platos\n    const platos = await getAllPlatos();\n    console.log(`üìã Platos almacenados (${platos.length}):`, platos);\n\n    // Verificar cola de sincronizaci√≥n\n    const syncQueue = await getSyncQueue();\n    console.log(`üîÑ Cola de sincronizaci√≥n (${syncQueue.length}):`, syncQueue);\n    console.log('‚úÖ DEPURACI√ìN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('‚ùå ERROR EN DEPURACI√ìN:', error);\n    throw error;\n  }\n}\n\n/**\n * Funci√≥n auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = {\n    ...platoData\n  };\n\n  // Asegurar que los campos necesarios tengan valores v√°lidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' ? parseFloat(normalizedData.price) || 0 : normalizedData.price || 0;\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n\n  // Asegurar que los campos de fecha est√©n presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n\n  // A√±adir estado de sincronizaci√≥n si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n\n  // Limitar el tama√±o de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && normalizedData.image.length > 200000) {\n    // Si es mayor a ~200KB\n    console.warn('‚ö†Ô∏è Imagen demasiado grande, se reducir√° para evitar problemas de sincronizaci√≥n');\n\n    // Crear miniatura para sincronizaci√≥n\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n\n    // Marcar que la imagen original est√° almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  return normalizedData;\n}\n\n/**\n * Funci√≥n para comprimir im√°genes y reducir su tama√±o para sincronizaci√≥n\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como est√°\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n\n    // Extraer informaci√≥n de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('‚ö†Ô∏è Formato de imagen no v√°lido para compresi√≥n');\n      return imageDataUrl;\n    }\n\n    // Crear una versi√≥n reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una soluci√≥n temporal; una implementaci√≥n adecuada usar√≠a canvas\n    // para redimensionar la imagen manteniendo la proporci√≥n\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente peque√±a\n    }\n\n    // Crear una versi√≥n recortada para sincronizaci√≥n\n    // Nota: En producci√≥n, ser√≠a mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n  } catch (error) {\n    console.error('‚ùå Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronizaci√≥n con el servidor\n * @param {Object} plato - Plato a preparar para sincronizaci√≥n\n * @returns {Object} Plato optimizado para env√≠o al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la funci√≥n no existe, implementarla\n  if (!plato) {\n    console.error('‚ùå Error: Se intent√≥ preparar un plato nulo para sincronizaci√≥n');\n    return {};\n  }\n  console.log('üîÑ Preparando plato para sincronizaci√≥n:', plato.id);\n\n  // Crear una copia para no modificar el objeto original\n  const syncPlato = {\n    ...plato\n  };\n\n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versi√≥n comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n\n  // PASO 2: Ser a√∫n m√°s agresivos con el tama√±o de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`üìä Tama√±o original de imagen: ${imageSize} bytes`);\n\n    // Establecer un l√≠mite mucho m√°s estricto (50KB m√°ximo)\n    const maxImageSize = 50000; // 50KB\n\n    if (imageSize > maxImageSize) {\n      console.warn('‚ö†Ô∏è Imagen demasiado grande, reduciendo dr√°sticamente...');\n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n\n            // Crear una versi√≥n muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            console.log(`üìä Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podr√≠amos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que deber√≠a ser peque√±a\n        }\n      } catch (imageError) {\n        console.error('‚ùå Error al procesar imagen para sincronizaci√≥n:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronizaci√≥n\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronizaci√≥n';\n      }\n    }\n  }\n\n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n\n  // PASO 4: Asegurar que todos los campos num√©ricos sean realmente n√∫meros\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n\n  // PASO 5: Verificar el tama√±o final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`üìä Tama√±o final del plato serializado: ${serializedSize} bytes`);\n\n  // Si a√∫n es mayor a 100KB, tomamos medidas dr√°sticas\n  if (serializedSize > 100000) {\n    console.warn('‚ö†Ô∏è ADVERTENCIA: Plato demasiado grande incluso despu√©s de optimizaciones');\n\n    // Crear objeto m√≠nimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    console.log('üîÑ Usando versi√≥n m√≠nima del plato para sincronizaci√≥n');\n    return minimalPlato;\n  }\n  console.log('‚úÖ Plato preparado para sincronizaci√≥n');\n  return syncPlato;\n}\n\n/**\n * Funci√≥n auxiliar para guardar platos desde cualquier formulario de la aplicaci√≥n\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('üîÑ Iniciando guardado de plato con guardarPlato():', platoData);\n  try {\n    // Validaci√≥n de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto v√°lido');\n    }\n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre v√°lido');\n    }\n\n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('‚úÖ Datos normalizados:', platoParaGuardar);\n\n    // Usar la funci√≥n createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    console.log('‚úÖ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('‚ùå Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validaci√≥n adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronizaci√≥n al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronizaci√≥n\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronizaci√≥n');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronizaci√≥n:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificaci√≥n inmediata para depuraci√≥n\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificaci√≥n exitosa del guardado del plato');\n            } else {\n              console.warn('‚ö†Ô∏è Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacci√≥n\n      transaction.onerror = event => {\n        console.error('Error en la transacci√≥n de guardado:', event.target.error);\n        reject(new Error('Error en la transacci√≥n: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacci√≥n de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async id => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontr√≥ plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposici√≥n de la funci√≥n de depuraci√≥n\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la funci√≥n guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\nexport { openDB, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato, debugIndexedDB, normalizePlatoData, guardarPlato,\n// Exportar la nueva funci√≥n\npreparePlatoForSync, compressImageForSync, getPlato };\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,\n  // Exportar la nueva funci√≥n\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","API_BASE_URL","process","env","VUE_APP_API_URL","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","onupgradeneeded","objectStoreNames","contains","platosStore","createObjectStore","keyPath","createIndex","unique","deleteObjectStore","syncQueueStore","autoIncrement","openDB","getAllPlatos","transaction","store","objectStore","getAll","allPlatos","length","activePlatos","filter","plato","deleted","getPendingPlatos","index","pendingPlatos","updatePlatoSyncStatus","id","status","validStatuses","includes","Error","join","getRequest","get","syncStatus","is_available","updateRequest","put","oncomplete","close","addToSyncQueue","item","add","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","online","navigator","onLine","serverUrl","response","fetch","method","headers","responseText","text","data","JSON","parse","ok","deleteFromIndexedDB","markPlatoForDeletion","parseError","syncError","deleteRequest","warn","updated_at","Date","toISOString","finalUpdateRequest","logDB","name","version","Array","from","setInterval","verifyPlatoStorage","message","createPlato","trim","platoToCreate","createdAt","updatedAt","localTimestamp","getTime","now","Math","floor","random","createdPlato","type","entityType","entityId","timestamp","platos","found","find","p","listError","setTimeout","verified","verifyError","transactionError","debugIndexedDB","databases","window","syncQueue","stores","normalizePlatoData","platoData","normalizedData","price","parseFloat","availableQuantity","parseInt","includesDrink","image","image_thumbnail","compressImageForSync","has_local_image","imageDataUrl","startsWith","match","maxLength","actualData","substring","preparePlatoForSync","syncPlato","needsSimplification","_id","imageSize","maxImageSize","imageType","base64Data","reducedData","imageError","image_error","description","Number","Boolean","serializedSize","stringify","minimalPlato","oversized","guardarPlato","platoParaGuardar","platoGuardado","savePlato","platoToSave","savedId","savedPlato","verificationResult","getPlato","debugDB"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/indexedDBService.js"],"sourcesContent":["// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 4; // Incrementar la versi√≥n para forzar una actualizaci√≥n del esquema\nconst API_BASE_URL = process.env.VUE_APP_API_URL || 'http://localhost:3000'; // URL base para la API\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versi√≥n: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n      \n      // Crear almac√©n para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almac√©n de platos...');\n        // Quitar autoIncrement para permitir IDs personalizados\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n        platosStore.createIndex('name', 'name', { unique: false });\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n        console.log('Almac√©n de platos creado');\n      } else {\n        console.log('El almac√©n de platos ya existe');\n        \n        // Si necesitamos modificar un almac√©n existente, primero hay que eliminarlo\n        // y luego volver a crearlo con la nueva configuraci√≥n\n        try {\n          db.deleteObjectStore(PLATOS_STORE);\n          console.log('Almac√©n de platos eliminado para recreaci√≥n');\n          \n          const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id' });\n          platosStore.createIndex('name', 'name', { unique: false });\n          platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\n          console.log('Almac√©n de platos recreado con nueva configuraci√≥n');\n        } catch (error) {\n          console.error('Error al intentar modificar el almac√©n de platos:', error);\n        }\n      }\n      \n      // Crear almac√©n para la cola de sincronizaci√≥n si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almac√©n de cola de sincronizaci√≥n...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\n        syncQueueStore.createIndex('type', 'type', { unique: false });\n        console.log('Almac√©n de cola de sincronizaci√≥n creado');\n      } else {\n        console.log('El almac√©n de cola de sincronizaci√≥n ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexi√≥n a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexi√≥n a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const allPlatos = event.target.result;\n        console.log(`Obtenidos ${allPlatos.length} platos totales de IndexedDB`);\n        \n        // Filtrar platos eliminados\n        const activePlatos = allPlatos.filter(plato => !plato.deleted);\n        console.log(`Filtrando platos eliminados: ${allPlatos.length - activePlatos.length} platos ocultos, ${activePlatos.length} platos activos`);\n        \n        resolve(activePlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronizaci√≥n\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronizaci√≥n...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      \n      request.onsuccess = (event) => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\n        resolve(pendingPlatos);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronizaci√≥n de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronizaci√≥n del plato ID ${id} a \"${status}\"...`);\n  \n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inv√°lido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  \n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        \n        getRequest.onerror = (event) => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        \n        getRequest.onsuccess = (event) => {\n          const plato = event.target.result;\n          \n          if (!plato) {\n            console.error(`No se encontr√≥ plato con ID ${id}.`);\n            reject(new Error(`No se encontr√≥ plato con ID ${id}.`));\n            return;\n          }\n          \n          // Actualizar el estado de sincronizaci√≥n\n          plato.syncStatus = status;\n          \n          // Si es pending_deletion, marcar como no disponible tambi√©n\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n          \n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          \n          updateRequest.onerror = (event) => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          \n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronizaci√≥n del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacci√≥n:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronizaci√≥n\nconst addToSyncQueue = async (item) => {\n  try {\n    console.log('Agregando elemento a la cola de sincronizaci√≥n:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.add(item);\n      \n      request.onsuccess = (event) => {\n        console.log('Elemento agregado a la cola de sincronizaci√≥n');\n        resolve(event.target.result);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al agregar a la cola de sincronizaci√≥n:', event);\n        reject('Error al agregar a la cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronizaci√≥n\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronizaci√≥n...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronizaci√≥n`);\n        resolve(queue);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al obtener cola de sincronizaci√≥n:', event);\n        reject('Error al obtener cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronizaci√≥n\nconst removeFromSyncQueue = async (id) => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronizaci√≥n...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      \n      const request = store.delete(id);\n      \n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronizaci√≥n`);\n        resolve(true);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al eliminar de la cola de sincronizaci√≥n:', event);\n        reject('Error al eliminar de la cola de sincronizaci√≥n');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB y sincronizar con el servidor\nconst deletePlato = async (id) => {\n  try {\n    console.log(`Iniciando proceso de eliminaci√≥n para plato ID: ${id}`);\n    \n    // Verificar si estamos en l√≠nea\n    const online = typeof navigator !== 'undefined' && navigator.onLine;\n    \n    if (online) {\n      try {\n        console.log(`Enviando solicitud al servidor para eliminar plato ID: ${id}`);\n        \n        // Usamos una URL absoluta para asegurarnos de que la solicitud llegue al servidor correcto\n        const serverUrl = 'http://localhost:3000/sync/platos/' + id;\n        console.log(`URL completa: ${serverUrl}`);\n        \n        const response = await fetch(serverUrl, {\n          method: 'DELETE',\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n        \n        // Registrar detalles completos de la respuesta para depuraci√≥n\n        console.log(`Respuesta del servidor: Status ${response.status}`);\n        let responseText = '';\n        try {\n          responseText = await response.text();\n          console.log(`Respuesta completa: ${responseText}`);\n          const data = JSON.parse(responseText);\n          \n          if (response.ok) {\n            console.log(`‚úÖ Plato ID ${id} eliminado con √©xito del servidor:`, data);\n            \n            // Si se elimin√≥ correctamente del servidor, ahora lo eliminamos de IndexedDB\n            await deleteFromIndexedDB(id);\n            return true;\n          } else {\n            console.error(`‚ùå Error al eliminar plato ID ${id} del servidor:`, data);\n            // Si hay error en el servidor, marcamos para eliminaci√≥n y eliminamos localmente\n            await markPlatoForDeletion(id);\n            return true;\n          }\n        } catch (parseError) {\n          console.error(`Error al procesar respuesta: ${responseText}`, parseError);\n          await markPlatoForDeletion(id);\n          return true;\n        }\n      } catch (syncError) {\n        console.error(`‚ùå Error de red al sincronizar eliminaci√≥n del plato ID ${id}:`, syncError);\n        // Si hay error de red, marcamos para eliminaci√≥n y eliminamos localmente\n        await markPlatoForDeletion(id);\n        return true;\n      }\n    } else {\n      console.log(`Sin conexi√≥n a internet, marcando plato ID ${id} para eliminaci√≥n futura`);\n      // Si estamos offline, marcamos para eliminaci√≥n y eliminamos localmente\n      await markPlatoForDeletion(id);\n      return true;\n    }\n  } catch (error) {\n    console.error(`‚ùå Error general al eliminar plato ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Funci√≥n auxiliar para eliminar un plato solo de IndexedDB\nconst deleteFromIndexedDB = async (id) => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        \n        const deleteRequest = platosStore.delete(id);\n        \n        deleteRequest.onerror = (event) => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        \n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con √©xito de IndexedDB`);\n          resolve(true);\n        };\n        \n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacci√≥n:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Funci√≥n para marcar un plato para eliminaci√≥n\nconst markPlatoForDeletion = async (id) => {\n  try {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    return new Promise((resolve, reject) => {\n      request.onerror = (event) => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject(new Error('No se pudo abrir la base de datos'));\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        \n        try {\n          const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n          const platosStore = transaction.objectStore(PLATOS_STORE);\n          \n          // Primero obtenemos el plato\n          const getRequest = platosStore.get(id);\n          \n          getRequest.onerror = (event) => {\n            console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo obtener el plato ID ${id}`));\n          };\n          \n          getRequest.onsuccess = (event) => {\n            const plato = event.target.result;\n            \n            if (!plato) {\n              console.warn(`Plato ID ${id} no encontrado, no se puede marcar para eliminaci√≥n`);\n              resolve(false);\n              return;\n            }\n            \n            // Marcar para eliminaci√≥n\n            plato.syncStatus = 'pending_deletion';\n            plato.updated_at = new Date().toISOString();\n            \n            // Guardar los cambios\n            const updateRequest = platosStore.put(plato);\n            \n            updateRequest.onerror = (event) => {\n              console.error(`Error al marcar plato ID ${id} para eliminaci√≥n:`, event.target.error);\n              reject(new Error(`No se pudo marcar el plato ID ${id} para eliminaci√≥n`));\n            };\n            \n            updateRequest.onsuccess = () => {\n              console.log(`Plato ID ${id} marcado para eliminaci√≥n`);\n              \n              // Ahora lo eliminamos de la vista del usuario (pero se mantiene en la base de datos para sincronizaci√≥n)\n              // Esto se hace a√±adiendo un flag 'deleted' que usamos para filtrar en las consultas\n              plato.deleted = true;\n              const finalUpdateRequest = platosStore.put(plato);\n              \n              finalUpdateRequest.onsuccess = () => {\n                console.log(`Plato ID ${id} marcado como eliminado para el usuario`);\n                resolve(true);\n              };\n              \n              finalUpdateRequest.onerror = (event) => {\n                console.error(`Error al marcar plato ID ${id} como eliminado:`, event.target.error);\n                reject(new Error(`No se pudo marcar el plato ID ${id} como eliminado`));\n              };\n            };\n          };\n          \n          transaction.oncomplete = () => {\n            db.close();\n          };\n        } catch (error) {\n          console.error('Error en la transacci√≥n:', error);\n          reject(error);\n        }\n      };\n    });\n  } catch (error) {\n    console.error(`Error general al marcar plato ID ${id} para eliminaci√≥n:`, error);\n    throw error;\n  }\n};\n\n// A√±adir esto al principio del archivo para depuraci√≥n\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versi√≥n:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo peri√≥dicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async (id) => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificaci√≥n exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificaci√≥n fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacci√≥n de verificaci√≥n completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\n * Crea un nuevo plato en la base de datos\n * @param {Object} plato - Datos del plato a crear\n * @returns {Promise<Object>} - Plato creado con su ID asignado\n */\nasync function createPlato(plato) {\n  console.log('üçΩÔ∏è INICIO - Creando nuevo plato en IndexedDB:', plato);\n  \n  try {\n    // Validaci√≥n de datos\n    if (!plato || typeof plato !== 'object') {\n      console.error('‚ùå ERROR: El plato debe ser un objeto v√°lido', plato);\n      throw new Error('El plato debe ser un objeto v√°lido');\n    }\n    \n    if (!plato.name || plato.name.trim() === '') {\n      console.error('‚ùå ERROR: El plato debe tener un nombre v√°lido', plato);\n      throw new Error('El plato debe tener un nombre v√°lido');\n    }\n    \n    console.log('‚úÖ Validaci√≥n inicial del plato exitosa');\n    \n    // Abrimos la BD con registro detallado\n    console.log('üîÑ Abriendo base de datos...');\n    const db = await openDB();\n    console.log('‚úÖ Base de datos abierta correctamente');\n    \n    return new Promise((resolve, reject) => {\n      console.log('üîÑ Iniciando transacci√≥n para guardar plato...');\n      \n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('‚úÖ Transacci√≥n creada correctamente');\n        \n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('‚úÖ Almac√©n obtenido correctamente');\n        \n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n        \n        // Asegurarse de que el plato tenga un ID\n        if (!platoToCreate.id) {\n          platoToCreate.id = `plato_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n          console.log(`üÜî Generando ID para el plato: ${platoToCreate.id}`);\n        }\n        \n        console.log('üì¶ Intentando guardar plato con datos:', platoToCreate);\n        // Usar put en lugar de add para actualizar si el ID ya existe\n        const request = store.put(platoToCreate);\n        \n        request.onsuccess = async (event) => {\n          // El ID ahora viene del objeto, no del evento\n          const id = platoToCreate.id;\n          console.log(`‚úÖ √âXITO: Plato guardado con ID: ${id}`);\n          \n          // Crear objeto completo con el ID\n          const createdPlato = { ...platoToCreate };\n          \n          // Agregar a la cola de sincronizaci√≥n\n          try {\n            console.log('üîÑ Agregando plato a cola de sincronizaci√≥n...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('‚úÖ Plato agregado a la cola de sincronizaci√≥n correctamente');\n          } catch (syncError) {\n            console.warn('‚ö†Ô∏è Error al agregar a cola de sincronizaci√≥n:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n          \n          // Verificaci√≥n inmediata para depuraci√≥n\n          console.log('üîç Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`üìä Total de platos en BD: ${platos.length}`);\n            console.log('üìã Lista de platos:', platos);\n            \n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('‚úÖ VERIFICACI√ìN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('‚ùå VERIFICACI√ìN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('‚ùå Error al listar platos para verificaci√≥n:', listError);\n          }\n          \n          // Verificaci√≥n posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`üîç Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('‚úÖ VERIFICACI√ìN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('‚ùå VERIFICACI√ìN POSTERIOR FALLIDA: Plato no encontrado en verificaci√≥n');\n              }\n            } catch (verifyError) {\n              console.error('‚ùå Error en verificaci√≥n posterior:', verifyError);\n            }\n          }, 1000);\n          \n          console.log('üèÅ Finalizando creaci√≥n del plato con √©xito');\n          resolve(createdPlato);\n        };\n        \n        request.onerror = (event) => {\n          console.error('‚ùå ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        \n        transaction.onerror = (event) => {\n          console.error('‚ùå ERROR en transacci√≥n:', event.target.error);\n          reject(new Error(`Error en transacci√≥n: ${event.target.error.message}`));\n        };\n        \n        transaction.oncomplete = () => {\n          console.log('‚úÖ Transacci√≥n completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('‚ùå ERROR al crear transacci√≥n:', transactionError);\n        reject(new Error(`Error al crear transacci√≥n: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('‚ùå ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\n * Funci√≥n de depuraci√≥n para verificar el contenido de la base de datos\n * @returns {Promise<void>}\n */\nasync function debugIndexedDB() {\n  console.log('üîç INICIANDO DEPURACI√ìN DE INDEXEDDB...');\n  \n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('üìä Bases de datos disponibles:', databases);\n    \n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('üì¶ Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n    \n    // Verificar contenido del almac√©n de platos\n    const platos = await getAllPlatos();\n    console.log(`üìã Platos almacenados (${platos.length}):`, platos);\n    \n    // Verificar cola de sincronizaci√≥n\n    const syncQueue = await getSyncQueue();\n    console.log(`üîÑ Cola de sincronizaci√≥n (${syncQueue.length}):`, syncQueue);\n    \n    console.log('‚úÖ DEPURACI√ìN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('‚ùå ERROR EN DEPURACI√ìN:', error);\n    throw error;\n  }\n}\n\n/**\n * Funci√≥n auxiliar para asegurar que los datos del plato sean consistentes antes de guardar\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Object} Datos del plato normalizados\n */\nfunction normalizePlatoData(platoData) {\n  // Crear una copia para no modificar el original\n  const normalizedData = { ...platoData };\n  \n  // Asegurar que los campos necesarios tengan valores v√°lidos\n  normalizedData.name = normalizedData.name?.trim() || 'Plato sin nombre';\n  normalizedData.price = typeof normalizedData.price === 'string' \n    ? parseFloat(normalizedData.price) || 0 \n    : (normalizedData.price || 0);\n  normalizedData.is_available = normalizedData.is_available !== false;\n  normalizedData.availableQuantity = parseInt(normalizedData.availableQuantity) || 0;\n  normalizedData.includesDrink = normalizedData.includesDrink === true;\n  \n  // Asegurar que los campos de fecha est√©n presentes\n  if (!normalizedData.createdAt) normalizedData.createdAt = new Date().toISOString();\n  normalizedData.updatedAt = new Date().toISOString();\n  \n  // A√±adir estado de sincronizaci√≥n si no existe\n  if (!normalizedData.syncStatus) normalizedData.syncStatus = 'pending';\n  \n  // Limitar el tama√±o de la imagen si existe (para evitar error 431)\n  if (normalizedData.image && typeof normalizedData.image === 'string' && \n      normalizedData.image.length > 200000) { // Si es mayor a ~200KB\n    console.warn('‚ö†Ô∏è Imagen demasiado grande, se reducir√° para evitar problemas de sincronizaci√≥n');\n    \n    // Crear miniatura para sincronizaci√≥n\n    normalizedData.image_thumbnail = compressImageForSync(normalizedData.image);\n    \n    // Marcar que la imagen original est√° almacenada localmente\n    normalizedData.has_local_image = true;\n  }\n  \n  return normalizedData;\n}\n\n/**\n * Funci√≥n para comprimir im√°genes y reducir su tama√±o para sincronizaci√≥n\n * @param {string} imageDataUrl - Imagen en formato data URL (base64)\n * @returns {string} Imagen comprimida como data URL\n */\nfunction compressImageForSync(imageDataUrl) {\n  try {\n    // Si no es una data URL, devolver como est√°\n    if (!imageDataUrl || !imageDataUrl.startsWith('data:')) {\n      return imageDataUrl;\n    }\n    \n    // Extraer informaci√≥n de tipo y datos\n    const match = imageDataUrl.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n    if (!match) {\n      console.warn('‚ö†Ô∏è Formato de imagen no v√°lido para compresi√≥n');\n      return imageDataUrl;\n    }\n    \n    // Crear una versi√≥n reducida (ejemplo: recortar a los primeros 50KB)\n    // Esto es una soluci√≥n temporal; una implementaci√≥n adecuada usar√≠a canvas\n    // para redimensionar la imagen manteniendo la proporci√≥n\n    const maxLength = 50000; // ~50KB\n    const actualData = match[2];\n    \n    if (actualData.length <= maxLength) {\n      return imageDataUrl; // Ya es lo suficientemente peque√±a\n    }\n    \n    // Crear una versi√≥n recortada para sincronizaci√≥n\n    // Nota: En producci√≥n, ser√≠a mejor usar canvas para redimensionar correctamente\n    return `data:${match[1]};base64,${actualData.substring(0, maxLength)}`;\n    \n  } catch (error) {\n    console.error('‚ùå Error al comprimir imagen:', error);\n    return imageDataUrl; // Devolver la original en caso de error\n  }\n}\n\n/**\n * Prepara un plato para sincronizaci√≥n con el servidor\n * @param {Object} plato - Plato a preparar para sincronizaci√≥n\n * @returns {Object} Plato optimizado para env√≠o al servidor\n */\nfunction preparePlatoForSync(plato) {\n  // Si la funci√≥n no existe, implementarla\n  if (!plato) {\n    console.error('‚ùå Error: Se intent√≥ preparar un plato nulo para sincronizaci√≥n');\n    return {};\n  }\n  \n  console.log('üîÑ Preparando plato para sincronizaci√≥n:', plato.id);\n  \n  // Crear una copia para no modificar el objeto original\n  const syncPlato = { ...plato };\n  \n  // PASO 1: Eliminar propiedades que no necesita el servidor\n  delete syncPlato.syncStatus;\n  delete syncPlato.localTimestamp;\n  delete syncPlato.needsSimplification;\n  delete syncPlato.image_thumbnail; // Si existe, la eliminaremos y usaremos una versi√≥n comprimida\n  delete syncPlato._id; // Eliminar posibles _id de MongoDB si existen\n  delete syncPlato.has_local_image;\n  \n  // PASO 2: Ser a√∫n m√°s agresivos con el tama√±o de la imagen\n  if (syncPlato.image && typeof syncPlato.image === 'string') {\n    const imageSize = syncPlato.image.length;\n    console.log(`üìä Tama√±o original de imagen: ${imageSize} bytes`);\n    \n    // Establecer un l√≠mite mucho m√°s estricto (50KB m√°ximo)\n    const maxImageSize = 50000; // 50KB\n    \n    if (imageSize > maxImageSize) {\n      console.warn('‚ö†Ô∏è Imagen demasiado grande, reduciendo dr√°sticamente...');\n      \n      try {\n        // Si empieza con data:, es una data URL\n        if (syncPlato.image.startsWith('data:')) {\n          const match = syncPlato.image.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          if (match) {\n            const imageType = match[1];\n            const base64Data = match[2];\n            \n            // Crear una versi√≥n muy reducida\n            const reducedData = base64Data.substring(0, maxImageSize);\n            syncPlato.image = `data:${imageType};base64,${reducedData}`;\n            \n            console.log(`üìä Imagen reducida a: ${syncPlato.image.length} bytes`);\n          } else {\n            // Si no podemos extraer los datos, simplemente truncamos\n            syncPlato.image = syncPlato.image.substring(0, maxImageSize);\n          }\n        } else {\n          // Para URL normales, podr√≠amos mantenerlas o reemplazarlas por un placeholder\n          // Por ahora, conservamos la URL ya que deber√≠a ser peque√±a\n        }\n      } catch (imageError) {\n        console.error('‚ùå Error al procesar imagen para sincronizaci√≥n:', imageError);\n        // Si hay error, eliminamos la imagen para garantizar la sincronizaci√≥n\n        delete syncPlato.image;\n        syncPlato.image_error = 'Error al procesar imagen para sincronizaci√≥n';\n      }\n    }\n  }\n  \n  // PASO 3: Limitar todos los campos de texto\n  if (syncPlato.description && syncPlato.description.length > 500) {\n    syncPlato.description = syncPlato.description.substring(0, 500) + '...';\n  }\n  \n  if (syncPlato.name && syncPlato.name.length > 100) {\n    syncPlato.name = syncPlato.name.substring(0, 100);\n  }\n  \n  // PASO 4: Asegurar que todos los campos num√©ricos sean realmente n√∫meros\n  syncPlato.price = Number(syncPlato.price) || 0;\n  syncPlato.availableQuantity = Number(syncPlato.availableQuantity) || 0;\n  syncPlato.includesDrink = Boolean(syncPlato.includesDrink);\n  \n  // PASO 5: Verificar el tama√±o final del objeto serializado\n  const serializedSize = JSON.stringify(syncPlato).length;\n  console.log(`üìä Tama√±o final del plato serializado: ${serializedSize} bytes`);\n  \n  // Si a√∫n es mayor a 100KB, tomamos medidas dr√°sticas\n  if (serializedSize > 100000) {\n    console.warn('‚ö†Ô∏è ADVERTENCIA: Plato demasiado grande incluso despu√©s de optimizaciones');\n    \n    // Crear objeto m√≠nimo que contenga solo campos esenciales\n    const minimalPlato = {\n      id: syncPlato.id,\n      name: syncPlato.name,\n      price: syncPlato.price,\n      description: syncPlato.description ? syncPlato.description.substring(0, 100) + '...' : '',\n      includesDrink: syncPlato.includesDrink,\n      availableQuantity: syncPlato.availableQuantity,\n      is_available: syncPlato.is_available !== false,\n      // Eliminar imagen completamente\n      image: null,\n      oversized: true\n    };\n    \n    console.log('üîÑ Usando versi√≥n m√≠nima del plato para sincronizaci√≥n');\n    return minimalPlato;\n  }\n  \n  console.log('‚úÖ Plato preparado para sincronizaci√≥n');\n  return syncPlato;\n}\n\n/**\n * Funci√≥n auxiliar para guardar platos desde cualquier formulario de la aplicaci√≥n\n * @param {Object} platoData - Datos del plato a guardar\n * @returns {Promise<Object>} El plato guardado\n */\nasync function guardarPlato(platoData) {\n  console.log('üîÑ Iniciando guardado de plato con guardarPlato():', platoData);\n  \n  try {\n    // Validaci√≥n de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto v√°lido');\n    }\n    \n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre v√°lido');\n    }\n    \n    // Normalizar los datos del plato\n    const platoParaGuardar = normalizePlatoData(platoData);\n    console.log('‚úÖ Datos normalizados:', platoParaGuardar);\n    \n    // Usar la funci√≥n createPlato\n    const platoGuardado = await createPlato(platoParaGuardar);\n    \n    console.log('‚úÖ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('‚ùå Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Guardar un plato en IndexedDB\nconst savePlato = async (platoData) => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n      \n      // Validaci√≥n adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      \n      const db = await openDB();\n      \n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n      \n      // Agregar estado de sincronizaci√≥n al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      \n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      \n      request.onsuccess = async (event) => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n        \n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = { ...platoToSave, id: savedId };\n        \n        // Agregar a la cola de sincronizaci√≥n\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronizaci√≥n');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronizaci√≥n:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n        \n        // Verificaci√≥n inmediata para depuraci√≥n\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificaci√≥n exitosa del guardado del plato');\n            } else {\n              console.warn('‚ö†Ô∏è Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        \n        resolve(savedPlato);\n      };\n      \n      request.onerror = (event) => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n      \n      // Manejar errores de transacci√≥n\n      transaction.onerror = (event) => {\n        console.error('Error en la transacci√≥n de guardado:', event.target.error);\n        reject(new Error('Error en la transacci√≥n: ' + event.target.error.message));\n      };\n      \n      transaction.oncomplete = () => {\n        console.log('Transacci√≥n de guardado completada exitosamente');\n      };\n      \n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Implementar y exportar getPlato si no existe\nconst getPlato = async (id) => {\n  try {\n    console.log(`Obteniendo plato con ID ${id} de IndexedDB...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      \n      request.onsuccess = (event) => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Plato con ID ${id} encontrado:`, plato);\n          resolve(plato);\n        } else {\n          console.log(`No se encontr√≥ plato con ID ${id}`);\n          resolve(null);\n        }\n      };\n      \n      request.onerror = (event) => {\n        console.error(`Error al obtener plato con ID ${id}:`, event);\n        reject(`Error al obtener plato con ID ${id}`);\n      };\n    });\n  } catch (error) {\n    console.error(`Error en getPlato:`, error);\n    throw error;\n  }\n};\n\n// Simplificar la exposici√≥n de la funci√≥n de depuraci√≥n\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la funci√≥n guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\n\nexport {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  // Exportar la nueva funci√≥n\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};\n\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  normalizePlatoData,\n  guardarPlato,  // Exportar la nueva funci√≥n\n  preparePlatoForSync,\n  compressImageForSync,\n  getPlato\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}