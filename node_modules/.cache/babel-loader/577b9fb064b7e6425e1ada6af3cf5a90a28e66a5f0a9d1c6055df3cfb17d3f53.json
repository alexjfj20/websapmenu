{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport * as apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      const userCount = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.length : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.filter(user => user.estado === 'activo').length : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n\n      const inactiveUsers = userCount - activeUsers;\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n          // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n          {\n            tipo: 'user_created',\n            usuario_nombre: 'Admin',\n            accion: 'creó un nuevo usuario',\n            fecha: new Date().toISOString()\n          }, {\n            tipo: 'login',\n            usuario_nombre: 'Laura Méndez',\n            accion: 'inició sesión en el sistema',\n            fecha: new Date().toISOString()\n          }, {\n            tipo: 'payment',\n            usuario_nombre: 'Carlos Gómez',\n            accion: 'realizó un pago de $350.000',\n            fecha: new Date(Date.now() - 3600000).toISOString() // 1 hora atrás\n          }, {\n            tipo: 'backup',\n            usuario_nombre: 'Sistema',\n            accion: 'realizó un respaldo automático',\n            fecha: new Date(Date.now() - 172800000).toISOString() // 2 días atrás\n          }]\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/stats');\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    // Incluso en caso de error, devolver alguna información\n    return {\n      success: false,\n      error: error.message,\n      data: {\n        totalUsers: localUsers.length || 1,\n        activeUsers: localUsers.length || 1,\n        inactiveUsers: 0,\n        menuItemsCount: 0,\n        totalSales: 0,\n        status: 'Error',\n        recentActivity: []\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/menu-items');\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const soldItems = await storageService.getSoldItems();\n      return {\n        success: true,\n        data: soldItems\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/sold-items');\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un producto y guarda el historial de cambios\n * @param {string} itemId - ID del producto a actualizar\n * @param {number} newQuantity - Nueva cantidad de stock\n * @param {Object} historyRecord - Registro para el historial de cambios\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newQuantity, historyRecord) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      // Primero obtener el elemento actual\n      const menuItem = await getMenuItem(itemId);\n      if (!menuItem.success || !menuItem.data) {\n        throw new Error('Producto no encontrado');\n      }\n\n      // Actualizar el stock\n      await storageService.updateItemAvailability(itemId, newQuantity);\n\n      // Actualizar el historial\n      if (historyRecord) {\n        // Si no existe stockHistory, crearlo\n        if (!menuItem.data.stockHistory) {\n          menuItem.data.stockHistory = [];\n        }\n\n        // Añadir el nuevo registro al historial\n        menuItem.data.stockHistory.push(historyRecord);\n\n        // Guardar el item actualizado con el historial\n        await storageService.saveMenuItem({\n          ...menuItem.data,\n          availableQuantity: newQuantity,\n          lastUpdated: new Date().toISOString()\n        });\n      }\n      return {\n        success: true,\n        message: 'Stock actualizado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/update-stock', {\n      itemId,\n      newQuantity,\n      historyRecord\n    });\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Desactivamos la simulación local\n      // Si la lista local está vacía, inicializarla con usuarios default\n      if (localUsers.length === 0) {\n        localUsers = [{\n          id: 1,\n          nombre: 'Admin Principal',\n          email: 'admin@ejemplo.com',\n          telefono: '3001234567',\n          roles: ['Superadministrador'],\n          estado: 'activo',\n          fecha_creacion: '2023-05-15T08:30:00Z'\n        }, {\n          id: 2,\n          nombre: 'Juan Pérez',\n          email: 'juan@ejemplo.com',\n          telefono: '3009876543',\n          roles: ['Administrador'],\n          estado: 'activo',\n          fecha_creacion: '2023-06-20T14:45:00Z'\n        }, {\n          id: 3,\n          nombre: 'María López',\n          email: 'maria@ejemplo.com',\n          telefono: '3002223344',\n          roles: ['Empleado'],\n          estado: 'activo',\n          fecha_creacion: '2023-07-05T11:15:00Z'\n        }, {\n          id: 4,\n          nombre: 'Carlos Rodríguez',\n          email: 'carlos@ejemplo.com',\n          telefono: '3005556677',\n          roles: ['Empleado'],\n          estado: 'inactivo',\n          fecha_creacion: '2023-08-10T09:20:00Z'\n        }];\n      }\n      console.log(\"getUsers - Total usuarios en memoria:\", localUsers.length);\n\n      // Aplicar filtros\n      let filteredUsers = [...localUsers];\n      if (options.searchTerm) {\n        const term = options.searchTerm.toLowerCase();\n        filteredUsers = filteredUsers.filter(user => user.nombre.toLowerCase().includes(term) || user.email.toLowerCase().includes(term) || user.telefono && user.telefono.toLowerCase().includes(term));\n      }\n      if (options.role) {\n        filteredUsers = filteredUsers.filter(user => user.roles && user.roles.includes(options.role));\n      }\n      if (options.status) {\n        filteredUsers = filteredUsers.filter(user => user.estado === options.status);\n      }\n      return {\n        success: true,\n        data: filteredUsers,\n        total: filteredUsers.length\n      };\n    }\n\n    // Siempre usar la API real\n    console.log(\"Obteniendo usuarios desde la API real con opciones:\", options);\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Construir los parámetros de consulta\n    let queryParams = new URLSearchParams();\n    if (options.searchTerm) queryParams.append('search', options.searchTerm);\n    if (options.role) queryParams.append('role', options.role);\n    if (options.status) queryParams.append('status', options.status);\n    if (options.page) queryParams.append('page', options.page);\n    if (options.limit) queryParams.append('limit', options.limit);\n    const queryString = queryParams.toString();\n    console.log(\"Query string construido:\", queryString);\n\n    // Llamar a la API real\n    const url = `/admin/users${queryString ? '?' + queryString : ''}`;\n    console.log(\"URL de la solicitud:\", url);\n    try {\n      const response = await apiService.default.get(url);\n      console.log(\"Respuesta de la API de usuarios:\", response);\n\n      // Verificar que la respuesta tiene el formato correcto\n      if (response && typeof response === 'object') {\n        // Si la respuesta no tiene la propiedad success, asumimos que es exitosa\n        if (!('success' in response)) {\n          return {\n            success: true,\n            data: Array.isArray(response) ? response : response.data || [],\n            total: Array.isArray(response) ? response.length : response.total || 0\n          };\n        }\n        return response;\n      } else {\n        console.error(\"Respuesta inesperada de la API:\", response);\n        return {\n          success: false,\n          message: 'Formato de respuesta inesperado',\n          data: []\n        };\n      }\n    } catch (apiError) {\n      console.error(\"Error en la llamada a la API:\", apiError);\n      // Proporcionar una respuesta con formato consistente incluso en caso de error\n      return {\n        success: false,\n        message: apiError.message || 'Error al obtener usuarios',\n        data: []\n      };\n    }\n  } catch (error) {\n    console.error('Error general en getUsers:', error);\n    // Proporcionar una respuesta con formato consistente incluso en caso de error general\n    return {\n      success: false,\n      message: error.message || 'Error al obtener usuarios',\n      data: []\n    };\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [{\n          id: 1,\n          timestamp: new Date().toISOString(),\n          type: 'info',\n          user: 'Admin',\n          message: 'Inicio de sesión exitoso',\n          details: {\n            ip: '192.168.1.1',\n            userAgent: 'Chrome/96.0'\n          }\n        }, {\n          id: 2,\n          timestamp: new Date(Date.now() - 3600000).toISOString(),\n          // 1 hora atrás\n          type: 'warning',\n          user: 'Sistema',\n          message: 'Intento de acceso fallido',\n          details: {\n            ip: '203.0.113.1',\n            userAgent: 'Edge/96.0',\n            attempts: 3\n          }\n        }, {\n          id: 3,\n          timestamp: new Date(Date.now() - 7200000).toISOString(),\n          // 2 horas atrás\n          type: 'error',\n          user: 'Sistema',\n          message: 'Error en la creación de backup',\n          details: {\n            error: 'Espacio insuficiente',\n            code: 'E0023'\n          }\n        }, {\n          id: 4,\n          timestamp: new Date(Date.now() - 86400000).toISOString(),\n          // 1 día atrás\n          type: 'success',\n          user: 'Juan Pérez',\n          message: 'Nuevo usuario creado',\n          details: {\n            newUser: 'carlos@ejemplo.com'\n          }\n        }]\n      });\n    }, 500);\n  });\n}\n\n/**\n * Obtiene un elemento del menú por su ID\n * @param {string} itemId - ID del elemento a obtener\n * @returns {Promise<Object>} Elemento del menú\n */\nexport async function getMenuItem(itemId) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      const menuItems = await storageService.getMenuItems();\n      const item = menuItems.find(item => item.id === itemId);\n      if (!item) {\n        return {\n          success: false,\n          message: 'Elemento no encontrado'\n        };\n      }\n      return {\n        success: true,\n        data: item\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get(`/admin/menu-items/${itemId}`);\n  } catch (error) {\n    console.error(`Error al obtener elemento del menú con ID ${itemId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // En desarrollo, devolver roles simulados\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [{\n          id: 1,\n          nombre: 'Superadministrador',\n          descripcion: 'Control total del sistema'\n        }, {\n          id: 2,\n          nombre: 'Administrador',\n          descripcion: 'Gestión de usuarios y configuración'\n        }, {\n          id: 3,\n          nombre: 'Empleado',\n          descripcion: 'Operaciones básicas'\n        }]\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData - Datos del nuevo usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createUser(userData) {\n  try {\n    // En desarrollo, simular creación\n    if (process.env.NODE_ENV === 'development') {\n      // Validar datos mínimos\n      if (!userData.nombre || !userData.email || !userData.password) {\n        return {\n          success: false,\n          message: 'Faltan datos obligatorios'\n        };\n      }\n\n      // Verificar si el correo ya existe\n      const existingUser = localUsers.find(user => user.email === userData.email);\n      if (existingUser) {\n        return {\n          success: false,\n          message: 'El correo electrónico ya está registrado'\n        };\n      }\n\n      // Generar ID único\n      const newId = localUsers.length > 0 ? Math.max(...localUsers.map(user => user.id)) + 1 : 1;\n\n      // Crear nuevo usuario\n      const newUser = {\n        id: newId,\n        nombre: userData.nombre,\n        email: userData.email,\n        telefono: userData.telefono || '',\n        // En un entorno real, la contraseña se hashearía\n        password: userData.password,\n        roles: userData.roles || ['Empleado'],\n        estado: 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n\n      // Añadir a la lista local\n      localUsers.push(newUser);\n      console.log(`Usuario creado: ${newUser.nombre} (${newUser.email})`);\n      return {\n        success: true,\n        message: 'Usuario creado correctamente',\n        data: {\n          id: newUser.id,\n          nombre: newUser.nombre,\n          email: newUser.email,\n          roles: newUser.roles,\n          estado: newUser.estado\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/users', userData);\n  } catch (error) {\n    console.error('Error al crear usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear usuario'\n    };\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {number} userId - ID del usuario a actualizar\n * @param {Object} userData - Nuevos datos del usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateUser(userId, userData) {\n  try {\n    // En desarrollo, simular actualización\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n\n      // Actualizar datos\n      const updatedUser = {\n        ...localUsers[userIndex],\n        ...userData,\n        // Mantener ID y correo original\n        id: userId,\n        email: localUsers[userIndex].email\n      };\n\n      // Actualizar en la lista local\n      localUsers[userIndex] = updatedUser;\n      console.log(`Usuario actualizado: ${updatedUser.nombre} (ID: ${updatedUser.id})`);\n      return {\n        success: true,\n        message: 'Usuario actualizado correctamente',\n        data: {\n          id: updatedUser.id,\n          nombre: updatedUser.nombre,\n          email: updatedUser.email,\n          roles: updatedUser.roles,\n          estado: updatedUser.estado\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.put(`/admin/users/${userId}`, userData);\n  } catch (error) {\n    console.error('Error al actualizar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar usuario'\n    };\n  }\n}\n\n/**\n * Cambia el estado de un usuario (activo/inactivo)\n * @param {number} userId - ID del usuario\n * @param {string} estado - Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(userId, estado) {\n  try {\n    // Validar estado\n    if (estado !== 'activo' && estado !== 'inactivo') {\n      return {\n        success: false,\n        message: 'Estado inválido'\n      };\n    }\n\n    // En desarrollo, simular cambio de estado\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n\n      // Actualizar estado\n      localUsers[userIndex].estado = estado;\n      console.log(`Estado de usuario ${userId} cambiado a: ${estado}`);\n      return {\n        success: true,\n        message: `Usuario ${estado === 'activo' ? 'activado' : 'desactivado'} correctamente`,\n        data: {\n          id: localUsers[userIndex].id,\n          estado: localUsers[userIndex].estado\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.put(`/admin/users/${userId}/estado`, {\n      estado\n    });\n  } catch (error) {\n    console.error('Error al cambiar estado de usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al cambiar estado de usuario'\n    };\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {number} userId - ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(userId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n\n      // Eliminar de la lista local\n      const deletedUser = localUsers.splice(userIndex, 1)[0];\n      console.log(`Usuario eliminado: ${deletedUser.nombre} (ID: ${deletedUser.id})`);\n      return {\n        success: true,\n        message: 'Usuario eliminado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.delete(`/admin/users/${userId}`);\n  } catch (error) {\n    console.error('Error al eliminar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar usuario'\n    };\n  }\n}\n\n/**\n * Realiza un respaldo del sistema\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createBackup() {\n  try {\n    // En desarrollo, simular respaldo\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      const backupId = Date.now().toString();\n      const backupDate = new Date().toISOString();\n      console.log(`Respaldo creado: ${backupId} (${backupDate})`);\n      return {\n        success: true,\n        message: 'Respaldo creado correctamente',\n        data: {\n          id: backupId,\n          fecha: backupDate,\n          tamaño: '2.3 MB',\n          estado: 'Completado'\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/backups');\n  } catch (error) {\n    console.error('Error al crear respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear respaldo'\n    };\n  }\n}\n\n/**\n * Obtiene la lista de respaldos\n * @returns {Promise<Object>} Lista de respaldos\n */\nexport async function getBackups() {\n  try {\n    // En desarrollo, devolver respaldos simulados\n    if (process.env.NODE_ENV === 'development') {\n      const now = Date.now();\n      return {\n        success: true,\n        data: [{\n          id: '1',\n          fecha: new Date(now - 3600000).toISOString(),\n          // 1 hora atrás\n          tamaño: '2.3 MB',\n          usuario: 'Admin',\n          estado: 'Completado',\n          tipo: 'Manual'\n        }, {\n          id: '2',\n          fecha: new Date(now - 86400000).toISOString(),\n          // 1 día atrás\n          tamaño: '2.1 MB',\n          usuario: 'Sistema',\n          estado: 'Completado',\n          tipo: 'Automático'\n        }, {\n          id: '3',\n          fecha: new Date(now - 172800000).toISOString(),\n          // 2 días atrás\n          tamaño: '2.0 MB',\n          usuario: 'Sistema',\n          estado: 'Completado',\n          tipo: 'Automático'\n        }]\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/backups');\n  } catch (error) {\n    console.error('Error al obtener respaldos:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Restaura el sistema desde un respaldo\n * @param {string} backupId - ID del respaldo a restaurar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function restoreBackup(backupId) {\n  try {\n    // En desarrollo, simular restauración\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      console.log(`Restauración desde respaldo ${backupId} completada`);\n      return {\n        success: true,\n        message: 'Sistema restaurado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.post(`/admin/backups/${backupId}/restore`);\n  } catch (error) {\n    console.error('Error al restaurar desde respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al restaurar desde respaldo'\n    };\n  }\n}\n\n/**\n * Elimina un respaldo\n * @param {string} backupId - ID del respaldo a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteBackup(backupId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Respaldo ${backupId} eliminado`);\n      return {\n        success: true,\n        message: 'Respaldo eliminado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.delete(`/admin/backups/${backupId}`);\n  } catch (error) {\n    console.error('Error al eliminar respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar respaldo'\n    };\n  }\n}","map":{"version":3,"names":["storageService","apiService","localUsers","getDashboardStats","process","env","NODE_ENV","usersResponse","getUsers","userCount","success","Array","isArray","data","length","activeUsers","filter","user","estado","Math","floor","inactiveUsers","console","log","totalUsers","activePayments","pendingPayments","overduePayments","totalIncome","status","lastBackup","Date","toISOString","recentActivity","tipo","usuario_nombre","accion","fecha","now","get","error","message","menuItemsCount","totalSales","getMenuItems","menuItems","getSoldItems","soldItems","updateItemStock","itemId","newQuantity","historyRecord","menuItem","getMenuItem","Error","updateItemAvailability","stockHistory","push","saveMenuItem","availableQuantity","lastUpdated","post","options","id","nombre","email","telefono","roles","fecha_creacion","filteredUsers","searchTerm","term","toLowerCase","includes","role","total","token","localStorage","getItem","queryParams","URLSearchParams","append","page","limit","queryString","toString","url","response","default","apiError","getLogs","Promise","resolve","setTimeout","timestamp","type","details","ip","userAgent","attempts","code","newUser","item","find","getRoles","descripcion","createUser","userData","password","existingUser","newId","max","map","updateUser","userId","userIndex","findIndex","updatedUser","put","cambiarEstadoUsuario","deleteUser","deletedUser","splice","delete","createBackup","backupId","backupDate","tamaño","getBackups","usuario","restoreBackup","deleteBackup"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/adminService.js"],"sourcesContent":["/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport * as apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      \n      const userCount = (usersResponse && usersResponse.success && Array.isArray(usersResponse.data)) \n        ? usersResponse.data.length \n        : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data)\n        ? usersResponse.data.filter(user => user.estado === 'activo').length\n        : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n        \n      const inactiveUsers = userCount - activeUsers;\n\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n            // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n            {\n              tipo: 'user_created',\n              usuario_nombre: 'Admin',\n              accion: 'creó un nuevo usuario',\n              fecha: new Date().toISOString()\n            },\n            {\n              tipo: 'login',\n              usuario_nombre: 'Laura Méndez',\n              accion: 'inició sesión en el sistema',\n              fecha: new Date().toISOString()\n            },\n            {\n              tipo: 'payment',\n              usuario_nombre: 'Carlos Gómez',\n              accion: 'realizó un pago de $350.000',\n              fecha: new Date(Date.now() - 3600000).toISOString() // 1 hora atrás\n            },\n            {\n              tipo: 'backup',\n              usuario_nombre: 'Sistema',\n              accion: 'realizó un respaldo automático',\n              fecha: new Date(Date.now() - 172800000).toISOString() // 2 días atrás\n            }\n          ]\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/stats');\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    // Incluso en caso de error, devolver alguna información\n    return {\n      success: false,\n      error: error.message,\n      data: {\n        totalUsers: localUsers.length || 1,\n        activeUsers: localUsers.length || 1,\n        inactiveUsers: 0,\n        menuItemsCount: 0,\n        totalSales: 0,\n        status: 'Error',\n        recentActivity: []\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems,\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/menu-items');\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const soldItems = await storageService.getSoldItems();\n      return {\n        success: true,\n        data: soldItems\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/sold-items');\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un producto y guarda el historial de cambios\n * @param {string} itemId - ID del producto a actualizar\n * @param {number} newQuantity - Nueva cantidad de stock\n * @param {Object} historyRecord - Registro para el historial de cambios\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newQuantity, historyRecord) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      // Primero obtener el elemento actual\n      const menuItem = await getMenuItem(itemId);\n      \n      if (!menuItem.success || !menuItem.data) {\n        throw new Error('Producto no encontrado');\n      }\n      \n      // Actualizar el stock\n      await storageService.updateItemAvailability(itemId, newQuantity);\n      \n      // Actualizar el historial\n      if (historyRecord) {\n        // Si no existe stockHistory, crearlo\n        if (!menuItem.data.stockHistory) {\n          menuItem.data.stockHistory = [];\n        }\n        \n        // Añadir el nuevo registro al historial\n        menuItem.data.stockHistory.push(historyRecord);\n        \n        // Guardar el item actualizado con el historial\n        await storageService.saveMenuItem({\n          ...menuItem.data,\n          availableQuantity: newQuantity,\n          lastUpdated: new Date().toISOString()\n        });\n      }\n      \n      return {\n        success: true,\n        message: 'Stock actualizado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/update-stock', {\n      itemId,\n      newQuantity,\n      historyRecord\n    });\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development' && false) { // Desactivamos la simulación local\n      // Si la lista local está vacía, inicializarla con usuarios default\n      if (localUsers.length === 0) {\n        localUsers = [\n          {\n            id: 1,\n            nombre: 'Admin Principal',\n            email: 'admin@ejemplo.com',\n            telefono: '3001234567',\n            roles: ['Superadministrador'],\n            estado: 'activo',\n            fecha_creacion: '2023-05-15T08:30:00Z'\n          },\n          {\n            id: 2,\n            nombre: 'Juan Pérez',\n            email: 'juan@ejemplo.com',\n            telefono: '3009876543',\n            roles: ['Administrador'],\n            estado: 'activo',\n            fecha_creacion: '2023-06-20T14:45:00Z'\n          },\n          {\n            id: 3,\n            nombre: 'María López',\n            email: 'maria@ejemplo.com',\n            telefono: '3002223344',\n            roles: ['Empleado'],\n            estado: 'activo',\n            fecha_creacion: '2023-07-05T11:15:00Z'\n          },\n          {\n            id: 4,\n            nombre: 'Carlos Rodríguez',\n            email: 'carlos@ejemplo.com',\n            telefono: '3005556677',\n            roles: ['Empleado'],\n            estado: 'inactivo',\n            fecha_creacion: '2023-08-10T09:20:00Z'\n          }\n        ];\n      }\n      console.log(\"getUsers - Total usuarios en memoria:\", localUsers.length);\n      \n      // Aplicar filtros\n      let filteredUsers = [...localUsers];\n      \n      if (options.searchTerm) {\n        const term = options.searchTerm.toLowerCase();\n        filteredUsers = filteredUsers.filter(user => \n          user.nombre.toLowerCase().includes(term) || \n          user.email.toLowerCase().includes(term) ||\n          (user.telefono && user.telefono.toLowerCase().includes(term))\n        );\n      }\n      \n      if (options.role) {\n        filteredUsers = filteredUsers.filter(user => \n          user.roles && user.roles.includes(options.role)\n        );\n      }\n      \n      if (options.status) {\n        filteredUsers = filteredUsers.filter(user => \n          user.estado === options.status\n        );\n      }\n      \n      return {\n        success: true,\n        data: filteredUsers,\n        total: filteredUsers.length\n      };\n    }\n    \n    // Siempre usar la API real\n    console.log(\"Obteniendo usuarios desde la API real con opciones:\", options);\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Construir los parámetros de consulta\n    let queryParams = new URLSearchParams();\n    if (options.searchTerm) queryParams.append('search', options.searchTerm);\n    if (options.role) queryParams.append('role', options.role);\n    if (options.status) queryParams.append('status', options.status);\n    if (options.page) queryParams.append('page', options.page);\n    if (options.limit) queryParams.append('limit', options.limit);\n    \n    const queryString = queryParams.toString();\n    console.log(\"Query string construido:\", queryString);\n    \n    // Llamar a la API real\n    const url = `/admin/users${queryString ? '?' + queryString : ''}`;\n    console.log(\"URL de la solicitud:\", url);\n    \n    try {\n      const response = await apiService.default.get(url);\n      console.log(\"Respuesta de la API de usuarios:\", response);\n      \n      // Verificar que la respuesta tiene el formato correcto\n      if (response && typeof response === 'object') {\n        // Si la respuesta no tiene la propiedad success, asumimos que es exitosa\n        if (!('success' in response)) {\n          return {\n            success: true,\n            data: Array.isArray(response) ? response : (response.data || []),\n            total: Array.isArray(response) ? response.length : (response.total || 0)\n          };\n        }\n        return response;\n      } else {\n        console.error(\"Respuesta inesperada de la API:\", response);\n        return {\n          success: false,\n          message: 'Formato de respuesta inesperado',\n          data: []\n        };\n      }\n    } catch (apiError) {\n      console.error(\"Error en la llamada a la API:\", apiError);\n      // Proporcionar una respuesta con formato consistente incluso en caso de error\n      return {\n        success: false,\n        message: apiError.message || 'Error al obtener usuarios',\n        data: []\n      };\n    }\n  } catch (error) {\n    console.error('Error general en getUsers:', error);\n    // Proporcionar una respuesta con formato consistente incluso en caso de error general\n    return {\n      success: false,\n      message: error.message || 'Error al obtener usuarios',\n      data: []\n    };\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [\n          {\n            id: 1,\n            timestamp: new Date().toISOString(),\n            type: 'info',\n            user: 'Admin',\n            message: 'Inicio de sesión exitoso',\n            details: { ip: '192.168.1.1', userAgent: 'Chrome/96.0' }\n          },\n          {\n            id: 2,\n            timestamp: new Date(Date.now() - 3600000).toISOString(), // 1 hora atrás\n            type: 'warning',\n            user: 'Sistema',\n            message: 'Intento de acceso fallido',\n            details: { ip: '203.0.113.1', userAgent: 'Edge/96.0', attempts: 3 }\n          },\n          {\n            id: 3,\n            timestamp: new Date(Date.now() - 7200000).toISOString(), // 2 horas atrás\n            type: 'error',\n            user: 'Sistema',\n            message: 'Error en la creación de backup',\n            details: { error: 'Espacio insuficiente', code: 'E0023' }\n          },\n          {\n            id: 4,\n            timestamp: new Date(Date.now() - 86400000).toISOString(), // 1 día atrás\n            type: 'success',\n            user: 'Juan Pérez',\n            message: 'Nuevo usuario creado',\n            details: { newUser: 'carlos@ejemplo.com' }\n          }\n        ]\n      });\n    }, 500);\n  });\n}\n\n/**\n * Obtiene un elemento del menú por su ID\n * @param {string} itemId - ID del elemento a obtener\n * @returns {Promise<Object>} Elemento del menú\n */\nexport async function getMenuItem(itemId) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      const menuItems = await storageService.getMenuItems();\n      const item = menuItems.find(item => item.id === itemId);\n      \n      if (!item) {\n        return {\n          success: false,\n          message: 'Elemento no encontrado'\n        };\n      }\n      \n      return {\n        success: true,\n        data: item\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get(`/admin/menu-items/${itemId}`);\n  } catch (error) {\n    console.error(`Error al obtener elemento del menú con ID ${itemId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // En desarrollo, devolver roles simulados\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [\n          { id: 1, nombre: 'Superadministrador', descripcion: 'Control total del sistema' },\n          { id: 2, nombre: 'Administrador', descripcion: 'Gestión de usuarios y configuración' },\n          { id: 3, nombre: 'Empleado', descripcion: 'Operaciones básicas' }\n        ]\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData - Datos del nuevo usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createUser(userData) {\n  try {\n    // En desarrollo, simular creación\n    if (process.env.NODE_ENV === 'development') {\n      // Validar datos mínimos\n      if (!userData.nombre || !userData.email || !userData.password) {\n        return {\n          success: false,\n          message: 'Faltan datos obligatorios'\n        };\n      }\n      \n      // Verificar si el correo ya existe\n      const existingUser = localUsers.find(user => user.email === userData.email);\n      if (existingUser) {\n        return {\n          success: false,\n          message: 'El correo electrónico ya está registrado'\n        };\n      }\n      \n      // Generar ID único\n      const newId = localUsers.length > 0 \n        ? Math.max(...localUsers.map(user => user.id)) + 1 \n        : 1;\n      \n      // Crear nuevo usuario\n      const newUser = {\n        id: newId,\n        nombre: userData.nombre,\n        email: userData.email,\n        telefono: userData.telefono || '',\n        // En un entorno real, la contraseña se hashearía\n        password: userData.password,\n        roles: userData.roles || ['Empleado'],\n        estado: 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n      \n      // Añadir a la lista local\n      localUsers.push(newUser);\n      \n      console.log(`Usuario creado: ${newUser.nombre} (${newUser.email})`);\n      \n      return {\n        success: true,\n        message: 'Usuario creado correctamente',\n        data: {\n          id: newUser.id,\n          nombre: newUser.nombre,\n          email: newUser.email,\n          roles: newUser.roles,\n          estado: newUser.estado\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/users', userData);\n  } catch (error) {\n    console.error('Error al crear usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear usuario'\n    };\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {number} userId - ID del usuario a actualizar\n * @param {Object} userData - Nuevos datos del usuario\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateUser(userId, userData) {\n  try {\n    // En desarrollo, simular actualización\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      \n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n      \n      // Actualizar datos\n      const updatedUser = {\n        ...localUsers[userIndex],\n        ...userData,\n        // Mantener ID y correo original\n        id: userId,\n        email: localUsers[userIndex].email\n      };\n      \n      // Actualizar en la lista local\n      localUsers[userIndex] = updatedUser;\n      \n      console.log(`Usuario actualizado: ${updatedUser.nombre} (ID: ${updatedUser.id})`);\n      \n      return {\n        success: true,\n        message: 'Usuario actualizado correctamente',\n        data: {\n          id: updatedUser.id,\n          nombre: updatedUser.nombre,\n          email: updatedUser.email,\n          roles: updatedUser.roles,\n          estado: updatedUser.estado\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.put(`/admin/users/${userId}`, userData);\n  } catch (error) {\n    console.error('Error al actualizar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al actualizar usuario'\n    };\n  }\n}\n\n/**\n * Cambia el estado de un usuario (activo/inactivo)\n * @param {number} userId - ID del usuario\n * @param {string} estado - Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(userId, estado) {\n  try {\n    // Validar estado\n    if (estado !== 'activo' && estado !== 'inactivo') {\n      return {\n        success: false,\n        message: 'Estado inválido'\n      };\n    }\n    \n    // En desarrollo, simular cambio de estado\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      \n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n      \n      // Actualizar estado\n      localUsers[userIndex].estado = estado;\n      \n      console.log(`Estado de usuario ${userId} cambiado a: ${estado}`);\n      \n      return {\n        success: true,\n        message: `Usuario ${estado === 'activo' ? 'activado' : 'desactivado'} correctamente`,\n        data: {\n          id: localUsers[userIndex].id,\n          estado: localUsers[userIndex].estado\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.put(`/admin/users/${userId}/estado`, { estado });\n  } catch (error) {\n    console.error('Error al cambiar estado de usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al cambiar estado de usuario'\n    };\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {number} userId - ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(userId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      // Buscar usuario por ID\n      const userIndex = localUsers.findIndex(user => user.id === userId);\n      \n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: 'Usuario no encontrado'\n        };\n      }\n      \n      // Eliminar de la lista local\n      const deletedUser = localUsers.splice(userIndex, 1)[0];\n      \n      console.log(`Usuario eliminado: ${deletedUser.nombre} (ID: ${deletedUser.id})`);\n      \n      return {\n        success: true,\n        message: 'Usuario eliminado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.delete(`/admin/users/${userId}`);\n  } catch (error) {\n    console.error('Error al eliminar usuario:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar usuario'\n    };\n  }\n}\n\n/**\n * Realiza un respaldo del sistema\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function createBackup() {\n  try {\n    // En desarrollo, simular respaldo\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      \n      const backupId = Date.now().toString();\n      const backupDate = new Date().toISOString();\n      \n      console.log(`Respaldo creado: ${backupId} (${backupDate})`);\n      \n      return {\n        success: true,\n        message: 'Respaldo creado correctamente',\n        data: {\n          id: backupId,\n          fecha: backupDate,\n          tamaño: '2.3 MB',\n          estado: 'Completado'\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/backups');\n  } catch (error) {\n    console.error('Error al crear respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al crear respaldo'\n    };\n  }\n}\n\n/**\n * Obtiene la lista de respaldos\n * @returns {Promise<Object>} Lista de respaldos\n */\nexport async function getBackups() {\n  try {\n    // En desarrollo, devolver respaldos simulados\n    if (process.env.NODE_ENV === 'development') {\n      const now = Date.now();\n      \n      return {\n        success: true,\n        data: [\n          {\n            id: '1',\n            fecha: new Date(now - 3600000).toISOString(), // 1 hora atrás\n            tamaño: '2.3 MB',\n            usuario: 'Admin',\n            estado: 'Completado',\n            tipo: 'Manual'\n          },\n          {\n            id: '2',\n            fecha: new Date(now - 86400000).toISOString(), // 1 día atrás\n            tamaño: '2.1 MB',\n            usuario: 'Sistema',\n            estado: 'Completado',\n            tipo: 'Automático'\n          },\n          {\n            id: '3',\n            fecha: new Date(now - 172800000).toISOString(), // 2 días atrás\n            tamaño: '2.0 MB',\n            usuario: 'Sistema',\n            estado: 'Completado',\n            tipo: 'Automático'\n          }\n        ]\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/backups');\n  } catch (error) {\n    console.error('Error al obtener respaldos:', error);\n    return {\n      success: false,\n      message: error.message,\n      data: []\n    };\n  }\n}\n\n/**\n * Restaura el sistema desde un respaldo\n * @param {string} backupId - ID del respaldo a restaurar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function restoreBackup(backupId) {\n  try {\n    // En desarrollo, simular restauración\n    if (process.env.NODE_ENV === 'development') {\n      // Simular tiempo de procesamiento\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      console.log(`Restauración desde respaldo ${backupId} completada`);\n      \n      return {\n        success: true,\n        message: 'Sistema restaurado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.post(`/admin/backups/${backupId}/restore`);\n  } catch (error) {\n    console.error('Error al restaurar desde respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al restaurar desde respaldo'\n    };\n  }\n}\n\n/**\n * Elimina un respaldo\n * @param {string} backupId - ID del respaldo a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteBackup(backupId) {\n  try {\n    // En desarrollo, simular eliminación\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`Respaldo ${backupId} eliminado`);\n      \n      return {\n        success: true,\n        message: 'Respaldo eliminado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.delete(`/admin/backups/${backupId}`);\n  } catch (error) {\n    console.error('Error al eliminar respaldo:', error);\n    return {\n      success: false,\n      message: error.message || 'Error al eliminar respaldo'\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}