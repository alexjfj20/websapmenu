{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport * as apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      const userCount = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.length : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data) ? usersResponse.data.filter(user => user.estado === 'activo').length : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n\n      const inactiveUsers = userCount - activeUsers;\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n          // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n          {\n            tipo: 'user_created',\n            usuario_nombre: 'Admin',\n            accion: 'creó un nuevo usuario',\n            fecha: new Date().toISOString()\n          }, {\n            tipo: 'login',\n            usuario_nombre: 'Laura Méndez',\n            accion: 'inició sesión en el sistema',\n            fecha: new Date().toISOString()\n          }, {\n            tipo: 'payment',\n            usuario_nombre: 'Carlos Gómez',\n            accion: 'realizó un pago de $350.000',\n            fecha: new Date(Date.now() - 3600000).toISOString() // 1 hora atrás\n          }, {\n            tipo: 'backup',\n            usuario_nombre: 'Sistema',\n            accion: 'realizó un respaldo automático',\n            fecha: new Date(Date.now() - 172800000).toISOString() // 2 días atrás\n          }]\n        }\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/stats');\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    // Incluso en caso de error, devolver alguna información\n    return {\n      success: false,\n      error: error.message,\n      data: {\n        totalUsers: localUsers.length || 1,\n        activeUsers: localUsers.length || 1,\n        inactiveUsers: 0,\n        menuItemsCount: 0,\n        totalSales: 0,\n        status: 'Error',\n        recentActivity: []\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/menu-items');\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const soldItems = await storageService.getSoldItems();\n      return {\n        success: true,\n        data: soldItems\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/sold-items');\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un producto y guarda el historial de cambios\n * @param {string} itemId - ID del producto a actualizar\n * @param {number} newQuantity - Nueva cantidad de stock\n * @param {Object} historyRecord - Registro para el historial de cambios\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newQuantity, historyRecord) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      // Primero obtener el elemento actual\n      const menuItem = await getMenuItem(itemId);\n      if (!menuItem.success || !menuItem.data) {\n        throw new Error('Producto no encontrado');\n      }\n\n      // Actualizar el stock\n      await storageService.updateItemAvailability(itemId, newQuantity);\n\n      // Actualizar el historial\n      if (historyRecord) {\n        // Si no existe stockHistory, crearlo\n        if (!menuItem.data.stockHistory) {\n          menuItem.data.stockHistory = [];\n        }\n\n        // Añadir el nuevo registro al historial\n        menuItem.data.stockHistory.push(historyRecord);\n\n        // Guardar el item actualizado con el historial\n        await storageService.saveMenuItem({\n          ...menuItem.data,\n          availableQuantity: newQuantity,\n          lastUpdated: new Date().toISOString()\n        });\n      }\n      return {\n        success: true,\n        message: 'Stock actualizado correctamente'\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/update-stock', {\n      itemId,\n      newQuantity,\n      historyRecord\n    });\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Desactivamos la simulación local\n      // Si la lista local está vacía, inicializarla con usuarios default\n      if (localUsers.length === 0) {\n        localUsers = [{\n          id: 1,\n          nombre: 'Admin Principal',\n          email: 'admin@ejemplo.com',\n          telefono: '3001234567',\n          roles: ['Superadministrador'],\n          estado: 'activo',\n          fecha_creacion: '2023-05-15T08:30:00Z'\n        }, {\n          id: 2,\n          nombre: 'Juan Pérez',\n          email: 'juan@ejemplo.com',\n          telefono: '3009876543',\n          roles: ['Administrador'],\n          estado: 'activo',\n          fecha_creacion: '2023-06-20T14:45:00Z'\n        }, {\n          id: 3,\n          nombre: 'María López',\n          email: 'maria@ejemplo.com',\n          telefono: '3002223344',\n          roles: ['Empleado'],\n          estado: 'activo',\n          fecha_creacion: '2023-07-05T11:15:00Z'\n        }, {\n          id: 4,\n          nombre: 'Carlos Rodríguez',\n          email: 'carlos@ejemplo.com',\n          telefono: '3005556677',\n          roles: ['Empleado'],\n          estado: 'inactivo',\n          fecha_creacion: '2023-08-10T09:20:00Z'\n        }];\n      }\n      console.log(\"getUsers - Total usuarios en memoria:\", localUsers.length);\n\n      // Aplicar filtros\n      let filteredUsers = [...localUsers];\n      if (options.searchTerm) {\n        const term = options.searchTerm.toLowerCase();\n        filteredUsers = filteredUsers.filter(user => user.nombre.toLowerCase().includes(term) || user.email.toLowerCase().includes(term) || user.telefono && user.telefono.toLowerCase().includes(term));\n      }\n      if (options.role) {\n        filteredUsers = filteredUsers.filter(user => user.roles && user.roles.includes(options.role));\n      }\n      if (options.status) {\n        filteredUsers = filteredUsers.filter(user => user.estado === options.status);\n      }\n      return {\n        success: true,\n        data: filteredUsers,\n        total: filteredUsers.length\n      };\n    }\n\n    // Siempre usar la API real\n    console.log(\"Obteniendo usuarios desde la API real\");\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Construir los parámetros de consulta\n    let queryParams = '';\n    if (options.searchTerm) queryParams += `search=${encodeURIComponent(options.searchTerm)}&`;\n    if (options.role) queryParams += `role=${encodeURIComponent(options.role)}&`;\n    if (options.status) queryParams += `status=${encodeURIComponent(options.status)}&`;\n    if (options.page) queryParams += `page=${options.page}&`;\n    if (options.limit) queryParams += `limit=${options.limit}&`;\n    if (queryParams.endsWith('&')) {\n      queryParams = queryParams.slice(0, -1);\n    }\n\n    // Llamar a la API real\n    const response = await apiService.default.get(`/admin/users${queryParams ? '?' + queryParams : ''}`);\n    console.log(\"Respuesta de la API de usuarios:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error al obtener usuarios:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [{\n          id: 1,\n          timestamp: new Date().toISOString(),\n          type: 'info',\n          user: 'Admin',\n          message: 'Inicio de sesión exitoso',\n          details: {\n            ip: '192.168.1.1',\n            userAgent: 'Chrome/96.0'\n          }\n        }, {\n          id: 2,\n          timestamp: new Date(Date.now() - 3600000).toISOString(),\n          // 1 hora atrás\n          type: 'warning',\n          user: 'Sistema',\n          message: 'Intento de acceso fallido',\n          details: {\n            ip: '203.0.113.1',\n            userAgent: 'Edge/96.0',\n            attempts: 3\n          }\n        }, {\n          id: 3,\n          timestamp: new Date(Date.now() - 7200000).toISOString(),\n          // 2 horas atrás\n          type: 'error',\n          user: 'Sistema',\n          message: 'Error en la creación de backup',\n          details: {\n            error: 'Espacio insuficiente',\n            code: 'E0023'\n          }\n        }, {\n          id: 4,\n          timestamp: new Date(Date.now() - 86400000).toISOString(),\n          // 1 día atrás\n          type: 'success',\n          user: 'Juan Pérez',\n          message: 'Nuevo usuario creado',\n          details: {\n            newUser: 'carlos@ejemplo.com'\n          }\n        }]\n      });\n    }, 1000);\n  });\n}\n\n/**\n * Descarga los logs en formato CSV\n * @returns {Promise<Object>} Datos CSV de los logs\n */\nexport async function downloadLogsCSV() {\n  // Simulamos la generación de un CSV\n  return new Promise(resolve => {\n    setTimeout(() => {\n      // Encabezados y datos de prueba en formato CSV\n      const csvData = 'Fecha,Tipo,Usuario,Mensaje\\n' + '2023-10-15 10:30:00,info,Admin,Inicio de sesión exitoso\\n' + '2023-10-15 09:30:00,warning,Sistema,Intento de acceso fallido\\n' + '2023-10-15 08:30:00,error,Sistema,Error en la creación de backup\\n' + '2023-10-14 15:45:00,success,Juan Pérez,Nuevo usuario creado';\n      resolve({\n        success: true,\n        data: csvData\n      });\n    }, 1000);\n  });\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Array>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [{\n          id: 1,\n          nombre: 'Superadministrador'\n        }, {\n          id: 2,\n          nombre: 'Administrador'\n        }, {\n          id: 3,\n          nombre: 'Empleado'\n        }]\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene todos los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getAllRoles() {\n  try {\n    // En desarrollo, devolver roles fijos\n    if (process.env.NODE_ENV === 'development') {\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 300));\n      const roles = [{\n        id: 1,\n        nombre: 'Empleado',\n        descripcion: 'Acceso básico al sistema'\n      }, {\n        id: 2,\n        nombre: 'Administrador',\n        descripcion: 'Acceso a configuración y gestión de usuarios'\n      }, {\n        id: 3,\n        nombre: 'Superadministrador',\n        descripcion: 'Acceso total al sistema'\n      }];\n      return {\n        success: true,\n        data: roles\n      };\n    }\n\n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    throw error;\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData Datos del usuario a crear\n * @returns {Promise<Object>} Usuario creado\n */\nexport async function createUser(userData) {\n  try {\n    console.log(\"adminService.createUser - Iniciando creación con datos:\", userData);\n\n    // En desarrollo, simular la creación\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n      // Comprobar si ya existe un usuario con el mismo email\n      const existingUser = localUsers.find(u => u.email && u.email.toLowerCase() === userData.email.toLowerCase());\n      if (existingUser) {\n        return {\n          success: false,\n          error: 'Ya existe un usuario con este correo electrónico.',\n          message: 'El correo electrónico ya está registrado'\n        };\n      }\n\n      // Crear un nuevo usuario con formato completo\n      const newUser = {\n        id: localUsers.length > 0 ? Math.max(...localUsers.map(u => u.id)) + 1 : 1,\n        nombre: userData.nombre || 'Usuario sin nombre',\n        email: userData.email || `usuario${Date.now()}@ejemplo.com`,\n        telefono: userData.telefono || '',\n        roles: Array.isArray(userData.roles) ? [...userData.roles] : ['Empleado'],\n        estado: userData.estado || 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n      console.log(\"Usuario creado para añadir a la lista local:\", newUser);\n\n      // Añadir a la lista local de usuarios\n      localUsers.push(newUser);\n      console.log(\"Lista actualizada de usuarios:\", localUsers.length);\n      return {\n        success: true,\n        data: newUser,\n        message: 'Usuario creado con éxito'\n      };\n    }\n\n    // Siempre usar la API real\n    console.log(\"Llamando a API real para crear usuario:\", userData);\n\n    // Asegurarnos de que los roles sean un array\n    if (userData.roles && !Array.isArray(userData.roles)) {\n      userData.roles = [userData.roles];\n    }\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Llamar al endpoint correcto para crear usuarios con el token en las cabeceras\n    const response = await apiService.default.post('/admin/users', userData);\n    console.log(\"Respuesta de la API:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en adminService.createUser:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {String|Number} id ID del usuario\n * @param {Object} userData Datos actualizados del usuario\n * @returns {Promise<Object>} Usuario actualizado\n */\nexport async function updateUser(id, userData) {\n  try {\n    console.log(`adminService.updateUser - Actualizando usuario con ID ${id}:`, userData);\n\n    // En desarrollo, simular la actualización\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Buscar el usuario en localUsers\n      const userIndex = localUsers.findIndex(user => user.id == id);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n\n      // Actualizar en la lista local\n      const updatedUser = {\n        ...localUsers[userIndex],\n        ...userData\n      };\n      localUsers[userIndex] = updatedUser;\n      console.log('Usuario actualizado:', updatedUser);\n      return {\n        success: true,\n        data: updatedUser,\n        message: 'Usuario actualizado con éxito'\n      };\n    }\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Asegurarnos de que los roles sean un array\n    if (userData.roles && !Array.isArray(userData.roles)) {\n      userData.roles = [userData.roles];\n    }\n\n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para actualizar usuario con ID ${userId}`);\n\n    // Llamar a la API real\n    const response = await apiService.default.put(`/admin/users/${userId}`, userData);\n    console.log(\"Respuesta de la API de actualización:\", response);\n    return response;\n  } catch (error) {\n    console.error(`Error al actualizar usuario con ID ${id}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Cambia el estado de un usuario\n * @param {String|Number} id ID del usuario\n * @param {String} estado Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(id, estado) {\n  try {\n    console.log(`adminService.cambiarEstadoUsuario: ID=${id}, estado=${estado}`);\n\n    // En desarrollo, simular la actualización\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Buscar el usuario en localUsers\n      const userIndex = localUsers.findIndex(user => user.id == id);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n\n      // Cambiar estado\n      localUsers[userIndex].estado = estado;\n      console.log(`Estado de usuario ${id} cambiado a ${estado}`);\n      return {\n        success: true,\n        message: `Estado del usuario cambiado a ${estado} exitosamente`,\n        data: localUsers[userIndex]\n      };\n    }\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para cambiar estado de usuario con ID ${userId} a ${estado}`);\n\n    // En lugar de usar una ruta especial, usamos la misma ruta de actualización\n    // y solo enviamos el campo estado\n    const response = await apiService.default.put(`/admin/users/${userId}`, {\n      estado\n    });\n    console.log(\"Respuesta de la API de cambio de estado:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en cambiarEstadoUsuario:', error);\n    throw error;\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {String|Number} id ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(id) {\n  try {\n    console.log(`adminService.deleteUser: Eliminando usuario con ID ${id}`);\n\n    // En desarrollo, simular la eliminación\n    if (process.env.NODE_ENV === 'development' && false) {\n      // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Verificar que el ID existe\n      const index = localUsers.findIndex(user => user.id == id);\n      if (index === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n\n      // Eliminar el usuario\n      const deletedUser = localUsers.splice(index, 1)[0];\n      console.log(`Usuario eliminado: ${deletedUser.nombre} (ID: ${deletedUser.id})`);\n      return {\n        success: true,\n        message: 'Usuario eliminado exitosamente'\n      };\n    }\n\n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n\n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n\n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para eliminar usuario con ID ${userId}`);\n\n    // Llamar a la API real - usar delete en lugar de del ya que así está exportado en apiService\n    const response = await apiService.default.delete(`/admin/users/${userId}`);\n    console.log(\"Respuesta de la API de eliminación:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en deleteUser:', error);\n    throw error;\n  }\n}\nexport default {\n  getDashboardStats,\n  getMenuItems,\n  getSoldItems,\n  getUsers,\n  getLogs,\n  downloadLogsCSV,\n  getRoles,\n  getAllRoles,\n  createUser,\n  updateUser,\n  cambiarEstadoUsuario,\n  deleteUser\n};","map":{"version":3,"names":["storageService","apiService","localUsers","getDashboardStats","process","env","NODE_ENV","usersResponse","getUsers","userCount","success","Array","isArray","data","length","activeUsers","filter","user","estado","Math","floor","inactiveUsers","console","log","totalUsers","activePayments","pendingPayments","overduePayments","totalIncome","status","lastBackup","Date","toISOString","recentActivity","tipo","usuario_nombre","accion","fecha","now","get","error","message","menuItemsCount","totalSales","getMenuItems","menuItems","getSoldItems","soldItems","updateItemStock","itemId","newQuantity","historyRecord","menuItem","getMenuItem","Error","updateItemAvailability","stockHistory","push","saveMenuItem","availableQuantity","lastUpdated","post","options","id","nombre","email","telefono","roles","fecha_creacion","filteredUsers","searchTerm","term","toLowerCase","includes","role","total","token","localStorage","getItem","queryParams","encodeURIComponent","page","limit","endsWith","slice","response","default","getLogs","Promise","resolve","setTimeout","timestamp","type","details","ip","userAgent","attempts","code","newUser","downloadLogsCSV","csvData","getRoles","getAllRoles","descripcion","createUser","userData","existingUser","find","u","max","map","updateUser","userIndex","findIndex","updatedUser","userId","String","put","cambiarEstadoUsuario","deleteUser","index","deletedUser","splice","delete"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/adminService.js"],"sourcesContent":["/**\n * Servicio para gestionar las operaciones administrativas\n */\nimport * as storageService from './storageService';\nimport * as apiService from './apiService';\n\n// Lista local de usuarios para mantener estado entre llamadas\nlet localUsers = [];\n\n/**\n * Obtiene estadísticas para el dashboard de administrador\n * @returns {Promise<Object>} Estadísticas del sistema\n */\nexport async function getDashboardStats() {\n  try {\n    // En desarrollo, devolver datos simulados pero con lógica para actualizarlos\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener usuarios actuales para tener un conteo real\n      const usersResponse = await getUsers();\n      \n      const userCount = (usersResponse && usersResponse.success && Array.isArray(usersResponse.data)) \n        ? usersResponse.data.length \n        : 45; // Valor por defecto si no podemos obtener el conteo real\n\n      // Calcular usuarios activos/inactivos\n      const activeUsers = usersResponse && usersResponse.success && Array.isArray(usersResponse.data)\n        ? usersResponse.data.filter(user => user.estado === 'activo').length\n        : Math.floor(userCount * 0.75); // Aproximadamente 75% activos por defecto\n        \n      const inactiveUsers = userCount - activeUsers;\n\n      console.log(`Estadísticas actualizadas: ${userCount} usuarios totales (${activeUsers} activos, ${inactiveUsers} inactivos)`);\n\n      return {\n        success: true,\n        data: {\n          totalUsers: userCount,\n          activeUsers: activeUsers,\n          inactiveUsers: inactiveUsers,\n          activePayments: 28,\n          pendingPayments: 8,\n          overduePayments: 3,\n          totalIncome: 15750000,\n          status: 'Normal',\n          lastBackup: new Date().toISOString(),\n          recentActivity: [\n            // Añadir actividad reciente de creación de usuario si se ha creado uno recientemente\n            {\n              tipo: 'user_created',\n              usuario_nombre: 'Admin',\n              accion: 'creó un nuevo usuario',\n              fecha: new Date().toISOString()\n            },\n            {\n              tipo: 'login',\n              usuario_nombre: 'Laura Méndez',\n              accion: 'inició sesión en el sistema',\n              fecha: new Date().toISOString()\n            },\n            {\n              tipo: 'payment',\n              usuario_nombre: 'Carlos Gómez',\n              accion: 'realizó un pago de $350.000',\n              fecha: new Date(Date.now() - 3600000).toISOString() // 1 hora atrás\n            },\n            {\n              tipo: 'backup',\n              usuario_nombre: 'Sistema',\n              accion: 'realizó un respaldo automático',\n              fecha: new Date(Date.now() - 172800000).toISOString() // 2 días atrás\n            }\n          ]\n        }\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/stats');\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    // Incluso en caso de error, devolver alguna información\n    return {\n      success: false,\n      error: error.message,\n      data: {\n        totalUsers: localUsers.length || 1,\n        activeUsers: localUsers.length || 1,\n        inactiveUsers: 0,\n        menuItemsCount: 0,\n        totalSales: 0,\n        status: 'Error',\n        recentActivity: []\n      }\n    };\n  }\n}\n\n/**\n * Obtiene los elementos del menú\n * @returns {Promise<Object>} Lista de elementos del menú\n */\nexport async function getMenuItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const menuItems = await storageService.getMenuItems();\n      return {\n        success: true,\n        data: menuItems,\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/menu-items');\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los elementos vendidos para el inventario\n * @returns {Promise<Object>} Lista de elementos vendidos\n */\nexport async function getSoldItems() {\n  try {\n    // En desarrollo, simular llamada a la API\n    if (process.env.NODE_ENV === 'development') {\n      // Obtener datos del servicio de almacenamiento\n      const soldItems = await storageService.getSoldItems();\n      return {\n        success: true,\n        data: soldItems\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/sold-items');\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza el stock de un producto y guarda el historial de cambios\n * @param {string} itemId - ID del producto a actualizar\n * @param {number} newQuantity - Nueva cantidad de stock\n * @param {Object} historyRecord - Registro para el historial de cambios\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function updateItemStock(itemId, newQuantity, historyRecord) {\n  try {\n    // En desarrollo, usar el servicio de almacenamiento local\n    if (process.env.NODE_ENV === 'development') {\n      // Primero obtener el elemento actual\n      const menuItem = await getMenuItem(itemId);\n      \n      if (!menuItem.success || !menuItem.data) {\n        throw new Error('Producto no encontrado');\n      }\n      \n      // Actualizar el stock\n      await storageService.updateItemAvailability(itemId, newQuantity);\n      \n      // Actualizar el historial\n      if (historyRecord) {\n        // Si no existe stockHistory, crearlo\n        if (!menuItem.data.stockHistory) {\n          menuItem.data.stockHistory = [];\n        }\n        \n        // Añadir el nuevo registro al historial\n        menuItem.data.stockHistory.push(historyRecord);\n        \n        // Guardar el item actualizado con el historial\n        await storageService.saveMenuItem({\n          ...menuItem.data,\n          availableQuantity: newQuantity,\n          lastUpdated: new Date().toISOString()\n        });\n      }\n      \n      return {\n        success: true,\n        message: 'Stock actualizado correctamente'\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.post('/admin/update-stock', {\n      itemId,\n      newQuantity,\n      historyRecord\n    });\n  } catch (error) {\n    console.error('Error al actualizar stock:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los usuarios del sistema\n * @param {Object} options Opciones de filtrado y paginación\n * @returns {Promise<Array>} Lista de usuarios\n */\nexport async function getUsers(options = {}) {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development' && false) { // Desactivamos la simulación local\n      // Si la lista local está vacía, inicializarla con usuarios default\n      if (localUsers.length === 0) {\n        localUsers = [\n          {\n            id: 1,\n            nombre: 'Admin Principal',\n            email: 'admin@ejemplo.com',\n            telefono: '3001234567',\n            roles: ['Superadministrador'],\n            estado: 'activo',\n            fecha_creacion: '2023-05-15T08:30:00Z'\n          },\n          {\n            id: 2,\n            nombre: 'Juan Pérez',\n            email: 'juan@ejemplo.com',\n            telefono: '3009876543',\n            roles: ['Administrador'],\n            estado: 'activo',\n            fecha_creacion: '2023-06-20T14:45:00Z'\n          },\n          {\n            id: 3,\n            nombre: 'María López',\n            email: 'maria@ejemplo.com',\n            telefono: '3002223344',\n            roles: ['Empleado'],\n            estado: 'activo',\n            fecha_creacion: '2023-07-05T11:15:00Z'\n          },\n          {\n            id: 4,\n            nombre: 'Carlos Rodríguez',\n            email: 'carlos@ejemplo.com',\n            telefono: '3005556677',\n            roles: ['Empleado'],\n            estado: 'inactivo',\n            fecha_creacion: '2023-08-10T09:20:00Z'\n          }\n        ];\n      }\n      console.log(\"getUsers - Total usuarios en memoria:\", localUsers.length);\n      \n      // Aplicar filtros\n      let filteredUsers = [...localUsers];\n      \n      if (options.searchTerm) {\n        const term = options.searchTerm.toLowerCase();\n        filteredUsers = filteredUsers.filter(user => \n          user.nombre.toLowerCase().includes(term) || \n          user.email.toLowerCase().includes(term) ||\n          (user.telefono && user.telefono.toLowerCase().includes(term))\n        );\n      }\n      \n      if (options.role) {\n        filteredUsers = filteredUsers.filter(user => \n          user.roles && user.roles.includes(options.role)\n        );\n      }\n      \n      if (options.status) {\n        filteredUsers = filteredUsers.filter(user => \n          user.estado === options.status\n        );\n      }\n      \n      return {\n        success: true,\n        data: filteredUsers,\n        total: filteredUsers.length\n      };\n    }\n    \n    // Siempre usar la API real\n    console.log(\"Obteniendo usuarios desde la API real\");\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Construir los parámetros de consulta\n    let queryParams = '';\n    if (options.searchTerm) queryParams += `search=${encodeURIComponent(options.searchTerm)}&`;\n    if (options.role) queryParams += `role=${encodeURIComponent(options.role)}&`;\n    if (options.status) queryParams += `status=${encodeURIComponent(options.status)}&`;\n    if (options.page) queryParams += `page=${options.page}&`;\n    if (options.limit) queryParams += `limit=${options.limit}&`;\n    if (queryParams.endsWith('&')) {\n      queryParams = queryParams.slice(0, -1);\n    }\n    \n    // Llamar a la API real\n    const response = await apiService.default.get(`/admin/users${queryParams ? '?' + queryParams : ''}`);\n    console.log(\"Respuesta de la API de usuarios:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error al obtener usuarios:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene los registros del sistema\n * @returns {Promise<Object>} Lista de logs\n */\nexport async function getLogs() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({\n        success: true,\n        data: [\n          {\n            id: 1,\n            timestamp: new Date().toISOString(),\n            type: 'info',\n            user: 'Admin',\n            message: 'Inicio de sesión exitoso',\n            details: { ip: '192.168.1.1', userAgent: 'Chrome/96.0' }\n          },\n          {\n            id: 2,\n            timestamp: new Date(Date.now() - 3600000).toISOString(), // 1 hora atrás\n            type: 'warning',\n            user: 'Sistema',\n            message: 'Intento de acceso fallido',\n            details: { ip: '203.0.113.1', userAgent: 'Edge/96.0', attempts: 3 }\n          },\n          {\n            id: 3,\n            timestamp: new Date(Date.now() - 7200000).toISOString(), // 2 horas atrás\n            type: 'error',\n            user: 'Sistema',\n            message: 'Error en la creación de backup',\n            details: { error: 'Espacio insuficiente', code: 'E0023' }\n          },\n          {\n            id: 4,\n            timestamp: new Date(Date.now() - 86400000).toISOString(), // 1 día atrás\n            type: 'success',\n            user: 'Juan Pérez',\n            message: 'Nuevo usuario creado',\n            details: { newUser: 'carlos@ejemplo.com' }\n          }\n        ]\n      });\n    }, 1000);\n  });\n}\n\n/**\n * Descarga los logs en formato CSV\n * @returns {Promise<Object>} Datos CSV de los logs\n */\nexport async function downloadLogsCSV() {\n  // Simulamos la generación de un CSV\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      // Encabezados y datos de prueba en formato CSV\n      const csvData = 'Fecha,Tipo,Usuario,Mensaje\\n' +\n                     '2023-10-15 10:30:00,info,Admin,Inicio de sesión exitoso\\n' +\n                     '2023-10-15 09:30:00,warning,Sistema,Intento de acceso fallido\\n' +\n                     '2023-10-15 08:30:00,error,Sistema,Error en la creación de backup\\n' +\n                     '2023-10-14 15:45:00,success,Juan Pérez,Nuevo usuario creado';\n      \n      resolve({\n        success: true,\n        data: csvData\n      });\n    }, 1000);\n  });\n}\n\n/**\n * Obtiene los roles disponibles en el sistema\n * @returns {Promise<Array>} Lista de roles\n */\nexport async function getRoles() {\n  try {\n    // En desarrollo, devolver datos simulados\n    if (process.env.NODE_ENV === 'development') {\n      return {\n        success: true,\n        data: [\n          { id: 1, nombre: 'Superadministrador' },\n          { id: 2, nombre: 'Administrador' },\n          { id: 3, nombre: 'Empleado' }\n        ]\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    throw error;\n  }\n}\n\n/**\n * Obtiene todos los roles disponibles en el sistema\n * @returns {Promise<Object>} Lista de roles\n */\nexport async function getAllRoles() {\n  try {\n    // En desarrollo, devolver roles fijos\n    if (process.env.NODE_ENV === 'development') {\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 300));\n      \n      const roles = [\n        { id: 1, nombre: 'Empleado', descripcion: 'Acceso básico al sistema' },\n        { id: 2, nombre: 'Administrador', descripcion: 'Acceso a configuración y gestión de usuarios' },\n        { id: 3, nombre: 'Superadministrador', descripcion: 'Acceso total al sistema' }\n      ];\n      \n      return {\n        success: true,\n        data: roles\n      };\n    }\n    \n    // En producción, hacer la llamada a la API real\n    return await apiService.get('/admin/roles');\n  } catch (error) {\n    console.error('Error al obtener roles:', error);\n    throw error;\n  }\n}\n\n/**\n * Crea un nuevo usuario\n * @param {Object} userData Datos del usuario a crear\n * @returns {Promise<Object>} Usuario creado\n */\nexport async function createUser(userData) {\n  try {\n    console.log(\"adminService.createUser - Iniciando creación con datos:\", userData);\n    \n    // En desarrollo, simular la creación\n    if (process.env.NODE_ENV === 'development' && false) { \n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n      // Comprobar si ya existe un usuario con el mismo email\n      const existingUser = localUsers.find(u => u.email && u.email.toLowerCase() === userData.email.toLowerCase());\n      if (existingUser) {\n        return {\n          success: false,\n          error: 'Ya existe un usuario con este correo electrónico.',\n          message: 'El correo electrónico ya está registrado'\n        };\n      }\n      \n      // Crear un nuevo usuario con formato completo\n      const newUser = {\n        id: localUsers.length > 0 ? Math.max(...localUsers.map(u => u.id)) + 1 : 1,\n        nombre: userData.nombre || 'Usuario sin nombre',\n        email: userData.email || `usuario${Date.now()}@ejemplo.com`,\n        telefono: userData.telefono || '',\n        roles: Array.isArray(userData.roles) ? [...userData.roles] : ['Empleado'],\n        estado: userData.estado || 'activo',\n        fecha_creacion: new Date().toISOString()\n      };\n      console.log(\"Usuario creado para añadir a la lista local:\", newUser);\n      \n      // Añadir a la lista local de usuarios\n      localUsers.push(newUser);\n      \n      console.log(\"Lista actualizada de usuarios:\", localUsers.length);\n      \n      return {\n        success: true,\n        data: newUser,\n        message: 'Usuario creado con éxito'\n      };\n    }\n    \n    // Siempre usar la API real\n    console.log(\"Llamando a API real para crear usuario:\", userData);\n    \n    // Asegurarnos de que los roles sean un array\n    if (userData.roles && !Array.isArray(userData.roles)) {\n      userData.roles = [userData.roles];\n    }\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Llamar al endpoint correcto para crear usuarios con el token en las cabeceras\n    const response = await apiService.default.post('/admin/users', userData);\n    console.log(\"Respuesta de la API:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en adminService.createUser:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza un usuario existente\n * @param {String|Number} id ID del usuario\n * @param {Object} userData Datos actualizados del usuario\n * @returns {Promise<Object>} Usuario actualizado\n */\nexport async function updateUser(id, userData) {\n  try {\n    console.log(`adminService.updateUser - Actualizando usuario con ID ${id}:`, userData);\n    \n    // En desarrollo, simular la actualización\n    if (process.env.NODE_ENV === 'development' && false) { // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Buscar el usuario en localUsers\n      const userIndex = localUsers.findIndex(user => user.id == id);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n      \n      // Actualizar en la lista local\n      const updatedUser = {\n        ...localUsers[userIndex],\n        ...userData\n      };\n      localUsers[userIndex] = updatedUser;\n      \n      console.log('Usuario actualizado:', updatedUser);\n      return {\n        success: true,\n        data: updatedUser,\n        message: 'Usuario actualizado con éxito'\n      };\n    }\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Asegurarnos de que los roles sean un array\n    if (userData.roles && !Array.isArray(userData.roles)) {\n      userData.roles = [userData.roles];\n    }\n    \n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para actualizar usuario con ID ${userId}`);\n    \n    // Llamar a la API real\n    const response = await apiService.default.put(`/admin/users/${userId}`, userData);\n    console.log(\"Respuesta de la API de actualización:\", response);\n    return response;\n  } catch (error) {\n    console.error(`Error al actualizar usuario con ID ${id}:`, error);\n    throw error;\n  }\n}\n\n/**\n * Cambia el estado de un usuario\n * @param {String|Number} id ID del usuario\n * @param {String} estado Nuevo estado ('activo' o 'inactivo')\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function cambiarEstadoUsuario(id, estado) {\n  try {\n    console.log(`adminService.cambiarEstadoUsuario: ID=${id}, estado=${estado}`);\n    \n    // En desarrollo, simular la actualización\n    if (process.env.NODE_ENV === 'development' && false) { // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Buscar el usuario en localUsers\n      const userIndex = localUsers.findIndex(user => user.id == id);\n      if (userIndex === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n      \n      // Cambiar estado\n      localUsers[userIndex].estado = estado;\n      \n      console.log(`Estado de usuario ${id} cambiado a ${estado}`);\n      return {\n        success: true,\n        message: `Estado del usuario cambiado a ${estado} exitosamente`,\n        data: localUsers[userIndex]\n      };\n    }\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para cambiar estado de usuario con ID ${userId} a ${estado}`);\n    \n    // En lugar de usar una ruta especial, usamos la misma ruta de actualización\n    // y solo enviamos el campo estado\n    const response = await apiService.default.put(`/admin/users/${userId}`, { estado });\n    console.log(\"Respuesta de la API de cambio de estado:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en cambiarEstadoUsuario:', error);\n    throw error;\n  }\n}\n\n/**\n * Elimina un usuario\n * @param {String|Number} id ID del usuario a eliminar\n * @returns {Promise<Object>} Resultado de la operación\n */\nexport async function deleteUser(id) {\n  try {\n    console.log(`adminService.deleteUser: Eliminando usuario con ID ${id}`);\n    \n    // En desarrollo, simular la eliminación\n    if (process.env.NODE_ENV === 'development' && false) { // Desactivamos la simulación local\n      // Simulando tiempo de respuesta del servidor\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Verificar que el ID existe\n      const index = localUsers.findIndex(user => user.id == id);\n      if (index === -1) {\n        return {\n          success: false,\n          message: `Usuario con ID ${id} no encontrado`\n        };\n      }\n      \n      // Eliminar el usuario\n      const deletedUser = localUsers.splice(index, 1)[0];\n      console.log(`Usuario eliminado: ${deletedUser.nombre} (ID: ${deletedUser.id})`);\n      return {\n        success: true,\n        message: 'Usuario eliminado exitosamente'\n      };\n    }\n    \n    // Obtener el token actual del localStorage\n    const token = localStorage.getItem('token');\n    console.log(\"Token de autenticación disponible:\", !!token);\n    \n    // Verificar si hay un token disponible\n    if (!token) {\n      console.error(\"No hay token de autenticación disponible\");\n      return {\n        success: false,\n        message: 'No hay sesión activa. Por favor, inicie sesión nuevamente.'\n      };\n    }\n    \n    // Convertir el ID a string para asegurarnos de que se pasa correctamente\n    const userId = String(id);\n    console.log(`Llamando a API para eliminar usuario con ID ${userId}`);\n    \n    // Llamar a la API real - usar delete en lugar de del ya que así está exportado en apiService\n    const response = await apiService.default.delete(`/admin/users/${userId}`);\n    console.log(\"Respuesta de la API de eliminación:\", response);\n    return response;\n  } catch (error) {\n    console.error('Error en deleteUser:', error);\n    throw error;\n  }\n}\n\nexport default {\n  getDashboardStats,\n  getMenuItems,\n  getSoldItems,\n  getUsers,\n  getLogs,\n  downloadLogsCSV,\n  getRoles,\n  getAllRoles,\n  createUser,\n  updateUser,\n  cambiarEstadoUsuario,\n  deleteUser\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}