{"ast":null,"code":"// src/services/syncService.js\n\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\nimport { getPendingPlatos, updatePlatoSyncStatus, getSyncQueue, removeFromSyncQueue, preparePlatoForSync } from './indexedDBService';\nconst API_URL = 'http://localhost:3000/api';\n\n// Estado de la sincronizaci√≥n\nlet isSyncing = false;\nlet _isOnline = navigator.onLine;\n\n// Alternativa m√°s simple para verificar la conexi√≥n\nconst isOnline = async () => {\n  // Primero comprobamos el estado de navigator.onLine\n  if (!navigator.onLine) {\n    return false;\n  }\n\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\n  try {\n    const response = await fetch(`${API_URL}/favicon.ico`, {\n      method: 'HEAD',\n      // Solo pedimos las cabeceras, no el contenido\n      mode: 'no-cors',\n      // Modo no-cors para evitar problemas de CORS\n      cache: 'no-store',\n      credentials: 'omit'\n    });\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\n  } catch (error) {\n    console.error('Error al verificar estado de conexi√≥n:', error);\n    return false;\n  }\n};\n\n// Configurar escuchas para eventos de conexi√≥n\nconst setupConnectionListeners = () => {\n  window.addEventListener('online', async () => {\n    console.log('Evento online detectado');\n    _isOnline = await isOnline();\n    if (_isOnline) {\n      console.log('Conexi√≥n a Internet restablecida');\n      // Sincronizar cuando se recupera la conexi√≥n\n      syncData();\n    }\n  });\n  window.addEventListener('offline', () => {\n    console.log('Evento offline detectado');\n    _isOnline = false;\n    console.log('Conexi√≥n a Internet perdida');\n  });\n\n  // Verificar estado inicial\n  isOnline().then(online => {\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\n  });\n};\n\n// Sincronizar un plato con el servidor\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\n  const maxRetries = 3; // N√∫mero m√°ximo de reintentos\n\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\n  try {\n    // Preparar el plato para sincronizaci√≥n (reducir tama√±o de im√°genes, etc.)\n    const preparedPlato = preparePlatoForSync(plato);\n\n    // Verificar el tama√±o final del objeto serializado\n    const platoJsonString = JSON.stringify(preparedPlato);\n    const platoSize = platoJsonString.length;\n    console.log(`üìä Tama√±o de datos a enviar: ${platoSize} bytes`);\n\n    // Verificar si el tama√±o es razonable\n    if (platoSize > 500000) {\n      // 500KB es mucho para una solicitud HTTP\n      console.error(`‚ùå ERROR: Datos demasiado grandes (${platoSize} bytes). Creando versi√≥n m√≠nima...`);\n\n      // Crear versi√≥n m√≠nima para sincronizaci√≥n\n      const minimalPlato = {\n        id: preparedPlato.id,\n        name: preparedPlato.name?.substring(0, 100) || 'Plato sin nombre',\n        price: Number(preparedPlato.price) || 0,\n        includesDrink: Boolean(preparedPlato.includesDrink),\n        availableQuantity: Number(preparedPlato.availableQuantity) || 0,\n        createdAt: preparedPlato.createdAt || new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n\n      // Actualizar para usar esta versi√≥n\n      console.log('üì§ Usando versi√≥n m√≠nima para sincronizaci√≥n');\n      preparedPlato = minimalPlato;\n    }\n\n    // Configurar timeout m√°s largo para la solicitud\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos de timeout\n\n    try {\n      console.log('üì§ Iniciando env√≠o al servidor...');\n\n      // Realizar la solicitud HTTP con los datos optimizados\n      const response = await fetch(`${API_URL}/platos`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(preparedPlato),\n        signal: controller.signal\n      });\n\n      // Limpiar el timeout despu√©s de la respuesta\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        // Intentar obtener m√°s informaci√≥n sobre el error\n        let errorDetails = '';\n        try {\n          const errorResponse = await response.text();\n          errorDetails = errorResponse;\n          console.error('Detalles del error del servidor:', errorResponse);\n        } catch (textError) {\n          console.error('No se pudieron obtener detalles del error');\n        }\n        console.error(`Error del servidor: ${response.status} - ${errorDetails}`);\n\n        // Manejar errores espec√≠ficos\n        if (response.status === 413) {\n          throw new Error('Datos demasiado grandes para el servidor');\n        } else if (response.status === 500 && retryCount < maxRetries) {\n          console.warn(`‚ö†Ô∏è Error 500, reintentando (${retryCount + 1}/${maxRetries})...`);\n          // Esperar antes de reintentar (backoff exponencial)\n          await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, retryCount)));\n          return syncPlatoToServer(plato, retryCount + 1);\n        }\n        throw new Error(`Error del servidor: ${response.status}`);\n      }\n      const serverData = await response.json();\n      console.log('‚úÖ Plato sincronizado con el servidor:', serverData);\n\n      // Actualizar estado de sincronizaci√≥n en IndexedDB\n      await updatePlatoSyncStatus(plato.id, 'synced');\n      return true;\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n\n      // Verificar si es un error de timeout o conexi√≥n\n      if (fetchError.name === 'AbortError') {\n        console.error('‚ùå Timeout de la solicitud');\n        throw new Error('Timeout al comunicarse con el servidor');\n      }\n\n      // Error de conexi√≥n - ECONNRESET y similares\n      if (fetchError.message.includes('ECONNRESET') && retryCount < maxRetries) {\n        console.warn(`‚ö†Ô∏è Error de conexi√≥n (ECONNRESET), reintentando (${retryCount + 1}/${maxRetries})...`);\n        // Esperar antes de reintentar\n        await new Promise(resolve => setTimeout(resolve, 3000 * Math.pow(2, retryCount)));\n        return syncPlatoToServer(plato, retryCount + 1);\n      }\n      throw fetchError;\n    }\n  } catch (error) {\n    console.error('‚ùå Error al sincronizar plato con el servidor:', error);\n\n    // Si hemos agotado los reintentos o es un error que no debemos reintentar\n    if (retryCount >= maxRetries || error.message.includes('demasiado grandes') || error.message.includes('413')) {\n      console.warn('‚ö†Ô∏è No se pudo sincronizar despu√©s de m√∫ltiples intentos o error irrecuperable');\n\n      // Opcionalmente, podr√≠amos marcar este plato con un flag especial\n      try {\n        await updatePlatoSyncStatus(plato.id, 'sync_error');\n      } catch (updateError) {\n        console.error('Error al actualizar estado de sincronizaci√≥n:', updateError);\n      }\n    }\n    return false;\n  }\n};\n\n// Procesar la cola de sincronizaci√≥n\nconst processSyncQueue = async () => {\n  if (!(await isOnline()) || isSyncing) {\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\n    return false;\n  }\n  isSyncing = true;\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\n  try {\n    const syncItems = await getSyncQueue();\n    if (syncItems.length === 0) {\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\n      isSyncing = false;\n      return true;\n    }\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\n\n    // Procesar cada elemento de la cola\n    for (const item of syncItems) {\n      let syncSuccess = false;\n      if (item.type === 'create' && item.entityType === 'plato') {\n        syncSuccess = await syncPlatoToServer(item.data);\n      }\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\n\n      if (syncSuccess) {\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\n        await removeFromSyncQueue(item.id);\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\n      } else {\n        // Corregir el error de sintaxis aqu√≠:\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\n      }\n    }\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\n    return true;\n  } catch (error) {\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Funci√≥n principal para sincronizar datos\nconst syncData = async () => {\n  if (!(await isOnline())) {\n    console.log('Sin conexi√≥n a Internet, la sincronizaci√≥n no es posible');\n    return false;\n  }\n  try {\n    console.log('Iniciando sincronizaci√≥n de datos...');\n\n    // Procesar la cola de sincronizaci√≥n\n    await processSyncQueue();\n\n    // Sincronizar platos pendientes que no est√©n en la cola\n    const pendingPlatos = await getPendingPlatos();\n    console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\n    for (const plato of pendingPlatos) {\n      await syncPlatoToServer(plato);\n    }\n    console.log('Sincronizaci√≥n completada con √©xito');\n    return true;\n  } catch (error) {\n    console.error('Error durante la sincronizaci√≥n:', error);\n    return false;\n  }\n};\n\n// Inicializar el servicio de sincronizaci√≥n\nconst initSyncService = () => {\n  // Configurar escuchas para eventos de conexi√≥n\n  setupConnectionListeners();\n\n  // Realizar sincronizaci√≥n inicial si hay conexi√≥n\n  isOnline().then(online => {\n    if (online) {\n      syncData();\n    }\n  });\n\n  // Configurar sincronizaci√≥n peri√≥dica (cada minuto)\n  setInterval(async () => {\n    if ((await isOnline()) && !isSyncing) {\n      syncData();\n    }\n  }, 60000);\n  console.log('Servicio de sincronizaci√≥n inicializado');\n};\nexport { initSyncService, syncData, isOnline, _isOnline };","map":{"version":3,"names":["getPendingPlatos","updatePlatoSyncStatus","getSyncQueue","removeFromSyncQueue","preparePlatoForSync","API_URL","isSyncing","_isOnline","navigator","onLine","isOnline","response","fetch","method","mode","cache","credentials","error","console","setupConnectionListeners","window","addEventListener","log","syncData","then","online","syncPlatoToServer","plato","retryCount","maxRetries","id","preparedPlato","platoJsonString","JSON","stringify","platoSize","length","minimalPlato","name","substring","price","Number","includesDrink","Boolean","availableQuantity","createdAt","Date","toISOString","updatedAt","controller","AbortController","timeoutId","setTimeout","abort","headers","body","signal","clearTimeout","ok","errorDetails","errorResponse","text","textError","status","Error","warn","Promise","resolve","Math","pow","serverData","json","fetchError","message","includes","updateError","processSyncQueue","syncItems","item","syncSuccess","type","entityType","data","pendingPlatos","initSyncService","setInterval"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/syncService.js"],"sourcesContent":["// src/services/syncService.js\r\n\r\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\r\nimport { \r\n  getPendingPlatos, \r\n  updatePlatoSyncStatus, \r\n  getSyncQueue, \r\n  removeFromSyncQueue,\r\n  preparePlatoForSync \r\n} from './indexedDBService';\r\n\r\nconst API_URL = 'http://localhost:3000/api';\r\n\r\n// Estado de la sincronizaci√≥n\r\nlet isSyncing = false;\r\nlet _isOnline = navigator.onLine;\r\n\r\n// Alternativa m√°s simple para verificar la conexi√≥n\r\nconst isOnline = async () => {\r\n  // Primero comprobamos el estado de navigator.onLine\r\n  if (!navigator.onLine) {\r\n    return false;\r\n  }\r\n  \r\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\r\n  try {\r\n    const response = await fetch(`${API_URL}/favicon.ico`, {\r\n      method: 'HEAD', // Solo pedimos las cabeceras, no el contenido\r\n      mode: 'no-cors', // Modo no-cors para evitar problemas de CORS\r\n      cache: 'no-store',\r\n      credentials: 'omit'\r\n    });\r\n    \r\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\r\n  } catch (error) {\r\n    console.error('Error al verificar estado de conexi√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Configurar escuchas para eventos de conexi√≥n\r\nconst setupConnectionListeners = () => {\r\n  window.addEventListener('online', async () => {\r\n    console.log('Evento online detectado');\r\n    _isOnline = await isOnline();\r\n    if (_isOnline) {\r\n      console.log('Conexi√≥n a Internet restablecida');\r\n      // Sincronizar cuando se recupera la conexi√≥n\r\n      syncData();\r\n    }\r\n  });\r\n  \r\n  window.addEventListener('offline', () => {\r\n    console.log('Evento offline detectado');\r\n    _isOnline = false;\r\n    console.log('Conexi√≥n a Internet perdida');\r\n  });\r\n  \r\n  // Verificar estado inicial\r\n  isOnline().then(online => {\r\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\r\n  });\r\n};\r\n\r\n// Sincronizar un plato con el servidor\r\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\r\n  const maxRetries = 3; // N√∫mero m√°ximo de reintentos\r\n  \r\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\r\n  \r\n  try {\r\n    // Preparar el plato para sincronizaci√≥n (reducir tama√±o de im√°genes, etc.)\r\n    const preparedPlato = preparePlatoForSync(plato);\r\n    \r\n    // Verificar el tama√±o final del objeto serializado\r\n    const platoJsonString = JSON.stringify(preparedPlato);\r\n    const platoSize = platoJsonString.length;\r\n    \r\n    console.log(`üìä Tama√±o de datos a enviar: ${platoSize} bytes`);\r\n    \r\n    // Verificar si el tama√±o es razonable\r\n    if (platoSize > 500000) { // 500KB es mucho para una solicitud HTTP\r\n      console.error(`‚ùå ERROR: Datos demasiado grandes (${platoSize} bytes). Creando versi√≥n m√≠nima...`);\r\n      \r\n      // Crear versi√≥n m√≠nima para sincronizaci√≥n\r\n      const minimalPlato = {\r\n        id: preparedPlato.id,\r\n        name: preparedPlato.name?.substring(0, 100) || 'Plato sin nombre',\r\n        price: Number(preparedPlato.price) || 0,\r\n        includesDrink: Boolean(preparedPlato.includesDrink),\r\n        availableQuantity: Number(preparedPlato.availableQuantity) || 0,\r\n        createdAt: preparedPlato.createdAt || new Date().toISOString(),\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n      \r\n      // Actualizar para usar esta versi√≥n\r\n      console.log('üì§ Usando versi√≥n m√≠nima para sincronizaci√≥n');\r\n      preparedPlato = minimalPlato;\r\n    }\r\n    \r\n    // Configurar timeout m√°s largo para la solicitud\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos de timeout\r\n    \r\n    try {\r\n      console.log('üì§ Iniciando env√≠o al servidor...');\r\n      \r\n      // Realizar la solicitud HTTP con los datos optimizados\r\n      const response = await fetch(`${API_URL}/platos`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(preparedPlato),\r\n        signal: controller.signal\r\n      });\r\n      \r\n      // Limpiar el timeout despu√©s de la respuesta\r\n      clearTimeout(timeoutId);\r\n      \r\n      if (!response.ok) {\r\n        // Intentar obtener m√°s informaci√≥n sobre el error\r\n        let errorDetails = '';\r\n        try {\r\n          const errorResponse = await response.text();\r\n          errorDetails = errorResponse;\r\n          console.error('Detalles del error del servidor:', errorResponse);\r\n        } catch (textError) {\r\n          console.error('No se pudieron obtener detalles del error');\r\n        }\r\n        \r\n        console.error(`Error del servidor: ${response.status} - ${errorDetails}`);\r\n        \r\n        // Manejar errores espec√≠ficos\r\n        if (response.status === 413) {\r\n          throw new Error('Datos demasiado grandes para el servidor');\r\n        } else if (response.status === 500 && retryCount < maxRetries) {\r\n          console.warn(`‚ö†Ô∏è Error 500, reintentando (${retryCount + 1}/${maxRetries})...`);\r\n          // Esperar antes de reintentar (backoff exponencial)\r\n          await new Promise(resolve => setTimeout(resolve, 2000 * Math.pow(2, retryCount)));\r\n          return syncPlatoToServer(plato, retryCount + 1);\r\n        }\r\n        \r\n        throw new Error(`Error del servidor: ${response.status}`);\r\n      }\r\n      \r\n      const serverData = await response.json();\r\n      console.log('‚úÖ Plato sincronizado con el servidor:', serverData);\r\n      \r\n      // Actualizar estado de sincronizaci√≥n en IndexedDB\r\n      await updatePlatoSyncStatus(plato.id, 'synced');\r\n      \r\n      return true;\r\n    } catch (fetchError) {\r\n      clearTimeout(timeoutId);\r\n      \r\n      // Verificar si es un error de timeout o conexi√≥n\r\n      if (fetchError.name === 'AbortError') {\r\n        console.error('‚ùå Timeout de la solicitud');\r\n        throw new Error('Timeout al comunicarse con el servidor');\r\n      }\r\n      \r\n      // Error de conexi√≥n - ECONNRESET y similares\r\n      if (fetchError.message.includes('ECONNRESET') && retryCount < maxRetries) {\r\n        console.warn(`‚ö†Ô∏è Error de conexi√≥n (ECONNRESET), reintentando (${retryCount + 1}/${maxRetries})...`);\r\n        // Esperar antes de reintentar\r\n        await new Promise(resolve => setTimeout(resolve, 3000 * Math.pow(2, retryCount)));\r\n        return syncPlatoToServer(plato, retryCount + 1);\r\n      }\r\n      \r\n      throw fetchError;\r\n    }\r\n  } catch (error) {\r\n    console.error('‚ùå Error al sincronizar plato con el servidor:', error);\r\n    \r\n    // Si hemos agotado los reintentos o es un error que no debemos reintentar\r\n    if (retryCount >= maxRetries || \r\n        error.message.includes('demasiado grandes') ||\r\n        error.message.includes('413')) {\r\n      \r\n      console.warn('‚ö†Ô∏è No se pudo sincronizar despu√©s de m√∫ltiples intentos o error irrecuperable');\r\n      \r\n      // Opcionalmente, podr√≠amos marcar este plato con un flag especial\r\n      try {\r\n        await updatePlatoSyncStatus(plato.id, 'sync_error');\r\n      } catch (updateError) {\r\n        console.error('Error al actualizar estado de sincronizaci√≥n:', updateError);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n};\r\n\r\n// Procesar la cola de sincronizaci√≥n\r\nconst processSyncQueue = async () => {\r\n  if (!await isOnline() || isSyncing) {\r\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\r\n    return false;\r\n  }\r\n  \r\n  isSyncing = true;\r\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\r\n  \r\n  try {\r\n    const syncItems = await getSyncQueue();\r\n    \r\n    if (syncItems.length === 0) {\r\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\r\n      isSyncing = false;\r\n      return true;\r\n    }\r\n    \r\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\r\n    \r\n    // Procesar cada elemento de la cola\r\n    for (const item of syncItems) {\r\n      let syncSuccess = false;\r\n      \r\n      if (item.type === 'create' && item.entityType === 'plato') {\r\n        syncSuccess = await syncPlatoToServer(item.data);\r\n      }\r\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\r\n      \r\n      if (syncSuccess) {\r\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\r\n        await removeFromSyncQueue(item.id);\r\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\r\n      } else {\r\n        // Corregir el error de sintaxis aqu√≠:\r\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\r\n      }\r\n    }\r\n    \r\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\r\n    return false;\r\n  } finally {\r\n    isSyncing = false;\r\n  }\r\n};\r\n\r\n// Funci√≥n principal para sincronizar datos\r\nconst syncData = async () => {\r\n  if (!await isOnline()) {\r\n    console.log('Sin conexi√≥n a Internet, la sincronizaci√≥n no es posible');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    console.log('Iniciando sincronizaci√≥n de datos...');\r\n    \r\n    // Procesar la cola de sincronizaci√≥n\r\n    await processSyncQueue();\r\n    \r\n    // Sincronizar platos pendientes que no est√©n en la cola\r\n    const pendingPlatos = await getPendingPlatos();\r\n    console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\r\n    \r\n    for (const plato of pendingPlatos) {\r\n      await syncPlatoToServer(plato);\r\n    }\r\n    \r\n    console.log('Sincronizaci√≥n completada con √©xito');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error durante la sincronizaci√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Inicializar el servicio de sincronizaci√≥n\r\nconst initSyncService = () => {\r\n  // Configurar escuchas para eventos de conexi√≥n\r\n  setupConnectionListeners();\r\n  \r\n  // Realizar sincronizaci√≥n inicial si hay conexi√≥n\r\n  isOnline().then(online => {\r\n    if (online) {\r\n      syncData();\r\n    }\r\n  });\r\n  \r\n  // Configurar sincronizaci√≥n peri√≥dica (cada minuto)\r\n  setInterval(async () => {\r\n    if (await isOnline() && !isSyncing) {\r\n      syncData();\r\n    }\r\n  }, 60000);\r\n  \r\n  console.log('Servicio de sincronizaci√≥n inicializado');\r\n};\r\n\r\nexport {\r\n  initSyncService,\r\n  syncData,\r\n  isOnline,\r\n  _isOnline\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}