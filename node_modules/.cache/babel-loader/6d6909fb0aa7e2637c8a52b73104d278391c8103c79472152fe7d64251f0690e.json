{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 1;\nconst SHARED_MENU_STORE = 'sharedMenus';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      reject('Error al abrir la base de datos: ' + event.target.errorCode);\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n\n      // Crear almacén para menús compartidos si no existe\n      if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n        db.createObjectStore(SHARED_MENU_STORE, {\n          keyPath: 'id'\n        });\n      }\n    };\n  });\n}\n\n/**\r\n * Guarda un menú en IndexedDB y devuelve un ID único\r\n * @param {Array} menuData - Los datos del menú a guardar\r\n * @returns {Promise<string>} - Promesa con el ID del menú guardado\r\n */\nexport async function saveMenu(menuData) {\n  try {\n    // Generar un ID único para el menú\n    const menuId = generateId();\n\n    // Procesar las imágenes para reducir su tamaño\n    const processedMenuData = await Promise.all(menuData.map(async item => {\n      const processedItem = {\n        ...item\n      };\n\n      // Si el item tiene una imagen, la procesamos\n      if (item.image && typeof item.image === 'string' && item.image.length > 0) {\n        try {\n          // Comprimir la imagen usando la función de compressImage de storageService\n          // Si no está disponible, podemos implementar una versión más simple aquí\n          const compressedImage = await compressImage(item.image);\n          processedItem.image = compressedImage;\n        } catch (error) {\n          console.warn('Error al comprimir la imagen del menú:', error);\n        }\n      }\n      return processedItem;\n    }));\n\n    // Preparar el objeto a guardar\n    const menuObject = {\n      id: menuId,\n      items: processedMenuData,\n      createdAt: new Date().toISOString()\n    };\n\n    // Guardar en IndexedDB\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    await new Promise((resolve, reject) => {\n      const request = store.put(menuObject);\n      request.onsuccess = () => resolve();\n      request.onerror = e => reject(e.target.error);\n    });\n    return menuId;\n  } catch (error) {\n    console.error('Error al guardar el menú en IndexedDB:', error);\n\n    // Fallback al localStorage con un objeto simplificado (sin imágenes)\n    try {\n      const menuId = generateId();\n      const simplifiedMenuData = menuData.map(item => ({\n        ...item,\n        image: null,\n        // Eliminamos la imagen para reducir el tamaño\n        hasImage: item.image ? true : false // Indicamos que tenía imagen\n      }));\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify({\n        items: simplifiedMenuData,\n        createdAt: new Date().toISOString()\n      }));\n      return menuId;\n    } catch (localStorageError) {\n      console.error('Error al guardar el menú en localStorage:', localStorageError);\n      throw new Error('No se pudo guardar el menú');\n    }\n  }\n}\n\n/**\r\n * Obtiene un menú guardado por su ID\r\n * @param {string} menuId - El ID del menú a recuperar\r\n * @returns {Promise<Array|null>} - Promesa con los datos del menú o null si no existe\r\n */\nexport async function getMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId} de IndexedDB`);\n    // Intentar recuperar de IndexedDB primero\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readonly');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get(menuId);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = e => reject(e.target.error);\n    });\n    if (result) {\n      console.log(`Menú encontrado en IndexedDB:`, result);\n      // Procesar las imágenes si el menú tiene la propiedad hasImage pero no tiene imagen\n      const processedItems = await Promise.all(result.items.map(async item => {\n        // Si el elemento indica que tiene imagen pero la imagen es null\n        if (item.hasImage && !item.image) {\n          try {\n            // Intentar recuperar la imagen desde IMAGE_STORE si hay ID\n            if (item.id) {\n              const image = await getMenuImage(item.id);\n              if (image) {\n                return {\n                  ...item,\n                  image\n                };\n              }\n            }\n          } catch (error) {\n            console.warn(`No se pudo recuperar la imagen para el elemento ${item.name}:`, error);\n          }\n        }\n        return item;\n      }));\n      return processedItems;\n    }\n\n    // Si no está en IndexedDB, intentar recuperar de localStorage\n    console.log(`Menú no encontrado en IndexedDB, buscando en localStorage`);\n    const localData = localStorage.getItem(`menu_${menuId}`);\n    if (localData) {\n      const parsed = JSON.parse(localData);\n      console.log(`Menú encontrado en localStorage:`, parsed);\n      return parsed.items;\n    }\n    console.log(`Menú no encontrado en ningún almacenamiento`);\n    return null;\n  } catch (error) {\n    console.error('Error al obtener menú:', error);\n\n    // Último intento: recuperar de localStorage\n    try {\n      const localData = localStorage.getItem(`menu_${menuId}`);\n      if (localData) {\n        const parsed = JSON.parse(localData);\n        return parsed.items;\n      }\n    } catch (e) {\n      console.error('Error al recuperar de localStorage:', e);\n    }\n    return null;\n  }\n}\n\n/**\r\n * Limpia menús antiguos que ya no son necesarios\r\n * @returns {Promise<void>}\r\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = e => reject(e.target.error);\n    });\n\n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n\n    // También limpiar localStorage\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.startsWith('menu_')) {\n        try {\n          const menuData = JSON.parse(localStorage.getItem(key));\n          const createdDate = new Date(menuData.createdAt);\n          const diff = now.getTime() - createdDate.getTime();\n          const days = Math.ceil(diff / (1000 * 3600 * 24));\n          if (days > 7) {\n            localStorage.removeItem(key);\n          }\n        } catch (e) {\n          // Si hay un error al procesar este elemento, lo eliminamos también\n          localStorage.removeItem(key);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n/**\r\n * Genera un ID único para un menú\r\n * @returns {string} Un ID único\r\n */\nfunction generateId() {\n  return Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n}\n\n/**\r\n * Comprime una imagen base64\r\n * @param {string} base64Image - La imagen en formato base64\r\n * @returns {Promise<string>} - Promesa con la imagen comprimida\r\n */\nfunction compressImage(base64Image, maxWidth = 600, maxHeight = 400, quality = 0.6) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      let width = img.width;\n      let height = img.height;\n      if (width > height) {\n        if (width > maxWidth) {\n          height = Math.round(height * maxWidth / width);\n          width = maxWidth;\n        }\n      } else {\n        if (height > maxHeight) {\n          width = Math.round(width * maxHeight / height);\n          height = maxHeight;\n        }\n      }\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n\n      // Mayor compresión para imágenes compartidas\n      const compressedImage = canvas.toDataURL('image/jpeg', quality);\n      resolve(compressedImage);\n    };\n    img.src = base64Image;\n  });\n}\n\n/**\r\n * Obtiene la imagen de un elemento por su ID\r\n * @param {string} itemId - El ID del elemento\r\n * @returns {Promise<string|null>} - Promesa con la imagen en base64 o null\r\n */\nasync function getMenuImage(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\n    const store = transaction.objectStore(IMAGE_STORE);\n    const request = store.get(itemId);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.data);\n        } else {\n          resolve(null);\n        }\n      };\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener imagen:', error);\n    return null;\n  }\n}","map":{"version":3,"names":["DB_NAME","DB_VERSION","SHARED_MENU_STORE","openDatabase","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","errorCode","onsuccess","db","result","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","saveMenu","menuData","menuId","generateId","processedMenuData","all","map","item","processedItem","image","length","compressedImage","compressImage","error","console","warn","menuObject","id","items","createdAt","Date","toISOString","transaction","store","objectStore","put","e","simplifiedMenuData","hasImage","localStorage","setItem","JSON","stringify","localStorageError","Error","getMenu","log","get","processedItems","getMenuImage","name","localData","getItem","parsed","parse","cleanOldMenus","now","allMenus","getAll","menusToDelete","filter","menu","createdDate","diff","getTime","days","Math","ceil","delete","i","key","startsWith","removeItem","random","toString","substring","base64Image","maxWidth","maxHeight","quality","img","Image","onload","canvas","document","createElement","width","height","round","ctx","getContext","drawImage","toDataURL","src","itemId","IMAGE_STORE","data"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/menuService.js"],"sourcesContent":["const DB_NAME = 'websapDatabase';\r\nconst DB_VERSION = 1;\r\nconst SHARED_MENU_STORE = 'sharedMenus';\r\n\r\n// Abrir la conexión a la base de datos\r\nfunction openDatabase() {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      reject('Error al abrir la base de datos: ' + event.target.errorCode);\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      resolve(db);\r\n    };\r\n    \r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      // Crear almacén para menús compartidos si no existe\r\n      if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\r\n        db.createObjectStore(SHARED_MENU_STORE, { keyPath: 'id' });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Guarda un menú en IndexedDB y devuelve un ID único\r\n * @param {Array} menuData - Los datos del menú a guardar\r\n * @returns {Promise<string>} - Promesa con el ID del menú guardado\r\n */\r\nexport async function saveMenu(menuData) {\r\n  try {\r\n    // Generar un ID único para el menú\r\n    const menuId = generateId();\r\n    \r\n    // Procesar las imágenes para reducir su tamaño\r\n    const processedMenuData = await Promise.all(menuData.map(async (item) => {\r\n      const processedItem = { ...item };\r\n      \r\n      // Si el item tiene una imagen, la procesamos\r\n      if (item.image && typeof item.image === 'string' && item.image.length > 0) {\r\n        try {\r\n          // Comprimir la imagen usando la función de compressImage de storageService\r\n          // Si no está disponible, podemos implementar una versión más simple aquí\r\n          const compressedImage = await compressImage(item.image);\r\n          processedItem.image = compressedImage;\r\n        } catch (error) {\r\n          console.warn('Error al comprimir la imagen del menú:', error);\r\n        }\r\n      }\r\n      \r\n      return processedItem;\r\n    }));\r\n    \r\n    // Preparar el objeto a guardar\r\n    const menuObject = {\r\n      id: menuId,\r\n      items: processedMenuData,\r\n      createdAt: new Date().toISOString()\r\n    };\r\n    \r\n    // Guardar en IndexedDB\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\r\n    const store = transaction.objectStore(SHARED_MENU_STORE);\r\n    \r\n    await new Promise((resolve, reject) => {\r\n      const request = store.put(menuObject);\r\n      request.onsuccess = () => resolve();\r\n      request.onerror = (e) => reject(e.target.error);\r\n    });\r\n    \r\n    return menuId;\r\n  } catch (error) {\r\n    console.error('Error al guardar el menú en IndexedDB:', error);\r\n    \r\n    // Fallback al localStorage con un objeto simplificado (sin imágenes)\r\n    try {\r\n      const menuId = generateId();\r\n      const simplifiedMenuData = menuData.map(item => ({\r\n        ...item,\r\n        image: null, // Eliminamos la imagen para reducir el tamaño\r\n        hasImage: item.image ? true : false // Indicamos que tenía imagen\r\n      }));\r\n      \r\n      localStorage.setItem(`menu_${menuId}`, JSON.stringify({\r\n        items: simplifiedMenuData,\r\n        createdAt: new Date().toISOString()\r\n      }));\r\n      \r\n      return menuId;\r\n    } catch (localStorageError) {\r\n      console.error('Error al guardar el menú en localStorage:', localStorageError);\r\n      throw new Error('No se pudo guardar el menú');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene un menú guardado por su ID\r\n * @param {string} menuId - El ID del menú a recuperar\r\n * @returns {Promise<Array|null>} - Promesa con los datos del menú o null si no existe\r\n */\r\nexport async function getMenu(menuId) {\r\n  try {\r\n    console.log(`Intentando recuperar menú con ID: ${menuId} de IndexedDB`);\r\n    // Intentar recuperar de IndexedDB primero\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readonly');\r\n    const store = transaction.objectStore(SHARED_MENU_STORE);\r\n    \r\n    const result = await new Promise((resolve, reject) => {\r\n      const request = store.get(menuId);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = (e) => reject(e.target.error);\r\n    });\r\n    \r\n    if (result) {\r\n      console.log(`Menú encontrado en IndexedDB:`, result);\r\n      // Procesar las imágenes si el menú tiene la propiedad hasImage pero no tiene imagen\r\n      const processedItems = await Promise.all(result.items.map(async (item) => {\r\n        // Si el elemento indica que tiene imagen pero la imagen es null\r\n        if (item.hasImage && !item.image) {\r\n          try {\r\n            // Intentar recuperar la imagen desde IMAGE_STORE si hay ID\r\n            if (item.id) {\r\n              const image = await getMenuImage(item.id);\r\n              if (image) {\r\n                return { ...item, image };\r\n              }\r\n            }\r\n          } catch (error) {\r\n            console.warn(`No se pudo recuperar la imagen para el elemento ${item.name}:`, error);\r\n          }\r\n        }\r\n        return item;\r\n      }));\r\n      \r\n      return processedItems;\r\n    }\r\n    \r\n    // Si no está en IndexedDB, intentar recuperar de localStorage\r\n    console.log(`Menú no encontrado en IndexedDB, buscando en localStorage`);\r\n    const localData = localStorage.getItem(`menu_${menuId}`);\r\n    if (localData) {\r\n      const parsed = JSON.parse(localData);\r\n      console.log(`Menú encontrado en localStorage:`, parsed);\r\n      return parsed.items;\r\n    }\r\n    \r\n    console.log(`Menú no encontrado en ningún almacenamiento`);\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error al obtener menú:', error);\r\n    \r\n    // Último intento: recuperar de localStorage\r\n    try {\r\n      const localData = localStorage.getItem(`menu_${menuId}`);\r\n      if (localData) {\r\n        const parsed = JSON.parse(localData);\r\n        return parsed.items;\r\n      }\r\n    } catch (e) {\r\n      console.error('Error al recuperar de localStorage:', e);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Limpia menús antiguos que ya no son necesarios\r\n * @returns {Promise<void>}\r\n */\r\nexport async function cleanOldMenus() {\r\n  try {\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\r\n    const store = transaction.objectStore(SHARED_MENU_STORE);\r\n    \r\n    const now = new Date();\r\n    const allMenus = await new Promise((resolve, reject) => {\r\n      const request = store.getAll();\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = (e) => reject(e.target.error);\r\n    });\r\n    \r\n    // Eliminar menús más antiguos de 7 días\r\n    const menusToDelete = allMenus.filter(menu => {\r\n      const createdDate = new Date(menu.createdAt);\r\n      const diff = now.getTime() - createdDate.getTime();\r\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\r\n      return days > 7;\r\n    });\r\n    \r\n    for (const menu of menusToDelete) {\r\n      store.delete(menu.id);\r\n    }\r\n    \r\n    // También limpiar localStorage\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key.startsWith('menu_')) {\r\n        try {\r\n          const menuData = JSON.parse(localStorage.getItem(key));\r\n          const createdDate = new Date(menuData.createdAt);\r\n          const diff = now.getTime() - createdDate.getTime();\r\n          const days = Math.ceil(diff / (1000 * 3600 * 24));\r\n          if (days > 7) {\r\n            localStorage.removeItem(key);\r\n          }\r\n        } catch (e) {\r\n          // Si hay un error al procesar este elemento, lo eliminamos también\r\n          localStorage.removeItem(key);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al limpiar menús antiguos:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Genera un ID único para un menú\r\n * @returns {string} Un ID único\r\n */\r\nfunction generateId() {\r\n  return Math.random().toString(36).substring(2, 10) + \r\n         Math.random().toString(36).substring(2, 10);\r\n}\r\n\r\n/**\r\n * Comprime una imagen base64\r\n * @param {string} base64Image - La imagen en formato base64\r\n * @returns {Promise<string>} - Promesa con la imagen comprimida\r\n */\r\nfunction compressImage(base64Image, maxWidth = 600, maxHeight = 400, quality = 0.6) {\r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n      const canvas = document.createElement('canvas');\r\n      \r\n      let width = img.width;\r\n      let height = img.height;\r\n      \r\n      if (width > height) {\r\n        if (width > maxWidth) {\r\n          height = Math.round((height * maxWidth) / width);\r\n          width = maxWidth;\r\n        }\r\n      } else {\r\n        if (height > maxHeight) {\r\n          width = Math.round((width * maxHeight) / height);\r\n          height = maxHeight;\r\n        }\r\n      }\r\n      \r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      \r\n      const ctx = canvas.getContext('2d');\r\n      ctx.drawImage(img, 0, 0, width, height);\r\n      \r\n      // Mayor compresión para imágenes compartidas\r\n      const compressedImage = canvas.toDataURL('image/jpeg', quality);\r\n      resolve(compressedImage);\r\n    };\r\n    img.src = base64Image;\r\n  });\r\n}\r\n\r\n/**\r\n * Obtiene la imagen de un elemento por su ID\r\n * @param {string} itemId - El ID del elemento\r\n * @returns {Promise<string|null>} - Promesa con la imagen en base64 o null\r\n */\r\nasync function getMenuImage(itemId) {\r\n  try {\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\r\n    const store = transaction.objectStore(IMAGE_STORE);\r\n    \r\n    const request = store.get(itemId);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => {\r\n        if (request.result) {\r\n          resolve(request.result.data);\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      };\r\n      request.onerror = (event) => reject(event.target.error);\r\n    });\r\n  } catch (error) {\r\n    console.error('Error al obtener imagen:', error);\r\n    return null;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}