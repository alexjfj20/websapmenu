{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nconst DB_NAME = 'websapDatabase';\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\nconst SHARED_MENU_STORE = 'sharedMenus';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = event => {\n        console.error('Error al abrir la base de datos:', event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        // Verificar que el almacén existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\n          return;\n        }\n        resolve(db);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Crear almacén para menús compartidos si no existe\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\n          console.log('Creando almacén:', SHARED_MENU_STORE);\n          db.createObjectStore(SHARED_MENU_STORE, {\n            keyPath: 'id'\n          });\n        }\n      };\n    } catch (error) {\n      console.error('Error crítico al abrir base de datos:', error);\n      reject(error);\n    }\n  });\n}\n\n/**\r\n * Guarda un menú en IndexedDB y devuelve un ID único\r\n * @param {Array} menuData - Los datos del menú a guardar\r\n * @returns {Promise<string>} - Promesa con el ID del menú guardado\r\n */\nexport async function saveMenu(menuData) {\n  try {\n    // Generar un ID único para el menú\n    const menuId = generateId();\n    console.log(`Guardando menú \"${menuId}\" con ${menuData.length} elementos...`);\n\n    // IMPORTANTE: Preprocesar y comprimir las imágenes para hacerlas más pequeñas\n    const processedItems = await Promise.all(menuData.map(async item => {\n      // Crear una copia del item\n      const processedItem = {\n        ...item\n      };\n\n      // Si tiene imagen, comprimirla a un tamaño más pequeño\n      if (processedItem.image && typeof processedItem.image === 'string') {\n        try {\n          // Usar una calidad más baja y dimensiones más pequeñas para compartir\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\n        } catch (err) {\n          console.warn('Error al comprimir imagen:', err);\n          // Si falla la compresión, eliminar la imagen completamente\n          processedItem.image = null;\n        }\n      }\n      return processedItem;\n    }));\n    console.log(`Procesadas ${processedItems.length} imágenes para compartir`);\n    const menuObject = {\n      id: menuId,\n      items: processedItems,\n      createdAt: new Date().toISOString()\n    };\n\n    // Verificar tamaño del objeto antes de guardarlo\n    try {\n      const jsonString = JSON.stringify(menuObject);\n      const objectSizeInMB = jsonString.length / (1024 * 1024);\n      console.log(`Tamaño del menú a guardar: ${objectSizeInMB.toFixed(2)} MB`);\n\n      // Si el menú es demasiado grande (>50MB), lanzar error\n      if (objectSizeInMB > 50) {\n        throw new Error(`El menú es demasiado grande (${objectSizeInMB.toFixed(2)} MB). Intente reducir el tamaño de las imágenes.`);\n      }\n    } catch (jsonError) {\n      console.error('Error al serializar menú:', jsonError);\n      throw new Error('No se pudo serializar el menú. Verifique que no haya datos inválidos.');\n    }\n\n    // Guardar en IndexedDB con manejo explícito de errores\n    try {\n      const db = await openDatabase();\n      const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n      const store = transaction.objectStore(SHARED_MENU_STORE);\n      await new Promise((resolve, reject) => {\n        const request = store.put(menuObject);\n        request.onsuccess = () => {\n          console.log(`Menú guardado exitosamente con ID: ${menuId}`);\n          resolve();\n        };\n        request.onerror = e => {\n          console.error(`Error específico al guardar menú: ${e.target.error.message || e.target.error}`);\n          reject(e.target.error);\n        };\n\n        // Añadir manejo de errores a nivel de transacción\n        transaction.onabort = e => {\n          console.error('Transacción abortada:', e.target.error);\n          reject(e.target.error || new Error('Transacción abortada'));\n        };\n        transaction.onerror = e => {\n          console.error('Error en transacción:', e.target.error);\n          reject(e.target.error || new Error('Error en transacción'));\n        };\n      });\n      console.log(`Elementos con imágenes: ${processedItems.filter(item => Boolean(item.image)).length} de ${processedItems.length}`);\n      return menuId;\n    } catch (dbError) {\n      console.error('Error en operación de base de datos:', dbError);\n      throw dbError;\n    }\n  } catch (error) {\n    console.error('Error al guardar el menú en IndexedDB:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Obtiene un menú guardado por su ID\r\n * @param {string} menuId - El ID del menú a recuperar\r\n * @returns {Promise<Array|null>} - Promesa con los datos del menú o null si no existe\r\n */\nexport async function getMenu(menuId) {\n  try {\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\n\n    // Intentar recuperar de IndexedDB primero\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readonly');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get(menuId);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = e => reject(e.target.error);\n    });\n    if (result && result.items && Array.isArray(result.items)) {\n      console.log(`Menú encontrado en IndexedDB, contiene ${result.items.length} elementos`);\n\n      // Verificar y registrar el estado de las imágenes\n      const itemsWithImages = result.items.filter(item => Boolean(item.image)).length;\n      console.log(`Elementos con imágenes: ${itemsWithImages} de ${result.items.length}`);\n\n      // Devolver directamente los items del resultado\n      return result.items;\n    }\n    console.log(`Menú no encontrado en ningún almacenamiento`);\n    return null;\n  } catch (error) {\n    console.error('Error al obtener menú:', error);\n    return null;\n  }\n}\n\n/**\r\n * Limpia menús antiguos que ya no son necesarios\r\n * @returns {Promise<void>}\r\n */\nexport async function cleanOldMenus() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(SHARED_MENU_STORE);\n    const now = new Date();\n    const allMenus = await new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = e => reject(e.target.error);\n    });\n\n    // Eliminar menús más antiguos de 7 días\n    const menusToDelete = allMenus.filter(menu => {\n      const createdDate = new Date(menu.createdAt);\n      const diff = now.getTime() - createdDate.getTime();\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\n      return days > 7;\n    });\n    for (const menu of menusToDelete) {\n      store.delete(menu.id);\n    }\n  } catch (error) {\n    console.error('Error al limpiar menús antiguos:', error);\n  }\n}\n\n/**\r\n * Genera un ID único para un menú\r\n * @returns {string} Un ID único\r\n */\nfunction generateId() {\n  return Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n}\n\n/**\r\n * Comprime una imagen base64 - FUNCIÓN MEJORADA\r\n * @param {string} base64Image - La imagen en formato base64\r\n * @returns {Promise<string>} - Promesa con la imagen comprimida\r\n */\nfunction compressImage(base64Image, maxWidth = 600, maxHeight = 400, quality = 0.6) {\n  return new Promise((resolve, reject) => {\n    try {\n      const img = new Image();\n\n      // Manejar errores de carga de imagen\n      img.onerror = () => {\n        console.warn('Error al cargar la imagen para compresión');\n        reject(new Error('Error al cargar la imagen'));\n      };\n      img.onload = () => {\n        try {\n          const canvas = document.createElement('canvas');\n          let width = img.width;\n          let height = img.height;\n\n          // Calcular nuevas dimensiones manteniendo proporción\n          if (width > height) {\n            if (width > maxWidth) {\n              height = Math.round(height * maxWidth / width);\n              width = maxWidth;\n            }\n          } else {\n            if (height > maxHeight) {\n              width = Math.round(width * maxHeight / height);\n              height = maxHeight;\n            }\n          }\n          canvas.width = width;\n          canvas.height = height;\n          const ctx = canvas.getContext('2d');\n          ctx.drawImage(img, 0, 0, width, height);\n\n          // Mayor compresión para imágenes compartidas\n          const compressedImage = canvas.toDataURL('image/jpeg', quality);\n          resolve(compressedImage);\n        } catch (canvasError) {\n          console.error('Error al procesar imagen en canvas:', canvasError);\n          reject(canvasError);\n        }\n      };\n\n      // Establecer un timeout para evitar bloqueos\n      setTimeout(() => {\n        reject(new Error('Timeout al procesar la imagen'));\n      }, 5000);\n      img.src = base64Image;\n    } catch (error) {\n      console.error('Error general al comprimir imagen:', error);\n      reject(error);\n    }\n  });\n}\n\n/**\r\n * Obtiene la imagen de un elemento por su ID\r\n * @param {string} itemId - El ID del elemento\r\n * @returns {Promise<string|null>} - Promesa con la imagen en base64 o null\r\n */\nasync function getMenuImage(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\n    const store = transaction.objectStore(IMAGE_STORE);\n    const request = store.get(itemId);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.data);\n        } else {\n          resolve(null);\n        }\n      };\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener imagen:', error);\n    return null;\n  }\n}","map":{"version":3,"names":["DB_NAME","DB_VERSION","SHARED_MENU_STORE","openDatabase","Promise","resolve","reject","request","indexedDB","open","onerror","event","console","error","target","errorCode","onsuccess","db","result","objectStoreNames","contains","Error","onupgradeneeded","log","createObjectStore","keyPath","saveMenu","menuData","menuId","generateId","length","processedItems","all","map","item","processedItem","image","compressImage","err","warn","menuObject","id","items","createdAt","Date","toISOString","jsonString","JSON","stringify","objectSizeInMB","toFixed","jsonError","transaction","store","objectStore","put","e","message","onabort","filter","Boolean","dbError","getMenu","get","Array","isArray","itemsWithImages","cleanOldMenus","now","allMenus","getAll","menusToDelete","menu","createdDate","diff","getTime","days","Math","ceil","delete","random","toString","substring","base64Image","maxWidth","maxHeight","quality","img","Image","onload","canvas","document","createElement","width","height","round","ctx","getContext","drawImage","compressedImage","toDataURL","canvasError","setTimeout","src","getMenuImage","itemId","IMAGE_STORE","data"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/menuService.js"],"sourcesContent":["const DB_NAME = 'websapDatabase';\r\nconst DB_VERSION = 3; // Debe coincidir con el resto de servicios\r\nconst SHARED_MENU_STORE = 'sharedMenus';\r\n\r\n// Abrir la conexión a la base de datos\r\nfunction openDatabase() {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al abrir la base de datos:', event.target.error);\r\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\r\n      };\r\n      \r\n      request.onsuccess = (event) => {\r\n        const db = event.target.result;\r\n        // Verificar que el almacén existe\r\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\r\n          console.error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`);\r\n          reject(new Error(`El almacén ${SHARED_MENU_STORE} no existe en la base de datos`));\r\n          return;\r\n        }\r\n        resolve(db);\r\n      };\r\n      \r\n      request.onupgradeneeded = (event) => {\r\n        const db = event.target.result;\r\n        \r\n        // Crear almacén para menús compartidos si no existe\r\n        if (!db.objectStoreNames.contains(SHARED_MENU_STORE)) {\r\n          console.log('Creando almacén:', SHARED_MENU_STORE);\r\n          db.createObjectStore(SHARED_MENU_STORE, { keyPath: 'id' });\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('Error crítico al abrir base de datos:', error);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Guarda un menú en IndexedDB y devuelve un ID único\r\n * @param {Array} menuData - Los datos del menú a guardar\r\n * @returns {Promise<string>} - Promesa con el ID del menú guardado\r\n */\r\nexport async function saveMenu(menuData) {\r\n  try {\r\n    // Generar un ID único para el menú\r\n    const menuId = generateId();\r\n    \r\n    console.log(`Guardando menú \"${menuId}\" con ${menuData.length} elementos...`);\r\n    \r\n    // IMPORTANTE: Preprocesar y comprimir las imágenes para hacerlas más pequeñas\r\n    const processedItems = await Promise.all(menuData.map(async (item) => {\r\n      // Crear una copia del item\r\n      const processedItem = { ...item };\r\n      \r\n      // Si tiene imagen, comprimirla a un tamaño más pequeño\r\n      if (processedItem.image && typeof processedItem.image === 'string') {\r\n        try {\r\n          // Usar una calidad más baja y dimensiones más pequeñas para compartir\r\n          processedItem.image = await compressImage(processedItem.image, 400, 300, 0.5);\r\n        } catch (err) {\r\n          console.warn('Error al comprimir imagen:', err);\r\n          // Si falla la compresión, eliminar la imagen completamente\r\n          processedItem.image = null;\r\n        }\r\n      }\r\n      \r\n      return processedItem;\r\n    }));\r\n    \r\n    console.log(`Procesadas ${processedItems.length} imágenes para compartir`);\r\n    \r\n    const menuObject = {\r\n      id: menuId,\r\n      items: processedItems,\r\n      createdAt: new Date().toISOString()\r\n    };\r\n    \r\n    // Verificar tamaño del objeto antes de guardarlo\r\n    try {\r\n      const jsonString = JSON.stringify(menuObject);\r\n      const objectSizeInMB = jsonString.length / (1024 * 1024);\r\n      console.log(`Tamaño del menú a guardar: ${objectSizeInMB.toFixed(2)} MB`);\r\n      \r\n      // Si el menú es demasiado grande (>50MB), lanzar error\r\n      if (objectSizeInMB > 50) {\r\n        throw new Error(`El menú es demasiado grande (${objectSizeInMB.toFixed(2)} MB). Intente reducir el tamaño de las imágenes.`);\r\n      }\r\n    } catch (jsonError) {\r\n      console.error('Error al serializar menú:', jsonError);\r\n      throw new Error('No se pudo serializar el menú. Verifique que no haya datos inválidos.');\r\n    }\r\n    \r\n    // Guardar en IndexedDB con manejo explícito de errores\r\n    try {\r\n      const db = await openDatabase();\r\n      const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SHARED_MENU_STORE);\r\n      \r\n      await new Promise((resolve, reject) => {\r\n        const request = store.put(menuObject);\r\n        \r\n        request.onsuccess = () => {\r\n          console.log(`Menú guardado exitosamente con ID: ${menuId}`);\r\n          resolve();\r\n        };\r\n        \r\n        request.onerror = (e) => {\r\n          console.error(`Error específico al guardar menú: ${e.target.error.message || e.target.error}`);\r\n          reject(e.target.error);\r\n        };\r\n        \r\n        // Añadir manejo de errores a nivel de transacción\r\n        transaction.onabort = (e) => {\r\n          console.error('Transacción abortada:', e.target.error);\r\n          reject(e.target.error || new Error('Transacción abortada'));\r\n        };\r\n        \r\n        transaction.onerror = (e) => {\r\n          console.error('Error en transacción:', e.target.error);\r\n          reject(e.target.error || new Error('Error en transacción'));\r\n        };\r\n      });\r\n      \r\n      console.log(`Elementos con imágenes: ${processedItems.filter(item => Boolean(item.image)).length} de ${processedItems.length}`);\r\n      \r\n      return menuId;\r\n    } catch (dbError) {\r\n      console.error('Error en operación de base de datos:', dbError);\r\n      throw dbError;\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al guardar el menú en IndexedDB:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene un menú guardado por su ID\r\n * @param {string} menuId - El ID del menú a recuperar\r\n * @returns {Promise<Array|null>} - Promesa con los datos del menú o null si no existe\r\n */\r\nexport async function getMenu(menuId) {\r\n  try {\r\n    console.log(`Intentando recuperar menú con ID: ${menuId}`);\r\n    \r\n    // Intentar recuperar de IndexedDB primero\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readonly');\r\n    const store = transaction.objectStore(SHARED_MENU_STORE);\r\n    \r\n    const result = await new Promise((resolve, reject) => {\r\n      const request = store.get(menuId);\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = (e) => reject(e.target.error);\r\n    });\r\n    \r\n    if (result && result.items && Array.isArray(result.items)) {\r\n      console.log(`Menú encontrado en IndexedDB, contiene ${result.items.length} elementos`);\r\n      \r\n      // Verificar y registrar el estado de las imágenes\r\n      const itemsWithImages = result.items.filter(item => Boolean(item.image)).length;\r\n      console.log(`Elementos con imágenes: ${itemsWithImages} de ${result.items.length}`);\r\n      \r\n      // Devolver directamente los items del resultado\r\n      return result.items;\r\n    }\r\n    \r\n    console.log(`Menú no encontrado en ningún almacenamiento`);\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error al obtener menú:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Limpia menús antiguos que ya no son necesarios\r\n * @returns {Promise<void>}\r\n */\r\nexport async function cleanOldMenus() {\r\n  try {\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([SHARED_MENU_STORE], 'readwrite');\r\n    const store = transaction.objectStore(SHARED_MENU_STORE);\r\n    \r\n    const now = new Date();\r\n    const allMenus = await new Promise((resolve, reject) => {\r\n      const request = store.getAll();\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = (e) => reject(e.target.error);\r\n    });\r\n    \r\n    // Eliminar menús más antiguos de 7 días\r\n    const menusToDelete = allMenus.filter(menu => {\r\n      const createdDate = new Date(menu.createdAt);\r\n      const diff = now.getTime() - createdDate.getTime();\r\n      const days = Math.ceil(diff / (1000 * 3600 * 24));\r\n      return days > 7;\r\n    });\r\n    \r\n    for (const menu of menusToDelete) {\r\n      store.delete(menu.id);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error al limpiar menús antiguos:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Genera un ID único para un menú\r\n * @returns {string} Un ID único\r\n */\r\nfunction generateId() {\r\n  return Math.random().toString(36).substring(2, 10) + \r\n         Math.random().toString(36).substring(2, 10);\r\n}\r\n\r\n/**\r\n * Comprime una imagen base64 - FUNCIÓN MEJORADA\r\n * @param {string} base64Image - La imagen en formato base64\r\n * @returns {Promise<string>} - Promesa con la imagen comprimida\r\n */\r\nfunction compressImage(base64Image, maxWidth = 600, maxHeight = 400, quality = 0.6) {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const img = new Image();\r\n      \r\n      // Manejar errores de carga de imagen\r\n      img.onerror = () => {\r\n        console.warn('Error al cargar la imagen para compresión');\r\n        reject(new Error('Error al cargar la imagen'));\r\n      };\r\n      \r\n      img.onload = () => {\r\n        try {\r\n          const canvas = document.createElement('canvas');\r\n          \r\n          let width = img.width;\r\n          let height = img.height;\r\n          \r\n          // Calcular nuevas dimensiones manteniendo proporción\r\n          if (width > height) {\r\n            if (width > maxWidth) {\r\n              height = Math.round((height * maxWidth) / width);\r\n              width = maxWidth;\r\n            }\r\n          } else {\r\n            if (height > maxHeight) {\r\n              width = Math.round((width * maxHeight) / height);\r\n              height = maxHeight;\r\n            }\r\n          }\r\n          \r\n          canvas.width = width;\r\n          canvas.height = height;\r\n          \r\n          const ctx = canvas.getContext('2d');\r\n          ctx.drawImage(img, 0, 0, width, height);\r\n          \r\n          // Mayor compresión para imágenes compartidas\r\n          const compressedImage = canvas.toDataURL('image/jpeg', quality);\r\n          resolve(compressedImage);\r\n        } catch (canvasError) {\r\n          console.error('Error al procesar imagen en canvas:', canvasError);\r\n          reject(canvasError);\r\n        }\r\n      };\r\n      \r\n      // Establecer un timeout para evitar bloqueos\r\n      setTimeout(() => {\r\n        reject(new Error('Timeout al procesar la imagen'));\r\n      }, 5000);\r\n      \r\n      img.src = base64Image;\r\n    } catch (error) {\r\n      console.error('Error general al comprimir imagen:', error);\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Obtiene la imagen de un elemento por su ID\r\n * @param {string} itemId - El ID del elemento\r\n * @returns {Promise<string|null>} - Promesa con la imagen en base64 o null\r\n */\r\nasync function getMenuImage(itemId) {\r\n  try {\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\r\n    const store = transaction.objectStore(IMAGE_STORE);\r\n    \r\n    const request = store.get(itemId);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => {\r\n        if (request.result) {\r\n          resolve(request.result.data);\r\n        } else {\r\n          resolve(null);\r\n        }\r\n      };\r\n      request.onerror = (event) => reject(event.target.error);\r\n    });\r\n  } catch (error) {\r\n    console.error('Error al obtener imagen:', error);\r\n    return null;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}