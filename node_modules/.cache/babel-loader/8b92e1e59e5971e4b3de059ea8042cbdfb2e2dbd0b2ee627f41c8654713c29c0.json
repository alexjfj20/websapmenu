{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { reactive } from 'vue';\n\n// Estado reactivo compartido para el WebSocket\nexport const webSocketState = reactive({\n  connection: null,\n  connected: false,\n  error: null,\n  reconnecting: false,\n  reconnectAttempts: 0,\n  maxReconnectAttempts: 5,\n  reconnectInterval: 2000,\n  listeners: new Map(),\n  messages: []\n});\nlet reconnectTimeout = null;\n\n/**\r\n * Inicializa la conexión WebSocket\r\n * @param {string} url - URL del servidor WebSocket\r\n * @param {Object} options - Opciones de configuración\r\n */\nexport function initializeWebSocket(url, options = {}) {\n  // Cerrar conexión existente si la hay\n  if (webSocketState.connection) {\n    closeWebSocket();\n  }\n\n  // Actualizar opciones de configuración\n  if (options.reconnectInterval) {\n    webSocketState.reconnectInterval = options.reconnectInterval;\n  }\n  if (options.reconnectAttempts) {\n    webSocketState.maxReconnectAttempts = options.reconnectAttempts;\n  }\n  try {\n    // Crear nueva conexión WebSocket\n    webSocketState.connection = new WebSocket(url);\n\n    // Configurar eventos\n    webSocketState.connection.onopen = handleOpen;\n    webSocketState.connection.onclose = handleClose;\n    webSocketState.connection.onerror = handleError;\n    webSocketState.connection.onmessage = handleMessage;\n    console.log('WebSocket: Iniciando conexión a', url);\n  } catch (error) {\n    console.error('WebSocket: Error al inicializar', error);\n    webSocketState.error = `Error al conectar: ${error.message}`;\n  }\n}\n\n/**\r\n * Cierra la conexión WebSocket\r\n */\nexport function closeWebSocket() {\n  if (webSocketState.connection && webSocketState.connection.readyState !== WebSocket.CLOSED) {\n    webSocketState.connection.close();\n    console.log('WebSocket: Conexión cerrada manualmente');\n  }\n\n  // Detener cualquier intento de reconexión\n  if (reconnectTimeout) {\n    clearTimeout(reconnectTimeout);\n    reconnectTimeout = null;\n  }\n\n  // Limpiar estado\n  webSocketState.connection = null;\n  webSocketState.connected = false;\n  webSocketState.reconnecting = false;\n  webSocketState.reconnectAttempts = 0;\n}\n\n/**\r\n * Detiene los intentos de reconexión\r\n */\nexport function stopReconnecting() {\n  if (reconnectTimeout) {\n    clearTimeout(reconnectTimeout);\n    reconnectTimeout = null;\n  }\n  webSocketState.reconnecting = false;\n  webSocketState.reconnectAttempts = 0;\n}\n\n/**\r\n * Intenta reconectar el WebSocket\r\n */\nexport function reconnect() {\n  if (webSocketState.reconnecting) return;\n  webSocketState.reconnecting = true;\n  webSocketState.reconnectAttempts = 0;\n  const attemptReconnect = () => {\n    if (!webSocketState.reconnecting) return;\n    if (webSocketState.reconnectAttempts >= webSocketState.maxReconnectAttempts) {\n      console.log('WebSocket: Máximo de intentos de reconexión alcanzado.');\n      webSocketState.reconnecting = false;\n      webSocketState.error = 'Máximo de intentos de reconexión alcanzado';\n      return;\n    }\n    webSocketState.reconnectAttempts++;\n    console.log(`WebSocket: Intento de reconexión ${webSocketState.reconnectAttempts} de ${webSocketState.maxReconnectAttempts}`);\n    try {\n      const url = webSocketState.connection ? webSocketState.connection.url : null;\n      if (!url) {\n        throw new Error('No hay URL disponible para reconexión');\n      }\n      initializeWebSocket(url);\n    } catch (error) {\n      console.error('WebSocket: Error al reconectar:', error);\n      reconnectTimeout = setTimeout(attemptReconnect, webSocketState.reconnectInterval);\n    }\n  };\n\n  // Iniciar el primer intento de reconexión\n  attemptReconnect();\n}\n\n/**\r\n * Envía un mensaje a través del WebSocket\r\n * @param {Object|string} data - Datos a enviar\r\n */\nexport function sendMessage(data) {\n  if (!webSocketState.connected) {\n    console.error('WebSocket: No conectado. No se puede enviar mensaje.');\n    return false;\n  }\n  try {\n    const message = typeof data === 'string' ? data : JSON.stringify(data);\n    webSocketState.connection.send(message);\n    return true;\n  } catch (error) {\n    console.error('WebSocket: Error al enviar mensaje', error);\n    return false;\n  }\n}\n\n/**\r\n * Registra un oyente para un tipo específico de mensaje\r\n * @param {string} messageType - Tipo de mensaje a escuchar\r\n * @param {Function} callback - Función de callback\r\n * @returns {Function} Función para eliminar el oyente\r\n */\nexport function addEventListener(messageType, callback) {\n  if (!webSocketState.listeners.has(messageType)) {\n    webSocketState.listeners.set(messageType, new Set());\n  }\n  webSocketState.listeners.get(messageType).add(callback);\n\n  // Retornar función para eliminar el oyente\n  return () => {\n    if (webSocketState.listeners.has(messageType)) {\n      webSocketState.listeners.get(messageType).delete(callback);\n    }\n  };\n}\n\n// Manejadores internos para eventos WebSocket\nfunction handleOpen(event) {\n  console.log('WebSocket: Conexión establecida');\n  webSocketState.connected = true;\n  webSocketState.error = null;\n  webSocketState.reconnecting = false;\n  webSocketState.reconnectAttempts = 0;\n\n  // Notificar oyentes\n  if (webSocketState.listeners.has('connection')) {\n    for (const callback of webSocketState.listeners.get('connection')) {\n      callback({\n        type: 'connection',\n        status: 'connected'\n      });\n    }\n  }\n}\nfunction handleClose(event) {\n  console.log('WebSocket: Conexión cerrada', event);\n  webSocketState.connected = false;\n  if (!event.wasClean && !webSocketState.reconnecting) {\n    webSocketState.error = 'Conexión cerrada inesperadamente';\n    reconnect();\n  }\n\n  // Notificar oyentes\n  if (webSocketState.listeners.has('connection')) {\n    for (const callback of webSocketState.listeners.get('connection')) {\n      callback({\n        type: 'connection',\n        status: 'disconnected'\n      });\n    }\n  }\n}\nfunction handleError(event) {\n  console.error('WebSocket: Error en la conexión', event);\n  webSocketState.error = 'Error en la conexión';\n\n  // Notificar oyentes\n  if (webSocketState.listeners.has('error')) {\n    for (const callback of webSocketState.listeners.get('error')) {\n      callback({\n        type: 'error',\n        event\n      });\n    }\n  }\n}\nfunction handleMessage(event) {\n  try {\n    // Intentar parsear el mensaje como JSON\n    const data = JSON.parse(event.data);\n    webSocketState.messages.push(data);\n\n    // Si el mensaje tiene un tipo, notificar a los oyentes específicos\n    if (data.type && webSocketState.listeners.has(data.type)) {\n      for (const callback of webSocketState.listeners.get(data.type)) {\n        callback(data);\n      }\n    }\n\n    // Notificar a oyentes generales de mensajes\n    if (webSocketState.listeners.has('message')) {\n      for (const callback of webSocketState.listeners.get('message')) {\n        callback(data);\n      }\n    }\n  } catch (error) {\n    // Si no es JSON, tratarlo como texto plano\n    console.log('WebSocket: Mensaje recibido (texto plano):', event.data);\n    if (webSocketState.listeners.has('raw')) {\n      for (const callback of webSocketState.listeners.get('raw')) {\n        callback(event.data);\n      }\n    }\n  }\n}\nexport default {\n  webSocketState,\n  initializeWebSocket,\n  closeWebSocket,\n  reconnect,\n  stopReconnecting,\n  sendMessage,\n  addEventListener\n};","map":{"version":3,"names":["reactive","webSocketState","connection","connected","error","reconnecting","reconnectAttempts","maxReconnectAttempts","reconnectInterval","listeners","Map","messages","reconnectTimeout","initializeWebSocket","url","options","closeWebSocket","WebSocket","onopen","handleOpen","onclose","handleClose","onerror","handleError","onmessage","handleMessage","console","log","message","readyState","CLOSED","close","clearTimeout","stopReconnecting","reconnect","attemptReconnect","Error","setTimeout","sendMessage","data","JSON","stringify","send","addEventListener","messageType","callback","has","set","Set","get","add","delete","event","type","status","wasClean","parse","push"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/webSocketService.js"],"sourcesContent":["import { reactive } from 'vue';\r\n\r\n// Estado reactivo compartido para el WebSocket\r\nexport const webSocketState = reactive({\r\n  connection: null,\r\n  connected: false,\r\n  error: null,\r\n  reconnecting: false,\r\n  reconnectAttempts: 0,\r\n  maxReconnectAttempts: 5,\r\n  reconnectInterval: 2000,\r\n  listeners: new Map(),\r\n  messages: []\r\n});\r\n\r\nlet reconnectTimeout = null;\r\n\r\n/**\r\n * Inicializa la conexión WebSocket\r\n * @param {string} url - URL del servidor WebSocket\r\n * @param {Object} options - Opciones de configuración\r\n */\r\nexport function initializeWebSocket(url, options = {}) {\r\n  // Cerrar conexión existente si la hay\r\n  if (webSocketState.connection) {\r\n    closeWebSocket();\r\n  }\r\n  \r\n  // Actualizar opciones de configuración\r\n  if (options.reconnectInterval) {\r\n    webSocketState.reconnectInterval = options.reconnectInterval;\r\n  }\r\n  \r\n  if (options.reconnectAttempts) {\r\n    webSocketState.maxReconnectAttempts = options.reconnectAttempts;\r\n  }\r\n  \r\n  try {\r\n    // Crear nueva conexión WebSocket\r\n    webSocketState.connection = new WebSocket(url);\r\n    \r\n    // Configurar eventos\r\n    webSocketState.connection.onopen = handleOpen;\r\n    webSocketState.connection.onclose = handleClose;\r\n    webSocketState.connection.onerror = handleError;\r\n    webSocketState.connection.onmessage = handleMessage;\r\n    \r\n    console.log('WebSocket: Iniciando conexión a', url);\r\n  } catch (error) {\r\n    console.error('WebSocket: Error al inicializar', error);\r\n    webSocketState.error = `Error al conectar: ${error.message}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Cierra la conexión WebSocket\r\n */\r\nexport function closeWebSocket() {\r\n  if (webSocketState.connection && webSocketState.connection.readyState !== WebSocket.CLOSED) {\r\n    webSocketState.connection.close();\r\n    console.log('WebSocket: Conexión cerrada manualmente');\r\n  }\r\n  \r\n  // Detener cualquier intento de reconexión\r\n  if (reconnectTimeout) {\r\n    clearTimeout(reconnectTimeout);\r\n    reconnectTimeout = null;\r\n  }\r\n  \r\n  // Limpiar estado\r\n  webSocketState.connection = null;\r\n  webSocketState.connected = false;\r\n  webSocketState.reconnecting = false;\r\n  webSocketState.reconnectAttempts = 0;\r\n}\r\n\r\n/**\r\n * Detiene los intentos de reconexión\r\n */\r\nexport function stopReconnecting() {\r\n  if (reconnectTimeout) {\r\n    clearTimeout(reconnectTimeout);\r\n    reconnectTimeout = null;\r\n  }\r\n  \r\n  webSocketState.reconnecting = false;\r\n  webSocketState.reconnectAttempts = 0;\r\n}\r\n\r\n/**\r\n * Intenta reconectar el WebSocket\r\n */\r\nexport function reconnect() {\r\n  if (webSocketState.reconnecting) return;\r\n  \r\n  webSocketState.reconnecting = true;\r\n  webSocketState.reconnectAttempts = 0;\r\n  \r\n  const attemptReconnect = () => {\r\n    if (!webSocketState.reconnecting) return;\r\n    \r\n    if (webSocketState.reconnectAttempts >= webSocketState.maxReconnectAttempts) {\r\n      console.log('WebSocket: Máximo de intentos de reconexión alcanzado.');\r\n      webSocketState.reconnecting = false;\r\n      webSocketState.error = 'Máximo de intentos de reconexión alcanzado';\r\n      return;\r\n    }\r\n    \r\n    webSocketState.reconnectAttempts++;\r\n    console.log(`WebSocket: Intento de reconexión ${webSocketState.reconnectAttempts} de ${webSocketState.maxReconnectAttempts}`);\r\n    \r\n    try {\r\n      const url = webSocketState.connection ? webSocketState.connection.url : null;\r\n      if (!url) {\r\n        throw new Error('No hay URL disponible para reconexión');\r\n      }\r\n      \r\n      initializeWebSocket(url);\r\n      \r\n    } catch (error) {\r\n      console.error('WebSocket: Error al reconectar:', error);\r\n      reconnectTimeout = setTimeout(attemptReconnect, webSocketState.reconnectInterval);\r\n    }\r\n  };\r\n  \r\n  // Iniciar el primer intento de reconexión\r\n  attemptReconnect();\r\n}\r\n\r\n/**\r\n * Envía un mensaje a través del WebSocket\r\n * @param {Object|string} data - Datos a enviar\r\n */\r\nexport function sendMessage(data) {\r\n  if (!webSocketState.connected) {\r\n    console.error('WebSocket: No conectado. No se puede enviar mensaje.');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    const message = typeof data === 'string' ? data : JSON.stringify(data);\r\n    webSocketState.connection.send(message);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('WebSocket: Error al enviar mensaje', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Registra un oyente para un tipo específico de mensaje\r\n * @param {string} messageType - Tipo de mensaje a escuchar\r\n * @param {Function} callback - Función de callback\r\n * @returns {Function} Función para eliminar el oyente\r\n */\r\nexport function addEventListener(messageType, callback) {\r\n  if (!webSocketState.listeners.has(messageType)) {\r\n    webSocketState.listeners.set(messageType, new Set());\r\n  }\r\n  \r\n  webSocketState.listeners.get(messageType).add(callback);\r\n  \r\n  // Retornar función para eliminar el oyente\r\n  return () => {\r\n    if (webSocketState.listeners.has(messageType)) {\r\n      webSocketState.listeners.get(messageType).delete(callback);\r\n    }\r\n  };\r\n}\r\n\r\n// Manejadores internos para eventos WebSocket\r\nfunction handleOpen(event) {\r\n  console.log('WebSocket: Conexión establecida');\r\n  webSocketState.connected = true;\r\n  webSocketState.error = null;\r\n  webSocketState.reconnecting = false;\r\n  webSocketState.reconnectAttempts = 0;\r\n  \r\n  // Notificar oyentes\r\n  if (webSocketState.listeners.has('connection')) {\r\n    for (const callback of webSocketState.listeners.get('connection')) {\r\n      callback({ type: 'connection', status: 'connected' });\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleClose(event) {\r\n  console.log('WebSocket: Conexión cerrada', event);\r\n  webSocketState.connected = false;\r\n  \r\n  if (!event.wasClean && !webSocketState.reconnecting) {\r\n    webSocketState.error = 'Conexión cerrada inesperadamente';\r\n    reconnect();\r\n  }\r\n  \r\n  // Notificar oyentes\r\n  if (webSocketState.listeners.has('connection')) {\r\n    for (const callback of webSocketState.listeners.get('connection')) {\r\n      callback({ type: 'connection', status: 'disconnected' });\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleError(event) {\r\n  console.error('WebSocket: Error en la conexión', event);\r\n  webSocketState.error = 'Error en la conexión';\r\n  \r\n  // Notificar oyentes\r\n  if (webSocketState.listeners.has('error')) {\r\n    for (const callback of webSocketState.listeners.get('error')) {\r\n      callback({ type: 'error', event });\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleMessage(event) {\r\n  try {\r\n    // Intentar parsear el mensaje como JSON\r\n    const data = JSON.parse(event.data);\r\n    webSocketState.messages.push(data);\r\n    \r\n    // Si el mensaje tiene un tipo, notificar a los oyentes específicos\r\n    if (data.type && webSocketState.listeners.has(data.type)) {\r\n      for (const callback of webSocketState.listeners.get(data.type)) {\r\n        callback(data);\r\n      }\r\n    }\r\n    \r\n    // Notificar a oyentes generales de mensajes\r\n    if (webSocketState.listeners.has('message')) {\r\n      for (const callback of webSocketState.listeners.get('message')) {\r\n        callback(data);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    // Si no es JSON, tratarlo como texto plano\r\n    console.log('WebSocket: Mensaje recibido (texto plano):', event.data);\r\n    \r\n    if (webSocketState.listeners.has('raw')) {\r\n      for (const callback of webSocketState.listeners.get('raw')) {\r\n        callback(event.data);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default {\r\n  webSocketState,\r\n  initializeWebSocket,\r\n  closeWebSocket,\r\n  reconnect,\r\n  stopReconnecting,\r\n  sendMessage,\r\n  addEventListener\r\n};\r\n"],"mappings":";;;;;;;;AAAA,SAASA,QAAQ,QAAQ,KAAK;;AAE9B;AACA,OAAO,MAAMC,cAAc,GAAGD,QAAQ,CAAC;EACrCE,UAAU,EAAE,IAAI;EAChBC,SAAS,EAAE,KAAK;EAChBC,KAAK,EAAE,IAAI;EACXC,YAAY,EAAE,KAAK;EACnBC,iBAAiB,EAAE,CAAC;EACpBC,oBAAoB,EAAE,CAAC;EACvBC,iBAAiB,EAAE,IAAI;EACvBC,SAAS,EAAE,IAAIC,GAAG,CAAC,CAAC;EACpBC,QAAQ,EAAE;AACZ,CAAC,CAAC;AAEF,IAAIC,gBAAgB,GAAG,IAAI;;AAE3B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAACC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACrD;EACA,IAAId,cAAc,CAACC,UAAU,EAAE;IAC7Bc,cAAc,CAAC,CAAC;EAClB;;EAEA;EACA,IAAID,OAAO,CAACP,iBAAiB,EAAE;IAC7BP,cAAc,CAACO,iBAAiB,GAAGO,OAAO,CAACP,iBAAiB;EAC9D;EAEA,IAAIO,OAAO,CAACT,iBAAiB,EAAE;IAC7BL,cAAc,CAACM,oBAAoB,GAAGQ,OAAO,CAACT,iBAAiB;EACjE;EAEA,IAAI;IACF;IACAL,cAAc,CAACC,UAAU,GAAG,IAAIe,SAAS,CAACH,GAAG,CAAC;;IAE9C;IACAb,cAAc,CAACC,UAAU,CAACgB,MAAM,GAAGC,UAAU;IAC7ClB,cAAc,CAACC,UAAU,CAACkB,OAAO,GAAGC,WAAW;IAC/CpB,cAAc,CAACC,UAAU,CAACoB,OAAO,GAAGC,WAAW;IAC/CtB,cAAc,CAACC,UAAU,CAACsB,SAAS,GAAGC,aAAa;IAEnDC,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAEb,GAAG,CAAC;EACrD,CAAC,CAAC,OAAOV,KAAK,EAAE;IACdsB,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvDH,cAAc,CAACG,KAAK,GAAG,sBAAsBA,KAAK,CAACwB,OAAO,EAAE;EAC9D;AACF;;AAEA;AACA;AACA;AACA,OAAO,SAASZ,cAAcA,CAAA,EAAG;EAC/B,IAAIf,cAAc,CAACC,UAAU,IAAID,cAAc,CAACC,UAAU,CAAC2B,UAAU,KAAKZ,SAAS,CAACa,MAAM,EAAE;IAC1F7B,cAAc,CAACC,UAAU,CAAC6B,KAAK,CAAC,CAAC;IACjCL,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;EACxD;;EAEA;EACA,IAAIf,gBAAgB,EAAE;IACpBoB,YAAY,CAACpB,gBAAgB,CAAC;IAC9BA,gBAAgB,GAAG,IAAI;EACzB;;EAEA;EACAX,cAAc,CAACC,UAAU,GAAG,IAAI;EAChCD,cAAc,CAACE,SAAS,GAAG,KAAK;EAChCF,cAAc,CAACI,YAAY,GAAG,KAAK;EACnCJ,cAAc,CAACK,iBAAiB,GAAG,CAAC;AACtC;;AAEA;AACA;AACA;AACA,OAAO,SAAS2B,gBAAgBA,CAAA,EAAG;EACjC,IAAIrB,gBAAgB,EAAE;IACpBoB,YAAY,CAACpB,gBAAgB,CAAC;IAC9BA,gBAAgB,GAAG,IAAI;EACzB;EAEAX,cAAc,CAACI,YAAY,GAAG,KAAK;EACnCJ,cAAc,CAACK,iBAAiB,GAAG,CAAC;AACtC;;AAEA;AACA;AACA;AACA,OAAO,SAAS4B,SAASA,CAAA,EAAG;EAC1B,IAAIjC,cAAc,CAACI,YAAY,EAAE;EAEjCJ,cAAc,CAACI,YAAY,GAAG,IAAI;EAClCJ,cAAc,CAACK,iBAAiB,GAAG,CAAC;EAEpC,MAAM6B,gBAAgB,GAAGA,CAAA,KAAM;IAC7B,IAAI,CAAClC,cAAc,CAACI,YAAY,EAAE;IAElC,IAAIJ,cAAc,CAACK,iBAAiB,IAAIL,cAAc,CAACM,oBAAoB,EAAE;MAC3EmB,OAAO,CAACC,GAAG,CAAC,wDAAwD,CAAC;MACrE1B,cAAc,CAACI,YAAY,GAAG,KAAK;MACnCJ,cAAc,CAACG,KAAK,GAAG,4CAA4C;MACnE;IACF;IAEAH,cAAc,CAACK,iBAAiB,EAAE;IAClCoB,OAAO,CAACC,GAAG,CAAC,oCAAoC1B,cAAc,CAACK,iBAAiB,OAAOL,cAAc,CAACM,oBAAoB,EAAE,CAAC;IAE7H,IAAI;MACF,MAAMO,GAAG,GAAGb,cAAc,CAACC,UAAU,GAAGD,cAAc,CAACC,UAAU,CAACY,GAAG,GAAG,IAAI;MAC5E,IAAI,CAACA,GAAG,EAAE;QACR,MAAM,IAAIsB,KAAK,CAAC,uCAAuC,CAAC;MAC1D;MAEAvB,mBAAmB,CAACC,GAAG,CAAC;IAE1B,CAAC,CAAC,OAAOV,KAAK,EAAE;MACdsB,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvDQ,gBAAgB,GAAGyB,UAAU,CAACF,gBAAgB,EAAElC,cAAc,CAACO,iBAAiB,CAAC;IACnF;EACF,CAAC;;EAED;EACA2B,gBAAgB,CAAC,CAAC;AACpB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASG,WAAWA,CAACC,IAAI,EAAE;EAChC,IAAI,CAACtC,cAAc,CAACE,SAAS,EAAE;IAC7BuB,OAAO,CAACtB,KAAK,CAAC,sDAAsD,CAAC;IACrE,OAAO,KAAK;EACd;EAEA,IAAI;IACF,MAAMwB,OAAO,GAAG,OAAOW,IAAI,KAAK,QAAQ,GAAGA,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACF,IAAI,CAAC;IACtEtC,cAAc,CAACC,UAAU,CAACwC,IAAI,CAACd,OAAO,CAAC;IACvC,OAAO,IAAI;EACb,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdsB,OAAO,CAACtB,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;IAC1D,OAAO,KAAK;EACd;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuC,gBAAgBA,CAACC,WAAW,EAAEC,QAAQ,EAAE;EACtD,IAAI,CAAC5C,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAACF,WAAW,CAAC,EAAE;IAC9C3C,cAAc,CAACQ,SAAS,CAACsC,GAAG,CAACH,WAAW,EAAE,IAAII,GAAG,CAAC,CAAC,CAAC;EACtD;EAEA/C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAACL,WAAW,CAAC,CAACM,GAAG,CAACL,QAAQ,CAAC;;EAEvD;EACA,OAAO,MAAM;IACX,IAAI5C,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAACF,WAAW,CAAC,EAAE;MAC7C3C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAACL,WAAW,CAAC,CAACO,MAAM,CAACN,QAAQ,CAAC;IAC5D;EACF,CAAC;AACH;;AAEA;AACA,SAAS1B,UAAUA,CAACiC,KAAK,EAAE;EACzB1B,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;EAC9C1B,cAAc,CAACE,SAAS,GAAG,IAAI;EAC/BF,cAAc,CAACG,KAAK,GAAG,IAAI;EAC3BH,cAAc,CAACI,YAAY,GAAG,KAAK;EACnCJ,cAAc,CAACK,iBAAiB,GAAG,CAAC;;EAEpC;EACA,IAAIL,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAAC,YAAY,CAAC,EAAE;IAC9C,KAAK,MAAMD,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAAC,YAAY,CAAC,EAAE;MACjEJ,QAAQ,CAAC;QAAEQ,IAAI,EAAE,YAAY;QAAEC,MAAM,EAAE;MAAY,CAAC,CAAC;IACvD;EACF;AACF;AAEA,SAASjC,WAAWA,CAAC+B,KAAK,EAAE;EAC1B1B,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEyB,KAAK,CAAC;EACjDnD,cAAc,CAACE,SAAS,GAAG,KAAK;EAEhC,IAAI,CAACiD,KAAK,CAACG,QAAQ,IAAI,CAACtD,cAAc,CAACI,YAAY,EAAE;IACnDJ,cAAc,CAACG,KAAK,GAAG,kCAAkC;IACzD8B,SAAS,CAAC,CAAC;EACb;;EAEA;EACA,IAAIjC,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAAC,YAAY,CAAC,EAAE;IAC9C,KAAK,MAAMD,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAAC,YAAY,CAAC,EAAE;MACjEJ,QAAQ,CAAC;QAAEQ,IAAI,EAAE,YAAY;QAAEC,MAAM,EAAE;MAAe,CAAC,CAAC;IAC1D;EACF;AACF;AAEA,SAAS/B,WAAWA,CAAC6B,KAAK,EAAE;EAC1B1B,OAAO,CAACtB,KAAK,CAAC,iCAAiC,EAAEgD,KAAK,CAAC;EACvDnD,cAAc,CAACG,KAAK,GAAG,sBAAsB;;EAE7C;EACA,IAAIH,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAAC,OAAO,CAAC,EAAE;IACzC,KAAK,MAAMD,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAAC,OAAO,CAAC,EAAE;MAC5DJ,QAAQ,CAAC;QAAEQ,IAAI,EAAE,OAAO;QAAED;MAAM,CAAC,CAAC;IACpC;EACF;AACF;AAEA,SAAS3B,aAAaA,CAAC2B,KAAK,EAAE;EAC5B,IAAI;IACF;IACA,MAAMb,IAAI,GAAGC,IAAI,CAACgB,KAAK,CAACJ,KAAK,CAACb,IAAI,CAAC;IACnCtC,cAAc,CAACU,QAAQ,CAAC8C,IAAI,CAAClB,IAAI,CAAC;;IAElC;IACA,IAAIA,IAAI,CAACc,IAAI,IAAIpD,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAACP,IAAI,CAACc,IAAI,CAAC,EAAE;MACxD,KAAK,MAAMR,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAACV,IAAI,CAACc,IAAI,CAAC,EAAE;QAC9DR,QAAQ,CAACN,IAAI,CAAC;MAChB;IACF;;IAEA;IACA,IAAItC,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAAC,SAAS,CAAC,EAAE;MAC3C,KAAK,MAAMD,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAAC,SAAS,CAAC,EAAE;QAC9DJ,QAAQ,CAACN,IAAI,CAAC;MAChB;IACF;EACF,CAAC,CAAC,OAAOnC,KAAK,EAAE;IACd;IACAsB,OAAO,CAACC,GAAG,CAAC,4CAA4C,EAAEyB,KAAK,CAACb,IAAI,CAAC;IAErE,IAAItC,cAAc,CAACQ,SAAS,CAACqC,GAAG,CAAC,KAAK,CAAC,EAAE;MACvC,KAAK,MAAMD,QAAQ,IAAI5C,cAAc,CAACQ,SAAS,CAACwC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC1DJ,QAAQ,CAACO,KAAK,CAACb,IAAI,CAAC;MACtB;IACF;EACF;AACF;AAEA,eAAe;EACbtC,cAAc;EACdY,mBAAmB;EACnBG,cAAc;EACdkB,SAAS;EACTD,gBAAgB;EAChBK,WAAW;EACXK;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}