{"ast":null,"code":"// src/services/imageService.js\n\n/**\n * Servicio para el manejo y optimización de imágenes\n */\n\n/**\n * Comprime una imagen en formato base64 para reducir su tamaño\n * @param {string} base64Image - Imagen en formato base64\n * @param {number} maxWidth - Ancho máximo de la imagen comprimida\n * @param {number} quality - Calidad de la imagen (0-1)\n * @returns {Promise<string>} - Imagen comprimida en formato base64\n */\nexport const compressImage = (base64Image, maxWidth = 800, quality = 0.7) => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Verificar que la imagen sea válida\n      if (!base64Image || typeof base64Image !== 'string') {\n        console.warn('La imagen no es válida para compresión');\n        resolve(base64Image);\n        return;\n      }\n\n      // Crear una imagen para cargar el base64\n      const img = new Image();\n      img.onload = () => {\n        // Crear un canvas para la compresión\n        const canvas = document.createElement('canvas');\n        let width = img.width;\n        let height = img.height;\n\n        // Redimensionar si es necesario\n        if (width > maxWidth) {\n          height = Math.round(height * maxWidth / width);\n          width = maxWidth;\n        }\n\n        // Establecer dimensiones del canvas\n        canvas.width = width;\n        canvas.height = height;\n\n        // Dibujar la imagen en el canvas\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0, width, height);\n\n        // Convertir a base64 con la calidad especificada\n        const compressedBase64 = canvas.toDataURL('image/jpeg', quality);\n\n        // Verificar si realmente se redujo el tamaño\n        if (compressedBase64.length < base64Image.length) {\n          console.log(`Imagen comprimida: ${Math.round(compressedBase64.length / 1024)}KB (original: ${Math.round(base64Image.length / 1024)}KB)`);\n          resolve(compressedBase64);\n        } else {\n          console.log('La compresión no redujo el tamaño, manteniendo original');\n          resolve(base64Image);\n        }\n      };\n      img.onerror = () => {\n        console.warn('Error al cargar la imagen para compresión');\n        resolve(base64Image); // Devolver la original en caso de error\n      };\n\n      // Asegurarse de que la imagen tenga el formato correcto\n      if (!base64Image.startsWith('data:image')) {\n        img.src = 'data:image/jpeg;base64,' + base64Image;\n      } else {\n        img.src = base64Image;\n      }\n    } catch (error) {\n      console.error('Error en la compresión de imagen:', error);\n      resolve(base64Image); // Devolver la original en caso de error\n    }\n  });\n};\n\n/**\n * Verifica si una imagen es demasiado grande y la comprime si es necesario\n * @param {string} base64Image - Imagen en formato base64\n * @param {number} maxSizeKB - Tamaño máximo en KB\n * @returns {Promise<string>} - Imagen optimizada en formato base64\n */\nexport const optimizeImageForSync = async (base64Image, maxSizeKB = 500) => {\n  try {\n    if (!base64Image || typeof base64Image !== 'string') {\n      return base64Image;\n    }\n\n    // Calcular tamaño aproximado en KB\n    const sizeKB = Math.round(base64Image.length / 1024);\n    if (sizeKB <= maxSizeKB) {\n      // La imagen ya es lo suficientemente pequeña\n      return base64Image;\n    }\n    console.log(`Optimizando imagen de ${sizeKB}KB (máximo: ${maxSizeKB}KB)`);\n\n    // Calcular calidad basada en cuánto necesitamos comprimir\n    let quality = 0.7;\n    if (sizeKB > maxSizeKB * 3) {\n      quality = 0.5; // Más compresión para imágenes muy grandes\n    } else if (sizeKB > maxSizeKB * 2) {\n      quality = 0.6; // Compresión media\n    }\n\n    // Comprimir la imagen\n    let compressedImage = await compressImage(base64Image, 800, quality);\n\n    // Si sigue siendo demasiado grande, intentar con más compresión\n    if (compressedImage.length / 1024 > maxSizeKB) {\n      compressedImage = await compressImage(compressedImage, 600, 0.5);\n    }\n\n    // Si aún es demasiado grande, hacer un último intento\n    if (compressedImage.length / 1024 > maxSizeKB) {\n      compressedImage = await compressImage(compressedImage, 400, 0.4);\n    }\n    return compressedImage;\n  } catch (error) {\n    console.error('Error al optimizar imagen:', error);\n    return base64Image; // Devolver la original en caso de error\n  }\n};","map":{"version":3,"names":["compressImage","base64Image","maxWidth","quality","Promise","resolve","reject","console","warn","img","Image","onload","canvas","document","createElement","width","height","Math","round","ctx","getContext","drawImage","compressedBase64","toDataURL","length","log","onerror","startsWith","src","error","optimizeImageForSync","maxSizeKB","sizeKB","compressedImage"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/imageService.js"],"sourcesContent":["// src/services/imageService.js\n\n/**\n * Servicio para el manejo y optimización de imágenes\n */\n\n/**\n * Comprime una imagen en formato base64 para reducir su tamaño\n * @param {string} base64Image - Imagen en formato base64\n * @param {number} maxWidth - Ancho máximo de la imagen comprimida\n * @param {number} quality - Calidad de la imagen (0-1)\n * @returns {Promise<string>} - Imagen comprimida en formato base64\n */\nexport const compressImage = (base64Image, maxWidth = 800, quality = 0.7) => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Verificar que la imagen sea válida\n      if (!base64Image || typeof base64Image !== 'string') {\n        console.warn('La imagen no es válida para compresión');\n        resolve(base64Image);\n        return;\n      }\n\n      // Crear una imagen para cargar el base64\n      const img = new Image();\n      img.onload = () => {\n        // Crear un canvas para la compresión\n        const canvas = document.createElement('canvas');\n        let width = img.width;\n        let height = img.height;\n        \n        // Redimensionar si es necesario\n        if (width > maxWidth) {\n          height = Math.round((height * maxWidth) / width);\n          width = maxWidth;\n        }\n        \n        // Establecer dimensiones del canvas\n        canvas.width = width;\n        canvas.height = height;\n        \n        // Dibujar la imagen en el canvas\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0, width, height);\n        \n        // Convertir a base64 con la calidad especificada\n        const compressedBase64 = canvas.toDataURL('image/jpeg', quality);\n        \n        // Verificar si realmente se redujo el tamaño\n        if (compressedBase64.length < base64Image.length) {\n          console.log(`Imagen comprimida: ${Math.round(compressedBase64.length / 1024)}KB (original: ${Math.round(base64Image.length / 1024)}KB)`);\n          resolve(compressedBase64);\n        } else {\n          console.log('La compresión no redujo el tamaño, manteniendo original');\n          resolve(base64Image);\n        }\n      };\n      \n      img.onerror = () => {\n        console.warn('Error al cargar la imagen para compresión');\n        resolve(base64Image); // Devolver la original en caso de error\n      };\n      \n      // Asegurarse de que la imagen tenga el formato correcto\n      if (!base64Image.startsWith('data:image')) {\n        img.src = 'data:image/jpeg;base64,' + base64Image;\n      } else {\n        img.src = base64Image;\n      }\n    } catch (error) {\n      console.error('Error en la compresión de imagen:', error);\n      resolve(base64Image); // Devolver la original en caso de error\n    }\n  });\n};\n\n/**\n * Verifica si una imagen es demasiado grande y la comprime si es necesario\n * @param {string} base64Image - Imagen en formato base64\n * @param {number} maxSizeKB - Tamaño máximo en KB\n * @returns {Promise<string>} - Imagen optimizada en formato base64\n */\nexport const optimizeImageForSync = async (base64Image, maxSizeKB = 500) => {\n  try {\n    if (!base64Image || typeof base64Image !== 'string') {\n      return base64Image;\n    }\n    \n    // Calcular tamaño aproximado en KB\n    const sizeKB = Math.round(base64Image.length / 1024);\n    \n    if (sizeKB <= maxSizeKB) {\n      // La imagen ya es lo suficientemente pequeña\n      return base64Image;\n    }\n    \n    console.log(`Optimizando imagen de ${sizeKB}KB (máximo: ${maxSizeKB}KB)`);\n    \n    // Calcular calidad basada en cuánto necesitamos comprimir\n    let quality = 0.7;\n    if (sizeKB > maxSizeKB * 3) {\n      quality = 0.5; // Más compresión para imágenes muy grandes\n    } else if (sizeKB > maxSizeKB * 2) {\n      quality = 0.6; // Compresión media\n    }\n    \n    // Comprimir la imagen\n    let compressedImage = await compressImage(base64Image, 800, quality);\n    \n    // Si sigue siendo demasiado grande, intentar con más compresión\n    if (compressedImage.length / 1024 > maxSizeKB) {\n      compressedImage = await compressImage(compressedImage, 600, 0.5);\n    }\n    \n    // Si aún es demasiado grande, hacer un último intento\n    if (compressedImage.length / 1024 > maxSizeKB) {\n      compressedImage = await compressImage(compressedImage, 400, 0.4);\n    }\n    \n    return compressedImage;\n  } catch (error) {\n    console.error('Error al optimizar imagen:', error);\n    return base64Image; // Devolver la original en caso de error\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}