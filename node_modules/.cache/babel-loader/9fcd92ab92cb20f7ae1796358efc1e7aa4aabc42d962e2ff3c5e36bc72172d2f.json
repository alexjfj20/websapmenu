{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\n// src/services/indexedDBService.js\n\n// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 3;\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n\n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        syncQueueStore.createIndex('type', 'type', {\n          unique: false\n        });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificar almacenamiento después de completar la transacción\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = event => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const platos = event.target.result;\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\n        resolve(platos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      request.onsuccess = event => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronización\n          plato.syncStatus = status;\n\n          // Si es pending_deletion, marcar como no disponible también\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB\nconst deletePlato = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Crea un nuevo plato en la base de datos\r\n * @param {Object} plato - Datos del plato a crear\r\n * @returns {Promise<Object>} - Plato creado con su ID asignado\r\n */\nasync function createPlato(plato) {\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\n  try {\n    // Validación más estricta de datos antes de intentar abrir la BD\n    if (!plato || typeof plato !== 'object') {\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\n      throw new Error('El plato debe ser un objeto válido');\n    }\n    if (!plato.name || plato.name.trim() === '') {\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\n      throw new Error('El plato debe tener un nombre válido');\n    }\n    console.log('✅ Validación inicial del plato exitosa');\n\n    // Abrimos la BD con registro detallado\n    console.log('🔄 Abriendo base de datos...');\n    const db = await openDB();\n    console.log('✅ Base de datos abierta correctamente');\n    return new Promise((resolve, reject) => {\n      console.log('🔄 Iniciando transacción para guardar plato...');\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        console.log('✅ Transacción creada correctamente');\n        const store = transaction.objectStore(PLATOS_STORE);\n        console.log('✅ Almacén obtenido correctamente');\n\n        // Preparar el plato con todos los campos necesarios\n        const platoToCreate = {\n          ...plato,\n          createdAt: plato.createdAt || new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          syncStatus: 'pending',\n          localTimestamp: new Date().getTime()\n        };\n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\n        const request = store.add(platoToCreate);\n        request.onsuccess = async event => {\n          const id = event.target.result;\n          console.log(`✅ ÉXITO: Plato creado con ID: ${id}`);\n\n          // Crear objeto completo con el ID asignado\n          const createdPlato = {\n            ...platoToCreate,\n            id\n          };\n\n          // Agregar a la cola de sincronización\n          try {\n            console.log('🔄 Agregando plato a cola de sincronización...');\n            await addToSyncQueue({\n              type: 'create',\n              entityType: 'plato',\n              entityId: id,\n              data: createdPlato,\n              timestamp: new Date().getTime()\n            });\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\n          } catch (syncError) {\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\n            // Continuamos a pesar de error en cola\n          }\n\n          // Verificación inmediata para depuración\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\n          try {\n            const platos = await getAllPlatos();\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\n            console.log('📋 Lista de platos:', platos);\n            const found = platos.find(p => p.id === id);\n            if (found) {\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\n            } else {\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\n            }\n          } catch (listError) {\n            console.error('❌ Error al listar platos para verificación:', listError);\n          }\n\n          // Verificación posterior para asegurar persistencia\n          setTimeout(async () => {\n            try {\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\n              const verified = await verifyPlatoStorage(id);\n              if (verified) {\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\n              } else {\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\n              }\n            } catch (verifyError) {\n              console.error('❌ Error en verificación posterior:', verifyError);\n            }\n          }, 1000);\n          console.log('🏁 Finalizando creación del plato con éxito');\n          resolve(createdPlato);\n        };\n        request.onerror = event => {\n          console.error('❌ ERROR al crear plato:', event.target.error);\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\n        };\n        transaction.onerror = event => {\n          console.error('❌ ERROR en transacción:', event.target.error);\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\n        };\n        transaction.oncomplete = () => {\n          console.log('✅ Transacción completada correctamente');\n        };\n      } catch (transactionError) {\n        console.error('❌ ERROR al crear transacción:', transactionError);\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\n      }\n    });\n  } catch (error) {\n    console.error('❌ ERROR GENERAL en createPlato:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Función de depuración para verificar el contenido de la base de datos\r\n * @returns {Promise<void>}\r\n */\nasync function debugIndexedDB() {\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\n  try {\n    // Verificar la existencia de la base de datos\n    const databases = await window.indexedDB.databases();\n    console.log('📊 Bases de datos disponibles:', databases);\n\n    // Abrir la base de datos y verificar su estructura\n    const db = await openDB();\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\n\n    // Verificar contenido del almacén de platos\n    const platos = await getAllPlatos();\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\n\n    // Verificar cola de sincronización\n    const syncQueue = await getSyncQueue();\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\n    console.log('✅ DEPURACIÓN COMPLETADA');\n    return {\n      databases,\n      stores: Array.from(db.objectStoreNames),\n      platos,\n      syncQueue\n    };\n  } catch (error) {\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\r\n * Es una envoltura (wrapper) que garantiza que el plato se guarde correctamente\r\n * @param {Object} platoData - Datos del plato a guardar\r\n * @returns {Promise<Object>} El plato guardado\r\n */\nasync function guardarPlato(platoData) {\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\n  try {\n    // Validación de datos\n    if (!platoData || typeof platoData !== 'object') {\n      throw new Error('Los datos del plato deben ser un objeto válido');\n    }\n    if (!platoData.name || platoData.name.trim() === '') {\n      throw new Error('El plato debe tener un nombre válido');\n    }\n\n    // Preparar los datos del plato para guardar\n    const platoParaGuardar = {\n      ...platoData,\n      // Asegurar que el precio sea un número\n      price: typeof platoData.price === 'string' ? parseFloat(platoData.price) : platoData.price,\n      // Asegurar que is_available sea booleano\n      is_available: Boolean(platoData.is_available)\n    };\n    console.log('✅ Datos validados, llamando a createPlato()...');\n\n    // Usar la función createPlato que ya sabemos que funciona\n    const platoGuardado = await createPlato(platoParaGuardar);\n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\n    return platoGuardado;\n  } catch (error) {\n    console.error('❌ Error en guardarPlato():', error);\n    throw error;\n  }\n}\n\n// Simplificar la exposición de la función de depuración\nif (typeof window !== 'undefined') {\n  window.debugDB = debugIndexedDB;\n  // Exponer la función guardarPlato para debug y uso directo\n  window.guardarPlato = guardarPlato;\n}\nexport { openDB, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato, debugIndexedDB, guardarPlato // Exportar la nueva función\n};\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato,\n  debugIndexedDB,\n  guardarPlato // Exportar la nueva función\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","onupgradeneeded","objectStoreNames","contains","platosStore","createObjectStore","keyPath","autoIncrement","createIndex","unique","syncQueueStore","openDB","savePlato","platoData","name","Error","transaction","store","objectStore","platoToSave","syncStatus","localTimestamp","Date","getTime","add","savedId","savedPlato","id","addToSyncQueue","type","entityType","entityId","data","timestamp","syncError","setTimeout","verificationResult","verifyPlatoStorage","warn","verifyError","message","oncomplete","getAllPlatos","getAll","platos","length","getPendingPlatos","index","pendingPlatos","updatePlatoSyncStatus","status","validStatuses","includes","join","getRequest","get","plato","is_available","updateRequest","put","close","item","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","deleteRequest","logDB","version","Array","from","setInterval","createPlato","trim","platoToCreate","createdAt","toISOString","updatedAt","createdPlato","found","find","p","listError","verified","transactionError","debugIndexedDB","databases","window","syncQueue","stores","guardarPlato","platoParaGuardar","price","parseFloat","Boolean","platoGuardado","debugDB"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/indexedDBService.js"],"sourcesContent":["// src/services/indexedDBService.js\r\n\r\n// Servicio para manejar operaciones con IndexedDB\r\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\r\nconst DB_VERSION = 3;\r\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\r\nconst SYNC_QUEUE_STORE = 'syncQueue';\r\n\r\n// Inicializar la base de datos\r\nconst initDB = () => {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos IndexedDB:', event);\r\n      reject('Error al abrir la base de datos');\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      console.log('IndexedDB inicializada correctamente');\r\n      resolve(db);\r\n    };\r\n    \r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      console.log('Actualizando estructura de la base de datos...');\r\n      \r\n      // Crear almacén para platos si no existe\r\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\r\n        console.log('Creando almacén de platos...');\r\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id', autoIncrement: true });\r\n        platosStore.createIndex('name', 'name', { unique: false });\r\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\r\n        console.log('Almacén de platos creado');\r\n      } else {\r\n        console.log('El almacén de platos ya existe');\r\n      }\r\n      \r\n      // Crear almacén para la cola de sincronización si no existe\r\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\r\n        console.log('Creando almacén de cola de sincronización...');\r\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\r\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n        syncQueueStore.createIndex('type', 'type', { unique: false });\r\n        console.log('Almacén de cola de sincronización creado');\r\n      } else {\r\n        console.log('El almacén de cola de sincronización ya existe');\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Abrir conexión a la base de datos\r\nconst openDB = async () => {\r\n  try {\r\n    return await initDB();\r\n  } catch (error) {\r\n    console.error('Error al abrir conexión a IndexedDB:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Guardar un plato en IndexedDB\r\nconst savePlato = async (platoData) => {\r\n  console.log('Intentando guardar el plato:', platoData);\r\n  return new Promise(async (resolve, reject) => {\r\n    try {\r\n      console.log('Iniciando guardado en IndexedDB:', platoData);\r\n      \r\n      // Validación adicional de campos obligatorios\r\n      if (!platoData.name) {\r\n        throw new Error('El plato debe tener un nombre');\r\n      }\r\n      \r\n      const db = await openDB();\r\n      \r\n      // Usar la constante PLATOS_STORE\r\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      \r\n      // Agregar estado de sincronización al plato\r\n      const platoToSave = {\r\n        ...platoData,\r\n        syncStatus: 'pending',\r\n        localTimestamp: new Date().getTime()\r\n      };\r\n      \r\n      console.log('Guardando plato con datos finales:', platoToSave);\r\n      const request = store.add(platoToSave);\r\n      \r\n      request.onsuccess = async (event) => {\r\n        const savedId = event.target.result;\r\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\r\n        \r\n        // Resolver la promesa con el objeto completo del plato\r\n        const savedPlato = { ...platoToSave, id: savedId };\r\n        \r\n        // Agregar a la cola de sincronización\r\n        try {\r\n          await addToSyncQueue({\r\n            type: 'create',\r\n            entityType: 'plato',\r\n            entityId: savedId,\r\n            data: platoToSave,\r\n            timestamp: new Date().getTime()\r\n          });\r\n          console.log('Plato agregado a la cola de sincronización');\r\n        } catch (syncError) {\r\n          console.error('Error al agregar a la cola de sincronización:', syncError);\r\n          // Continuamos a pesar del error en la cola\r\n        }\r\n        \r\n        // Verificar almacenamiento después de completar la transacción\r\n        setTimeout(async () => {\r\n          try {\r\n            const verificationResult = await verifyPlatoStorage(savedId);\r\n            if (verificationResult) {\r\n              console.log('Verificación exitosa del guardado del plato');\r\n            } else {\r\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\r\n            }\r\n          } catch (verifyError) {\r\n            console.error('Error al verificar almacenamiento:', verifyError);\r\n          }\r\n        }, 500);\r\n        \r\n        resolve(savedPlato);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\r\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\r\n      };\r\n      \r\n      // Manejar errores de transacción\r\n      transaction.onerror = (event) => {\r\n        console.error('Error en la transacción de guardado:', event.target.error);\r\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\r\n      };\r\n      \r\n      transaction.oncomplete = () => {\r\n        console.log('Transacción de guardado completada exitosamente');\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('Error general en savePlato:', error);\r\n      reject(error);\r\n    }\r\n  });\r\n};\r\n\r\n// Obtener todos los platos de IndexedDB\r\nconst getAllPlatos = async () => {\r\n  try {\r\n    console.log('Obteniendo todos los platos de IndexedDB...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const request = store.getAll();\r\n      \r\n      request.onsuccess = (event) => {\r\n        const platos = event.target.result;\r\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\r\n        resolve(platos);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener platos de IndexedDB:', event);\r\n        reject('Error al obtener platos localmente');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getAllPlatos:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Obtener platos pendientes de sincronización\r\nconst getPendingPlatos = async () => {\r\n  try {\r\n    console.log('Buscando platos pendientes de sincronización...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const index = store.index('syncStatus');\r\n      const request = index.getAll('pending');\r\n      \r\n      request.onsuccess = (event) => {\r\n        const pendingPlatos = event.target.result;\r\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\r\n        resolve(pendingPlatos);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener platos pendientes:', event);\r\n        reject('Error al obtener platos pendientes');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getPendingPlatos:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Actualizar estado de sincronización de un plato\r\nconst updatePlatoSyncStatus = async (id, status) => {\r\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\r\n  \r\n  // Validar que el estado sea uno de los permitidos\r\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\r\n  if (!validStatuses.includes(status)) {\r\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\r\n  }\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos:', event.target.error);\r\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      try {\r\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n        const platosStore = transaction.objectStore(PLATOS_STORE);\r\n        \r\n        // Obtener el plato primero\r\n        const getRequest = platosStore.get(id);\r\n        \r\n        getRequest.onerror = (event) => {\r\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\r\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\r\n        };\r\n        \r\n        getRequest.onsuccess = (event) => {\r\n          const plato = event.target.result;\r\n          \r\n          if (!plato) {\r\n            console.error(`No se encontró plato con ID ${id}.`);\r\n            reject(new Error(`No se encontró plato con ID ${id}.`));\r\n            return;\r\n          }\r\n          \r\n          // Actualizar el estado de sincronización\r\n          plato.syncStatus = status;\r\n          \r\n          // Si es pending_deletion, marcar como no disponible también\r\n          if (status === 'pending_deletion') {\r\n            plato.is_available = false;\r\n          }\r\n          \r\n          // Guardar el plato actualizado\r\n          const updateRequest = platosStore.put(plato);\r\n          \r\n          updateRequest.onerror = (event) => {\r\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\r\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\r\n          };\r\n          \r\n          updateRequest.onsuccess = () => {\r\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\r\n            resolve(true);\r\n          };\r\n        };\r\n        \r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        console.error('Error en la transacción:', error);\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Agregar elemento a la cola de sincronización\r\nconst addToSyncQueue = async (item) => {\r\n  try {\r\n    console.log('Agregando elemento a la cola de sincronización:', item);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      \r\n      const request = store.add(item);\r\n      \r\n      request.onsuccess = (event) => {\r\n        console.log('Elemento agregado a la cola de sincronización');\r\n        resolve(event.target.result);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al agregar a la cola de sincronización:', event);\r\n        reject('Error al agregar a la cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en addToSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Obtener elementos de la cola de sincronización\r\nconst getSyncQueue = async () => {\r\n  try {\r\n    console.log('Obteniendo cola de sincronización...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      const request = store.getAll();\r\n      \r\n      request.onsuccess = (event) => {\r\n        const queue = event.target.result;\r\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\r\n        resolve(queue);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener cola de sincronización:', event);\r\n        reject('Error al obtener cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Eliminar elemento de la cola de sincronización\r\nconst removeFromSyncQueue = async (id) => {\r\n  try {\r\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      \r\n      const request = store.delete(id);\r\n      \r\n      request.onsuccess = () => {\r\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\r\n        resolve(true);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al eliminar de la cola de sincronización:', event);\r\n        reject('Error al eliminar de la cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en removeFromSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Eliminar un plato de IndexedDB\r\nconst deletePlato = async (id) => {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos:', event.target.error);\r\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      try {\r\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n        const platosStore = transaction.objectStore(PLATOS_STORE);\r\n        \r\n        const deleteRequest = platosStore.delete(id);\r\n        \r\n        deleteRequest.onerror = (event) => {\r\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\r\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\r\n        };\r\n        \r\n        deleteRequest.onsuccess = () => {\r\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\r\n          resolve(true);\r\n        };\r\n        \r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        console.error('Error en la transacción:', error);\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Añadir esto al principio del archivo para depuración\r\nconst logDB = async () => {\r\n  const db = await openDB();\r\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\r\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\r\n};\r\n\r\n// Y llamarlo periódicamente para verificar\r\nsetInterval(logDB, 10000);\r\n\r\n// Verificar si un plato fue guardado correctamente (con timeout)\r\nconst verifyPlatoStorage = async (id) => {\r\n  try {\r\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const request = store.get(id);\r\n      \r\n      request.onsuccess = (event) => {\r\n        const plato = event.target.result;\r\n        if (plato) {\r\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\r\n          resolve(plato);\r\n        } else {\r\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\r\n          resolve(null);\r\n        }\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\r\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\r\n      };\r\n      \r\n      transaction.oncomplete = () => {\r\n        console.log('Transacción de verificación completada');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en verifyPlatoStorage:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Crea un nuevo plato en la base de datos\r\n * @param {Object} plato - Datos del plato a crear\r\n * @returns {Promise<Object>} - Plato creado con su ID asignado\r\n */\r\nasync function createPlato(plato) {\r\n  console.log('🍽️ INICIO - Creando nuevo plato en IndexedDB:', plato);\r\n  \r\n  try {\r\n    // Validación más estricta de datos antes de intentar abrir la BD\r\n    if (!plato || typeof plato !== 'object') {\r\n      console.error('❌ ERROR: El plato debe ser un objeto válido', plato);\r\n      throw new Error('El plato debe ser un objeto válido');\r\n    }\r\n    \r\n    if (!plato.name || plato.name.trim() === '') {\r\n      console.error('❌ ERROR: El plato debe tener un nombre válido', plato);\r\n      throw new Error('El plato debe tener un nombre válido');\r\n    }\r\n    \r\n    console.log('✅ Validación inicial del plato exitosa');\r\n    \r\n    // Abrimos la BD con registro detallado\r\n    console.log('🔄 Abriendo base de datos...');\r\n    const db = await openDB();\r\n    console.log('✅ Base de datos abierta correctamente');\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      console.log('🔄 Iniciando transacción para guardar plato...');\r\n      \r\n      try {\r\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n        console.log('✅ Transacción creada correctamente');\r\n        \r\n        const store = transaction.objectStore(PLATOS_STORE);\r\n        console.log('✅ Almacén obtenido correctamente');\r\n        \r\n        // Preparar el plato con todos los campos necesarios\r\n        const platoToCreate = {\r\n          ...plato,\r\n          createdAt: plato.createdAt || new Date().toISOString(),\r\n          updatedAt: new Date().toISOString(),\r\n          syncStatus: 'pending',\r\n          localTimestamp: new Date().getTime()\r\n        };\r\n        \r\n        console.log('📦 Intentando guardar plato con datos:', platoToCreate);\r\n        const request = store.add(platoToCreate);\r\n        \r\n        request.onsuccess = async (event) => {\r\n          const id = event.target.result;\r\n          console.log(`✅ ÉXITO: Plato creado con ID: ${id}`);\r\n          \r\n          // Crear objeto completo con el ID asignado\r\n          const createdPlato = { ...platoToCreate, id };\r\n          \r\n          // Agregar a la cola de sincronización\r\n          try {\r\n            console.log('🔄 Agregando plato a cola de sincronización...');\r\n            await addToSyncQueue({\r\n              type: 'create',\r\n              entityType: 'plato',\r\n              entityId: id,\r\n              data: createdPlato,\r\n              timestamp: new Date().getTime()\r\n            });\r\n            console.log('✅ Plato agregado a la cola de sincronización correctamente');\r\n          } catch (syncError) {\r\n            console.warn('⚠️ Error al agregar a cola de sincronización:', syncError);\r\n            // Continuamos a pesar de error en cola\r\n          }\r\n          \r\n          // Verificación inmediata para depuración\r\n          console.log('🔍 Verificando inmediatamente el almacenamiento del plato...');\r\n          try {\r\n            const platos = await getAllPlatos();\r\n            console.log(`📊 Total de platos en BD: ${platos.length}`);\r\n            console.log('📋 Lista de platos:', platos);\r\n            \r\n            const found = platos.find(p => p.id === id);\r\n            if (found) {\r\n              console.log('✅ VERIFICACIÓN EXITOSA: Plato encontrado en la lista completa');\r\n            } else {\r\n              console.error('❌ VERIFICACIÓN FALLIDA: Plato NO encontrado en la lista completa');\r\n            }\r\n          } catch (listError) {\r\n            console.error('❌ Error al listar platos para verificación:', listError);\r\n          }\r\n          \r\n          // Verificación posterior para asegurar persistencia\r\n          setTimeout(async () => {\r\n            try {\r\n              console.log(`🔍 Verificando persistencia del plato ID ${id}...`);\r\n              const verified = await verifyPlatoStorage(id);\r\n              if (verified) {\r\n                console.log('✅ VERIFICACIÓN POSTERIOR: Plato confirmado en base de datos');\r\n              } else {\r\n                console.error('❌ VERIFICACIÓN POSTERIOR FALLIDA: Plato no encontrado en verificación');\r\n              }\r\n            } catch (verifyError) {\r\n              console.error('❌ Error en verificación posterior:', verifyError);\r\n            }\r\n          }, 1000);\r\n          \r\n          console.log('🏁 Finalizando creación del plato con éxito');\r\n          resolve(createdPlato);\r\n        };\r\n        \r\n        request.onerror = (event) => {\r\n          console.error('❌ ERROR al crear plato:', event.target.error);\r\n          reject(new Error(`Error al crear plato: ${event.target.error.message}`));\r\n        };\r\n        \r\n        transaction.onerror = (event) => {\r\n          console.error('❌ ERROR en transacción:', event.target.error);\r\n          reject(new Error(`Error en transacción: ${event.target.error.message}`));\r\n        };\r\n        \r\n        transaction.oncomplete = () => {\r\n          console.log('✅ Transacción completada correctamente');\r\n        };\r\n      } catch (transactionError) {\r\n        console.error('❌ ERROR al crear transacción:', transactionError);\r\n        reject(new Error(`Error al crear transacción: ${transactionError.message}`));\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('❌ ERROR GENERAL en createPlato:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Función de depuración para verificar el contenido de la base de datos\r\n * @returns {Promise<void>}\r\n */\r\nasync function debugIndexedDB() {\r\n  console.log('🔍 INICIANDO DEPURACIÓN DE INDEXEDDB...');\r\n  \r\n  try {\r\n    // Verificar la existencia de la base de datos\r\n    const databases = await window.indexedDB.databases();\r\n    console.log('📊 Bases de datos disponibles:', databases);\r\n    \r\n    // Abrir la base de datos y verificar su estructura\r\n    const db = await openDB();\r\n    console.log('📦 Almacenes en la base de datos:', Array.from(db.objectStoreNames));\r\n    \r\n    // Verificar contenido del almacén de platos\r\n    const platos = await getAllPlatos();\r\n    console.log(`📋 Platos almacenados (${platos.length}):`, platos);\r\n    \r\n    // Verificar cola de sincronización\r\n    const syncQueue = await getSyncQueue();\r\n    console.log(`🔄 Cola de sincronización (${syncQueue.length}):`, syncQueue);\r\n    \r\n    console.log('✅ DEPURACIÓN COMPLETADA');\r\n    return {\r\n      databases,\r\n      stores: Array.from(db.objectStoreNames),\r\n      platos,\r\n      syncQueue\r\n    };\r\n  } catch (error) {\r\n    console.error('❌ ERROR EN DEPURACIÓN:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Función auxiliar para guardar platos desde cualquier formulario de la aplicación\r\n * Es una envoltura (wrapper) que garantiza que el plato se guarde correctamente\r\n * @param {Object} platoData - Datos del plato a guardar\r\n * @returns {Promise<Object>} El plato guardado\r\n */\r\nasync function guardarPlato(platoData) {\r\n  console.log('🔄 Iniciando guardado de plato con guardarPlato():', platoData);\r\n  \r\n  try {\r\n    // Validación de datos\r\n    if (!platoData || typeof platoData !== 'object') {\r\n      throw new Error('Los datos del plato deben ser un objeto válido');\r\n    }\r\n    \r\n    if (!platoData.name || platoData.name.trim() === '') {\r\n      throw new Error('El plato debe tener un nombre válido');\r\n    }\r\n    \r\n    // Preparar los datos del plato para guardar\r\n    const platoParaGuardar = {\r\n      ...platoData,\r\n      // Asegurar que el precio sea un número\r\n      price: typeof platoData.price === 'string' ? parseFloat(platoData.price) : platoData.price,\r\n      // Asegurar que is_available sea booleano\r\n      is_available: Boolean(platoData.is_available)\r\n    };\r\n    \r\n    console.log('✅ Datos validados, llamando a createPlato()...');\r\n    \r\n    // Usar la función createPlato que ya sabemos que funciona\r\n    const platoGuardado = await createPlato(platoParaGuardar);\r\n    \r\n    console.log('✅ Plato guardado exitosamente:', platoGuardado);\r\n    return platoGuardado;\r\n  } catch (error) {\r\n    console.error('❌ Error en guardarPlato():', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Simplificar la exposición de la función de depuración\r\nif (typeof window !== 'undefined') {\r\n  window.debugDB = debugIndexedDB;\r\n  // Exponer la función guardarPlato para debug y uso directo\r\n  window.guardarPlato = guardarPlato;\r\n}\r\n\r\nexport {\r\n  openDB,\r\n  savePlato,\r\n  getAllPlatos,\r\n  getPendingPlatos,\r\n  updatePlatoSyncStatus,\r\n  addToSyncQueue,\r\n  getSyncQueue,\r\n  removeFromSyncQueue,\r\n  deletePlato,\r\n  verifyPlatoStorage,\r\n  createPlato,\r\n  debugIndexedDB,\r\n  guardarPlato  // Exportar la nueva función\r\n};\r\n\r\nexport default {\r\n  openDB,\r\n  savePlato,\r\n  getAllPlatos,\r\n  getPendingPlatos,\r\n  updatePlatoSyncStatus,\r\n  addToSyncQueue,\r\n  getSyncQueue,\r\n  removeFromSyncQueue,\r\n  deletePlato,\r\n  verifyPlatoStorage,\r\n  createPlato,\r\n  debugIndexedDB,\r\n  guardarPlato  // Exportar la nueva función\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}