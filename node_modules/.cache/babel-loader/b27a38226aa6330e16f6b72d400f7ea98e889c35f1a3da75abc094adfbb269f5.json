{"ast":null,"code":"// src/services/indexedDBService.js\n\n// Servicio para manejar operaciones con IndexedDB\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\nconst DB_VERSION = 3;\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\nconst SYNC_QUEUE_STORE = 'syncQueue';\n\n// Inicializar la base de datos\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos IndexedDB:', event);\n      reject('Error al abrir la base de datos');\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      console.log('IndexedDB inicializada correctamente');\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      console.log('Actualizando estructura de la base de datos...');\n\n      // Crear almacén para platos si no existe\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\n        console.log('Creando almacén de platos...');\n        const platosStore = db.createObjectStore(PLATOS_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        platosStore.createIndex('name', 'name', {\n          unique: false\n        });\n        platosStore.createIndex('syncStatus', 'syncStatus', {\n          unique: false\n        });\n        console.log('Almacén de platos creado');\n      } else {\n        console.log('El almacén de platos ya existe');\n      }\n\n      // Crear almacén para la cola de sincronización si no existe\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\n        console.log('Creando almacén de cola de sincronización...');\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        syncQueueStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n        syncQueueStore.createIndex('type', 'type', {\n          unique: false\n        });\n        console.log('Almacén de cola de sincronización creado');\n      } else {\n        console.log('El almacén de cola de sincronización ya existe');\n      }\n    };\n  });\n};\n\n// Abrir conexión a la base de datos\nconst openDB = async () => {\n  try {\n    return await initDB();\n  } catch (error) {\n    console.error('Error al abrir conexión a IndexedDB:', error);\n    throw error;\n  }\n};\n\n// Guardar un plato en IndexedDB\nconst savePlato = async platoData => {\n  console.log('Intentando guardar el plato:', platoData);\n  return new Promise(async (resolve, reject) => {\n    try {\n      console.log('Iniciando guardado en IndexedDB:', platoData);\n\n      // Validación adicional de campos obligatorios\n      if (!platoData.name) {\n        throw new Error('El plato debe tener un nombre');\n      }\n      const db = await openDB();\n\n      // Usar la constante PLATOS_STORE\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n      const store = transaction.objectStore(PLATOS_STORE);\n\n      // Agregar estado de sincronización al plato\n      const platoToSave = {\n        ...platoData,\n        syncStatus: 'pending',\n        localTimestamp: new Date().getTime()\n      };\n      console.log('Guardando plato con datos finales:', platoToSave);\n      const request = store.add(platoToSave);\n      request.onsuccess = async event => {\n        const savedId = event.target.result;\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\n\n        // Resolver la promesa con el objeto completo del plato\n        const savedPlato = {\n          ...platoToSave,\n          id: savedId\n        };\n\n        // Agregar a la cola de sincronización\n        try {\n          await addToSyncQueue({\n            type: 'create',\n            entityType: 'plato',\n            entityId: savedId,\n            data: platoToSave,\n            timestamp: new Date().getTime()\n          });\n          console.log('Plato agregado a la cola de sincronización');\n        } catch (syncError) {\n          console.error('Error al agregar a la cola de sincronización:', syncError);\n          // Continuamos a pesar del error en la cola\n        }\n\n        // Verificar almacenamiento después de completar la transacción\n        setTimeout(async () => {\n          try {\n            const verificationResult = await verifyPlatoStorage(savedId);\n            if (verificationResult) {\n              console.log('Verificación exitosa del guardado del plato');\n            } else {\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\n            }\n          } catch (verifyError) {\n            console.error('Error al verificar almacenamiento:', verifyError);\n          }\n        }, 500);\n        resolve(savedPlato);\n      };\n      request.onerror = event => {\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = event => {\n        console.error('Error en la transacción de guardado:', event.target.error);\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de guardado completada exitosamente');\n      };\n    } catch (error) {\n      console.error('Error general en savePlato:', error);\n      reject(error);\n    }\n  });\n};\n\n// Obtener todos los platos de IndexedDB\nconst getAllPlatos = async () => {\n  try {\n    console.log('Obteniendo todos los platos de IndexedDB...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const platos = event.target.result;\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\n        resolve(platos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos de IndexedDB:', event);\n        reject('Error al obtener platos localmente');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getAllPlatos:', error);\n    throw error;\n  }\n};\n\n// Obtener platos pendientes de sincronización\nconst getPendingPlatos = async () => {\n  try {\n    console.log('Buscando platos pendientes de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const index = store.index('syncStatus');\n      const request = index.getAll('pending');\n      request.onsuccess = event => {\n        const pendingPlatos = event.target.result;\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\n        resolve(pendingPlatos);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener platos pendientes:', event);\n        reject('Error al obtener platos pendientes');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getPendingPlatos:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de sincronización de un plato\nconst updatePlatoSyncStatus = async (id, status) => {\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\n\n  // Validar que el estado sea uno de los permitidos\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\n  }\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n\n        // Obtener el plato primero\n        const getRequest = platosStore.get(id);\n        getRequest.onerror = event => {\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\n        };\n        getRequest.onsuccess = event => {\n          const plato = event.target.result;\n          if (!plato) {\n            console.error(`No se encontró plato con ID ${id}.`);\n            reject(new Error(`No se encontró plato con ID ${id}.`));\n            return;\n          }\n\n          // Actualizar el estado de sincronización\n          plato.syncStatus = status;\n\n          // Si es pending_deletion, marcar como no disponible también\n          if (status === 'pending_deletion') {\n            plato.is_available = false;\n          }\n\n          // Guardar el plato actualizado\n          const updateRequest = platosStore.put(plato);\n          updateRequest.onerror = event => {\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\n          };\n          updateRequest.onsuccess = () => {\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\n            resolve(true);\n          };\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Agregar elemento a la cola de sincronización\nconst addToSyncQueue = async item => {\n  try {\n    console.log('Agregando elemento a la cola de sincronización:', item);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.add(item);\n      request.onsuccess = event => {\n        console.log('Elemento agregado a la cola de sincronización');\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        console.error('Error al agregar a la cola de sincronización:', event);\n        reject('Error al agregar a la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en addToSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Obtener elementos de la cola de sincronización\nconst getSyncQueue = async () => {\n  try {\n    console.log('Obteniendo cola de sincronización...');\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.getAll();\n      request.onsuccess = event => {\n        const queue = event.target.result;\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\n        resolve(queue);\n      };\n      request.onerror = event => {\n        console.error('Error al obtener cola de sincronización:', event);\n        reject('Error al obtener cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en getSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar elemento de la cola de sincronización\nconst removeFromSyncQueue = async id => {\n  try {\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\n      const request = store.delete(id);\n      request.onsuccess = () => {\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\n        resolve(true);\n      };\n      request.onerror = event => {\n        console.error('Error al eliminar de la cola de sincronización:', event);\n        reject('Error al eliminar de la cola de sincronización');\n      };\n    });\n  } catch (error) {\n    console.error('Error en removeFromSyncQueue:', error);\n    throw error;\n  }\n};\n\n// Eliminar un plato de IndexedDB\nconst deletePlato = async id => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error('Error al abrir la base de datos:', event.target.error);\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      try {\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n        const platosStore = transaction.objectStore(PLATOS_STORE);\n        const deleteRequest = platosStore.delete(id);\n        deleteRequest.onerror = event => {\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\n        };\n        deleteRequest.onsuccess = () => {\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\n          resolve(true);\n        };\n        transaction.oncomplete = () => {\n          db.close();\n        };\n      } catch (error) {\n        console.error('Error en la transacción:', error);\n        reject(error);\n      }\n    };\n  });\n};\n\n// Añadir esto al principio del archivo para depuración\nconst logDB = async () => {\n  const db = await openDB();\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\n};\n\n// Y llamarlo periódicamente para verificar\nsetInterval(logDB, 10000);\n\n// Verificar si un plato fue guardado correctamente (con timeout)\nconst verifyPlatoStorage = async id => {\n  try {\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\n    const db = await openDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\n      const store = transaction.objectStore(PLATOS_STORE);\n      const request = store.get(id);\n      request.onsuccess = event => {\n        const plato = event.target.result;\n        if (plato) {\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\n          resolve(plato);\n        } else {\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\n          resolve(null);\n        }\n      };\n      request.onerror = event => {\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\n      };\n      transaction.oncomplete = () => {\n        console.log('Transacción de verificación completada');\n      };\n    });\n  } catch (error) {\n    console.error('Error en verifyPlatoStorage:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Crea un nuevo plato en la base de datos\r\n * @param {Object} plato - Datos del plato a crear\r\n * @returns {Promise<number>} - ID del plato creado\r\n */\nasync function createPlato(plato) {\n  try {\n    const db = await openDB();\n    const tx = db.transaction('platos', 'readwrite');\n    const store = tx.objectStore('platos');\n\n    // Asegurar que el plato tenga fecha de creación\n    const platoToCreate = {\n      ...plato,\n      createdAt: plato.createdAt || new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      syncStatus: 'pendiente' // Marcar para sincronización posterior\n    };\n    const id = await store.add(platoToCreate);\n    await tx.complete;\n    console.log('Plato creado en IndexedDB con ID:', id);\n    return id;\n  } catch (error) {\n    console.error('Error al crear plato en IndexedDB:', error);\n    throw error;\n  }\n}\n\n// Ejemplo de objeto de plato para pruebas\nconst testPlato = {\n  name: \"Test Plato\",\n  description: \"Descripción del test plato\",\n  price: 10.5,\n  category: \"Test Categoria\",\n  image_url: \"http://example.com/image.jpg\",\n  is_available: true\n};\n\n// Llamada directa a la función de creación\ncreatePlato(testPlato).then(result => {\n  console.log(\"Resultado de la creación del plato:\", result);\n}).catch(error => {\n  console.error(\"Error al crear el plato:\", error);\n});\nexport { openDB, savePlato, getAllPlatos, getPendingPlatos, updatePlatoSyncStatus, addToSyncQueue, getSyncQueue, removeFromSyncQueue, deletePlato, verifyPlatoStorage, createPlato };\nexport default {\n  openDB,\n  savePlato,\n  getAllPlatos,\n  getPendingPlatos,\n  updatePlatoSyncStatus,\n  addToSyncQueue,\n  getSyncQueue,\n  removeFromSyncQueue,\n  deletePlato,\n  verifyPlatoStorage,\n  createPlato\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","PLATOS_STORE","SYNC_QUEUE_STORE","initDB","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","onsuccess","db","target","result","onupgradeneeded","objectStoreNames","contains","platosStore","createObjectStore","keyPath","autoIncrement","createIndex","unique","syncQueueStore","openDB","savePlato","platoData","name","Error","transaction","store","objectStore","platoToSave","syncStatus","localTimestamp","Date","getTime","add","savedId","savedPlato","id","addToSyncQueue","type","entityType","entityId","data","timestamp","syncError","setTimeout","verificationResult","verifyPlatoStorage","warn","verifyError","message","oncomplete","getAllPlatos","getAll","platos","length","getPendingPlatos","index","pendingPlatos","updatePlatoSyncStatus","status","validStatuses","includes","join","getRequest","get","plato","is_available","updateRequest","put","close","item","getSyncQueue","queue","removeFromSyncQueue","delete","deletePlato","deleteRequest","logDB","version","Array","from","setInterval","createPlato","tx","platoToCreate","createdAt","toISOString","updatedAt","complete","testPlato","description","price","category","image_url","then","catch"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/indexedDBService.js"],"sourcesContent":["// src/services/indexedDBService.js\r\n\r\n// Servicio para manejar operaciones con IndexedDB\r\nconst DB_NAME = 'restauranteAppDB'; // Usar este nombre para todas las operaciones\r\nconst DB_VERSION = 3;\r\nconst PLATOS_STORE = 'platos'; // Usar 'platos' en lugar de 'menuItems'\r\nconst SYNC_QUEUE_STORE = 'syncQueue';\r\n\r\n// Inicializar la base de datos\r\nconst initDB = () => {\r\n  return new Promise((resolve, reject) => {\r\n    console.log(`Intentando abrir la base de datos con versión: ${DB_VERSION}`);\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos IndexedDB:', event);\r\n      reject('Error al abrir la base de datos');\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      console.log('IndexedDB inicializada correctamente');\r\n      resolve(db);\r\n    };\r\n    \r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      console.log('Actualizando estructura de la base de datos...');\r\n      \r\n      // Crear almacén para platos si no existe\r\n      if (!db.objectStoreNames.contains(PLATOS_STORE)) {\r\n        console.log('Creando almacén de platos...');\r\n        const platosStore = db.createObjectStore(PLATOS_STORE, { keyPath: 'id', autoIncrement: true });\r\n        platosStore.createIndex('name', 'name', { unique: false });\r\n        platosStore.createIndex('syncStatus', 'syncStatus', { unique: false });\r\n        console.log('Almacén de platos creado');\r\n      } else {\r\n        console.log('El almacén de platos ya existe');\r\n      }\r\n      \r\n      // Crear almacén para la cola de sincronización si no existe\r\n      if (!db.objectStoreNames.contains(SYNC_QUEUE_STORE)) {\r\n        console.log('Creando almacén de cola de sincronización...');\r\n        const syncQueueStore = db.createObjectStore(SYNC_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });\r\n        syncQueueStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n        syncQueueStore.createIndex('type', 'type', { unique: false });\r\n        console.log('Almacén de cola de sincronización creado');\r\n      } else {\r\n        console.log('El almacén de cola de sincronización ya existe');\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Abrir conexión a la base de datos\r\nconst openDB = async () => {\r\n  try {\r\n    return await initDB();\r\n  } catch (error) {\r\n    console.error('Error al abrir conexión a IndexedDB:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Guardar un plato en IndexedDB\r\nconst savePlato = async (platoData) => {\r\n  console.log('Intentando guardar el plato:', platoData);\r\n  return new Promise(async (resolve, reject) => {\r\n    try {\r\n      console.log('Iniciando guardado en IndexedDB:', platoData);\r\n      \r\n      // Validación adicional de campos obligatorios\r\n      if (!platoData.name) {\r\n        throw new Error('El plato debe tener un nombre');\r\n      }\r\n      \r\n      const db = await openDB();\r\n      \r\n      // Usar la constante PLATOS_STORE\r\n      const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      \r\n      // Agregar estado de sincronización al plato\r\n      const platoToSave = {\r\n        ...platoData,\r\n        syncStatus: 'pending',\r\n        localTimestamp: new Date().getTime()\r\n      };\r\n      \r\n      console.log('Guardando plato con datos finales:', platoToSave);\r\n      const request = store.add(platoToSave);\r\n      \r\n      request.onsuccess = async (event) => {\r\n        const savedId = event.target.result;\r\n        console.log(`Plato guardado localmente con ID: ${savedId}`);\r\n        \r\n        // Resolver la promesa con el objeto completo del plato\r\n        const savedPlato = { ...platoToSave, id: savedId };\r\n        \r\n        // Agregar a la cola de sincronización\r\n        try {\r\n          await addToSyncQueue({\r\n            type: 'create',\r\n            entityType: 'plato',\r\n            entityId: savedId,\r\n            data: platoToSave,\r\n            timestamp: new Date().getTime()\r\n          });\r\n          console.log('Plato agregado a la cola de sincronización');\r\n        } catch (syncError) {\r\n          console.error('Error al agregar a la cola de sincronización:', syncError);\r\n          // Continuamos a pesar del error en la cola\r\n        }\r\n        \r\n        // Verificar almacenamiento después de completar la transacción\r\n        setTimeout(async () => {\r\n          try {\r\n            const verificationResult = await verifyPlatoStorage(savedId);\r\n            if (verificationResult) {\r\n              console.log('Verificación exitosa del guardado del plato');\r\n            } else {\r\n              console.warn('⚠️ Advertencia: El plato no se pudo verificar en IndexedDB');\r\n            }\r\n          } catch (verifyError) {\r\n            console.error('Error al verificar almacenamiento:', verifyError);\r\n          }\r\n        }, 500);\r\n        \r\n        resolve(savedPlato);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al guardar plato en IndexedDB:', event.target.error);\r\n        reject(new Error('Error al guardar plato localmente: ' + event.target.error.message));\r\n      };\r\n      \r\n      // Manejar errores de transacción\r\n      transaction.onerror = (event) => {\r\n        console.error('Error en la transacción de guardado:', event.target.error);\r\n        reject(new Error('Error en la transacción: ' + event.target.error.message));\r\n      };\r\n      \r\n      transaction.oncomplete = () => {\r\n        console.log('Transacción de guardado completada exitosamente');\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('Error general en savePlato:', error);\r\n      reject(error);\r\n    }\r\n  });\r\n};\r\n\r\n// Obtener todos los platos de IndexedDB\r\nconst getAllPlatos = async () => {\r\n  try {\r\n    console.log('Obteniendo todos los platos de IndexedDB...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const request = store.getAll();\r\n      \r\n      request.onsuccess = (event) => {\r\n        const platos = event.target.result;\r\n        console.log(`Obtenidos ${platos.length} platos de IndexedDB`);\r\n        resolve(platos);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener platos de IndexedDB:', event);\r\n        reject('Error al obtener platos localmente');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getAllPlatos:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Obtener platos pendientes de sincronización\r\nconst getPendingPlatos = async () => {\r\n  try {\r\n    console.log('Buscando platos pendientes de sincronización...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const index = store.index('syncStatus');\r\n      const request = index.getAll('pending');\r\n      \r\n      request.onsuccess = (event) => {\r\n        const pendingPlatos = event.target.result;\r\n        console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronización`);\r\n        resolve(pendingPlatos);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener platos pendientes:', event);\r\n        reject('Error al obtener platos pendientes');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getPendingPlatos:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Actualizar estado de sincronización de un plato\r\nconst updatePlatoSyncStatus = async (id, status) => {\r\n  console.log(`Actualizando estado de sincronización del plato ID ${id} a \"${status}\"...`);\r\n  \r\n  // Validar que el estado sea uno de los permitidos\r\n  const validStatuses = ['pending', 'synced', 'pending_deletion'];\r\n  if (!validStatuses.includes(status)) {\r\n    throw new Error(`Estado inválido: ${status}. Debe ser uno de: ${validStatuses.join(', ')}`);\r\n  }\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos:', event.target.error);\r\n      reject(new Error('No se pudo abrir la base de datos para actualizar el estado.'));\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      try {\r\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n        const platosStore = transaction.objectStore(PLATOS_STORE);\r\n        \r\n        // Obtener el plato primero\r\n        const getRequest = platosStore.get(id);\r\n        \r\n        getRequest.onerror = (event) => {\r\n          console.error(`Error al obtener plato ID ${id}:`, event.target.error);\r\n          reject(new Error(`No se pudo obtener el plato ID ${id}.`));\r\n        };\r\n        \r\n        getRequest.onsuccess = (event) => {\r\n          const plato = event.target.result;\r\n          \r\n          if (!plato) {\r\n            console.error(`No se encontró plato con ID ${id}.`);\r\n            reject(new Error(`No se encontró plato con ID ${id}.`));\r\n            return;\r\n          }\r\n          \r\n          // Actualizar el estado de sincronización\r\n          plato.syncStatus = status;\r\n          \r\n          // Si es pending_deletion, marcar como no disponible también\r\n          if (status === 'pending_deletion') {\r\n            plato.is_available = false;\r\n          }\r\n          \r\n          // Guardar el plato actualizado\r\n          const updateRequest = platosStore.put(plato);\r\n          \r\n          updateRequest.onerror = (event) => {\r\n            console.error(`Error al actualizar plato ID ${id}:`, event.target.error);\r\n            reject(new Error(`No se pudo actualizar el estado del plato ID ${id}.`));\r\n          };\r\n          \r\n          updateRequest.onsuccess = () => {\r\n            console.log(`Estado de sincronización del plato ID ${id} actualizado a \"${status}\".`);\r\n            resolve(true);\r\n          };\r\n        };\r\n        \r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        console.error('Error en la transacción:', error);\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Agregar elemento a la cola de sincronización\r\nconst addToSyncQueue = async (item) => {\r\n  try {\r\n    console.log('Agregando elemento a la cola de sincronización:', item);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      \r\n      const request = store.add(item);\r\n      \r\n      request.onsuccess = (event) => {\r\n        console.log('Elemento agregado a la cola de sincronización');\r\n        resolve(event.target.result);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al agregar a la cola de sincronización:', event);\r\n        reject('Error al agregar a la cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en addToSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Obtener elementos de la cola de sincronización\r\nconst getSyncQueue = async () => {\r\n  try {\r\n    console.log('Obteniendo cola de sincronización...');\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readonly');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      const request = store.getAll();\r\n      \r\n      request.onsuccess = (event) => {\r\n        const queue = event.target.result;\r\n        console.log(`Obtenidos ${queue.length} elementos de la cola de sincronización`);\r\n        resolve(queue);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al obtener cola de sincronización:', event);\r\n        reject('Error al obtener cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en getSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Eliminar elemento de la cola de sincronización\r\nconst removeFromSyncQueue = async (id) => {\r\n  try {\r\n    console.log(`Eliminando elemento ${id} de la cola de sincronización...`);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([SYNC_QUEUE_STORE], 'readwrite');\r\n      const store = transaction.objectStore(SYNC_QUEUE_STORE);\r\n      \r\n      const request = store.delete(id);\r\n      \r\n      request.onsuccess = () => {\r\n        console.log(`Elemento ${id} eliminado de la cola de sincronización`);\r\n        resolve(true);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error('Error al eliminar de la cola de sincronización:', event);\r\n        reject('Error al eliminar de la cola de sincronización');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en removeFromSyncQueue:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Eliminar un plato de IndexedDB\r\nconst deletePlato = async (id) => {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      console.error('Error al abrir la base de datos:', event.target.error);\r\n      reject(new Error('No se pudo abrir la base de datos para eliminar el plato'));\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      try {\r\n        const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n        const platosStore = transaction.objectStore(PLATOS_STORE);\r\n        \r\n        const deleteRequest = platosStore.delete(id);\r\n        \r\n        deleteRequest.onerror = (event) => {\r\n          console.error(`Error al eliminar plato ID ${id}:`, event.target.error);\r\n          reject(new Error(`No se pudo eliminar el plato ID ${id}`));\r\n        };\r\n        \r\n        deleteRequest.onsuccess = () => {\r\n          console.log(`Plato ID ${id} eliminado con éxito de IndexedDB`);\r\n          resolve(true);\r\n        };\r\n        \r\n        transaction.oncomplete = () => {\r\n          db.close();\r\n        };\r\n      } catch (error) {\r\n        console.error('Error en la transacción:', error);\r\n        reject(error);\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\n// Añadir esto al principio del archivo para depuración\r\nconst logDB = async () => {\r\n  const db = await openDB();\r\n  console.log('Bases de datos disponibles:', db.name, 'versión:', db.version);\r\n  console.log('Almacenes disponibles:', Array.from(db.objectStoreNames));\r\n};\r\n\r\n// Y llamarlo periódicamente para verificar\r\nsetInterval(logDB, 10000);\r\n\r\n// Verificar si un plato fue guardado correctamente (con timeout)\r\nconst verifyPlatoStorage = async (id) => {\r\n  try {\r\n    console.log(`Verificando almacenamiento del plato ID ${id}...`);\r\n    const db = await openDB();\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction([PLATOS_STORE], 'readonly');\r\n      const store = transaction.objectStore(PLATOS_STORE);\r\n      const request = store.get(id);\r\n      \r\n      request.onsuccess = (event) => {\r\n        const plato = event.target.result;\r\n        if (plato) {\r\n          console.log(`Verificación exitosa: Plato ID ${id} encontrado en IndexedDB:`, plato);\r\n          resolve(plato);\r\n        } else {\r\n          console.error(`Verificación fallida: Plato ID ${id} NO encontrado en IndexedDB`);\r\n          resolve(null);\r\n        }\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        console.error(`Error al verificar plato ID ${id}:`, event.target.error);\r\n        reject(new Error(`Error al verificar plato ID ${id}: ${event.target.error.message}`));\r\n      };\r\n      \r\n      transaction.oncomplete = () => {\r\n        console.log('Transacción de verificación completada');\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error en verifyPlatoStorage:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Crea un nuevo plato en la base de datos\r\n * @param {Object} plato - Datos del plato a crear\r\n * @returns {Promise<number>} - ID del plato creado\r\n */\r\nasync function createPlato(plato) {\r\n  try {\r\n    const db = await openDB();\r\n    const tx = db.transaction('platos', 'readwrite');\r\n    const store = tx.objectStore('platos');\r\n    \r\n    // Asegurar que el plato tenga fecha de creación\r\n    const platoToCreate = {\r\n      ...plato,\r\n      createdAt: plato.createdAt || new Date().toISOString(),\r\n      updatedAt: new Date().toISOString(),\r\n      syncStatus: 'pendiente' // Marcar para sincronización posterior\r\n    };\r\n    \r\n    const id = await store.add(platoToCreate);\r\n    await tx.complete;\r\n    \r\n    console.log('Plato creado en IndexedDB con ID:', id);\r\n    return id;\r\n  } catch (error) {\r\n    console.error('Error al crear plato en IndexedDB:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Ejemplo de objeto de plato para pruebas\r\nconst testPlato = {\r\n  name: \"Test Plato\",\r\n  description: \"Descripción del test plato\",\r\n  price: 10.5,\r\n  category: \"Test Categoria\",\r\n  image_url: \"http://example.com/image.jpg\",\r\n  is_available: true\r\n};\r\n\r\n// Llamada directa a la función de creación\r\ncreatePlato(testPlato).then(result => {\r\n  console.log(\"Resultado de la creación del plato:\", result);\r\n}).catch(error => {\r\n  console.error(\"Error al crear el plato:\", error);\r\n});\r\n\r\nexport {\r\n  openDB,\r\n  savePlato,\r\n  getAllPlatos,\r\n  getPendingPlatos,\r\n  updatePlatoSyncStatus,\r\n  addToSyncQueue,\r\n  getSyncQueue,\r\n  removeFromSyncQueue,\r\n  deletePlato,\r\n  verifyPlatoStorage,\r\n  createPlato\r\n};\r\n\r\nexport default {\r\n  openDB,\r\n  savePlato,\r\n  getAllPlatos,\r\n  getPendingPlatos,\r\n  updatePlatoSyncStatus,\r\n  addToSyncQueue,\r\n  getSyncQueue,\r\n  removeFromSyncQueue,\r\n  deletePlato,\r\n  verifyPlatoStorage,\r\n  createPlato\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}