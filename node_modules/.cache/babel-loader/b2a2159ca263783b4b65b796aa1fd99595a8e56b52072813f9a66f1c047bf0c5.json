{"ast":null,"code":"// src/services/syncService.js\n\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\nimport { getPendingPlatos, updatePlatoSyncStatus, getSyncQueue, removeFromSyncQueue, preparePlatoForSync, openDB } from './indexedDBService';\n\n// Constantes desde el servicio IndexedDB\nconst PLATOS_STORE = 'platos';\nconst API_URL = 'http://localhost:3000/api';\n\n// Estado de la sincronizaci√≥n\nlet isSyncing = false;\nlet _isOnline = navigator.onLine;\n\n// Alternativa m√°s simple para verificar la conexi√≥n\nconst isOnline = async () => {\n  // Primero comprobamos el estado de navigator.onLine\n  if (!navigator.onLine) {\n    return false;\n  }\n\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\n  try {\n    const response = await fetch(`${API_URL}/favicon.ico`, {\n      method: 'HEAD',\n      // Solo pedimos las cabeceras, no el contenido\n      mode: 'no-cors',\n      // Modo no-cors para evitar problemas de CORS\n      cache: 'no-store',\n      credentials: 'omit'\n    });\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\n  } catch (error) {\n    console.error('Error al verificar estado de conexi√≥n:', error);\n    return false;\n  }\n};\n\n// Configurar escuchas para eventos de conexi√≥n\nconst setupConnectionListeners = () => {\n  window.addEventListener('online', async () => {\n    console.log('Evento online detectado');\n    _isOnline = await isOnline();\n    if (_isOnline) {\n      console.log('Conexi√≥n a Internet restablecida');\n      // Sincronizar cuando se recupera la conexi√≥n\n      syncData();\n    }\n  });\n  window.addEventListener('offline', () => {\n    console.log('Evento offline detectado');\n    _isOnline = false;\n    console.log('Conexi√≥n a Internet perdida');\n  });\n\n  // Verificar estado inicial\n  isOnline().then(online => {\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\n  });\n};\n\n// Crear versi√≥n minimalista de un plato para sincronizaci√≥n de emergencia\nconst createMinimalPlato = plato => {\n  return {\n    id: plato.id,\n    name: plato.name?.substring(0, 50) || 'Plato sin nombre',\n    price: Number(plato.price) || 0,\n    description: (plato.description?.substring(0, 100) || '') + '...',\n    includesDrink: Boolean(plato.includesDrink),\n    availableQuantity: Number(plato.availableQuantity) || 0,\n    is_available: true,\n    createdAt: plato.createdAt || new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    minimal_sync: true // Marca para indicar que es una versi√≥n minimalista\n  };\n};\n\n// Verificar si el servidor est√° realmente disponible\nconst checkServerAvailability = async () => {\n  try {\n    // Intentar una petici√≥n simple para verificar disponibilidad\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n    const response = await fetch(`${API_URL}/health`, {\n      method: 'GET',\n      signal: controller.signal,\n      cache: 'no-store'\n    });\n    clearTimeout(timeoutId);\n    return response.ok;\n  } catch (error) {\n    console.warn('‚ö†Ô∏è Error al verificar disponibilidad del servidor:', error);\n    return false;\n  }\n};\n\n// Marcar un plato como problem√°tico para evitar intentos continuos\nconst markPlatoAsSyncProblematic = async platoId => {\n  try {\n    // Actualizar el estado del plato en IndexedDB\n    const db = await openDB();\n    const transaction = db.transaction([PLATOS_STORE], 'readwrite');\n    const store = transaction.objectStore(PLATOS_STORE);\n\n    // Obtener el plato\n    const getRequest = store.get(platoId);\n    return new Promise((resolve, reject) => {\n      getRequest.onsuccess = event => {\n        const plato = event.target.result;\n        if (!plato) {\n          reject(new Error(`Plato ID ${platoId} no encontrado`));\n          return;\n        }\n\n        // Marcar como problem√°tico y cambiar estado de sincronizaci√≥n\n        plato.sync_problematic = true;\n        plato.syncStatus = 'sync_error';\n        plato.lastSyncAttempt = new Date().toISOString();\n\n        // Guardar los cambios\n        const updateRequest = store.put(plato);\n        updateRequest.onsuccess = () => {\n          console.log(`‚úÖ Plato ID ${platoId} marcado como problem√°tico para sincronizaci√≥n`);\n          resolve(true);\n        };\n        updateRequest.onerror = event => {\n          reject(new Error(`Error al actualizar plato: ${event.target.error}`));\n        };\n      };\n      getRequest.onerror = event => {\n        reject(new Error(`Error al obtener plato: ${event.target.error}`));\n      };\n    });\n  } catch (error) {\n    console.error('‚ùå Error al marcar plato como problem√°tico:', error);\n    throw error;\n  }\n};\n\n// M√©todo alternativo de sincronizaci√≥n con opciones m√°s resilientes\nconst syncPlatoUsingAlternativeMethod = async (preparedPlato, platoId, retryCount = 0) => {\n  const maxRetries = 3;\n  try {\n    console.log('üì° Usando m√©todo alternativo de sincronizaci√≥n...');\n\n    // Usar XMLHttpRequest para mayor control sobre la conexi√≥n\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n\n      // Configurar timeout largo\n      xhr.timeout = 60000; // 60 segundos\n\n      xhr.onreadystatechange = async function () {\n        if (xhr.readyState === 4) {\n          if (xhr.status >= 200 && xhr.status < 300) {\n            console.log('‚úÖ Sincronizaci√≥n exitosa usando m√©todo alternativo');\n            try {\n              // Actualizar estado en la base de datos\n              await updatePlatoSyncStatus(platoId, 'synced');\n            } catch (dbError) {\n              console.error('‚ö†Ô∏è Error al actualizar estado en BD:', dbError);\n            }\n            resolve(true);\n          } else {\n            console.error(`‚ùå Error en sincronizaci√≥n alternativa: ${xhr.status}`);\n\n            // Si hay error 500 y a√∫n tenemos reintentos\n            if (xhr.status === 500 && retryCount < maxRetries) {\n              console.warn(`‚ö†Ô∏è Reintentando (${retryCount + 1}/${maxRetries})...`);\n\n              // Espera exponencial entre reintentos\n              setTimeout(async () => {\n                try {\n                  const result = await syncPlatoUsingAlternativeMethod(preparedPlato, platoId, retryCount + 1);\n                  resolve(result);\n                } catch (retryError) {\n                  reject(retryError);\n                }\n              }, 5000 * Math.pow(2, retryCount));\n            } else {\n              reject(new Error(`Error HTTP: ${xhr.status}`));\n            }\n          }\n        }\n      };\n      xhr.ontimeout = function () {\n        console.error('‚ùå Timeout en la solicitud alternativa');\n        reject(new Error('Timeout en la solicitud'));\n      };\n      xhr.onerror = function () {\n        console.error('‚ùå Error de red en solicitud alternativa');\n\n        // Reintento con backoff si todav√≠a hay intentos disponibles\n        if (retryCount < maxRetries) {\n          console.warn(`‚ö†Ô∏è Error de red, reintentando (${retryCount + 1}/${maxRetries})...`);\n          setTimeout(async () => {\n            try {\n              const result = await syncPlatoUsingAlternativeMethod(preparedPlato, platoId, retryCount + 1);\n              resolve(result);\n            } catch (retryError) {\n              reject(retryError);\n            }\n          }, 5000 * Math.pow(2, retryCount));\n        } else {\n          reject(new Error('Error de red persistente'));\n        }\n      };\n\n      // Abrir conexi√≥n con m√©todo POST\n      xhr.open('POST', `${API_URL}/platos`, true);\n\n      // Establecer headers\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      // Enviar los datos\n      xhr.send(JSON.stringify(preparedPlato));\n    });\n  } catch (error) {\n    console.error('‚ùå Error en m√©todo alternativo de sincronizaci√≥n:', error);\n    throw error;\n  }\n};\n\n// Sincronizar un plato con el servidor\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\n  const maxRetries = 3; // N√∫mero m√°ximo de reintentos\n\n  // Si el plato est√° marcado como problem√°tico, omitirlo\n  if (plato.sync_problematic) {\n    console.warn(`‚ö†Ô∏è Omitiendo plato ${plato.id} marcado como problem√°tico para sincronizaci√≥n`);\n    return false;\n  }\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\n  try {\n    // Verificar si el servidor est√° realmente disponible antes de intentar sincronizar\n    if (!(await checkServerAvailability())) {\n      console.error('‚ùå El servidor no est√° disponible. Posponiendo sincronizaci√≥n.');\n      return false;\n    }\n\n    // Preparar el plato para sincronizaci√≥n (reducir tama√±o de im√°genes, etc.)\n    let preparedPlato;\n    try {\n      preparedPlato = preparePlatoForSync(plato);\n    } catch (prepError) {\n      console.error('‚ùå Error al preparar plato para sincronizaci√≥n:', prepError);\n\n      // Si hay un error en la preparaci√≥n, intentar con una versi√≥n minimalista\n      preparedPlato = createMinimalPlato(plato);\n    }\n\n    // Verificar el tama√±o final del objeto serializado\n    const platoJsonString = JSON.stringify(preparedPlato);\n    const platoSize = platoJsonString.length;\n    console.log(`üìä Tama√±o de datos a enviar: ${platoSize} bytes`);\n\n    // Verificar si el tama√±o es razonable - ser mucho m√°s estricto\n    if (platoSize > 100000) {\n      // 100KB m√°ximo\n      console.error(`‚ùå ERROR: Datos demasiado grandes (${platoSize} bytes). Usando versi√≥n minimal.`);\n      preparedPlato = createMinimalPlato(plato);\n    }\n\n    // Usar m√©todo alternativo de sincronizaci√≥n\n    return await syncPlatoUsingAlternativeMethod(preparedPlato, plato.id, retryCount);\n  } catch (error) {\n    console.error('‚ùå Error general al sincronizar plato con el servidor:', error);\n\n    // Si hemos agotado los reintentos o es un error que no debemos reintentar\n    if (retryCount >= maxRetries) {\n      console.warn('‚ö†Ô∏è No se pudo sincronizar despu√©s de m√∫ltiples intentos');\n\n      // Marcar el plato como problem√°tico para evitar intentos continuos\n      try {\n        await markPlatoAsSyncProblematic(plato.id);\n      } catch (updateError) {\n        console.error('Error al marcar plato como problem√°tico:', updateError);\n      }\n    }\n    return false;\n  }\n};\n\n// Procesar la cola de sincronizaci√≥n\nconst processSyncQueue = async () => {\n  if (!(await isOnline()) || isSyncing) {\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\n    return false;\n  }\n  isSyncing = true;\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\n  try {\n    const syncItems = await getSyncQueue();\n    if (syncItems.length === 0) {\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\n      isSyncing = false;\n      return true;\n    }\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\n\n    // Procesar cada elemento de la cola\n    for (const item of syncItems) {\n      let syncSuccess = false;\n      if (item.type === 'create' && item.entityType === 'plato') {\n        syncSuccess = await syncPlatoToServer(item.data);\n      }\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\n\n      if (syncSuccess) {\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\n        await removeFromSyncQueue(item.id);\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\n      } else {\n        // Corregir el error de sintaxis aqu√≠:\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\n      }\n    }\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\n    return true;\n  } catch (error) {\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\n    return false;\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Funci√≥n principal para sincronizar datos\nconst syncData = async () => {\n  if (!(await isOnline())) {\n    console.log('Sin conexi√≥n a Internet, la sincronizaci√≥n no es posible');\n    return false;\n  }\n  try {\n    console.log('Iniciando sincronizaci√≥n de datos...');\n\n    // Procesar la cola de sincronizaci√≥n\n    await processSyncQueue();\n\n    // Sincronizar platos pendientes que no est√©n en la cola\n    const pendingPlatos = await getPendingPlatos();\n    console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\n    for (const plato of pendingPlatos) {\n      await syncPlatoToServer(plato);\n    }\n    console.log('Sincronizaci√≥n completada con √©xito');\n    return true;\n  } catch (error) {\n    console.error('Error durante la sincronizaci√≥n:', error);\n    return false;\n  }\n};\n\n// Inicializar el servicio de sincronizaci√≥n\nconst initSyncService = () => {\n  // Configurar escuchas para eventos de conexi√≥n\n  setupConnectionListeners();\n\n  // Realizar sincronizaci√≥n inicial si hay conexi√≥n\n  isOnline().then(online => {\n    if (online) {\n      syncData();\n    }\n  });\n\n  // Configurar sincronizaci√≥n peri√≥dica (cada minuto)\n  setInterval(async () => {\n    if ((await isOnline()) && !isSyncing) {\n      syncData();\n    }\n  }, 60000);\n  console.log('Servicio de sincronizaci√≥n inicializado');\n};\nexport { initSyncService, syncData, isOnline, _isOnline };","map":{"version":3,"names":["getPendingPlatos","updatePlatoSyncStatus","getSyncQueue","removeFromSyncQueue","preparePlatoForSync","openDB","PLATOS_STORE","API_URL","isSyncing","_isOnline","navigator","onLine","isOnline","response","fetch","method","mode","cache","credentials","error","console","setupConnectionListeners","window","addEventListener","log","syncData","then","online","createMinimalPlato","plato","id","name","substring","price","Number","description","includesDrink","Boolean","availableQuantity","is_available","createdAt","Date","toISOString","updatedAt","minimal_sync","checkServerAvailability","controller","AbortController","timeoutId","setTimeout","abort","signal","clearTimeout","ok","warn","markPlatoAsSyncProblematic","platoId","db","transaction","store","objectStore","getRequest","get","Promise","resolve","reject","onsuccess","event","target","result","Error","sync_problematic","syncStatus","lastSyncAttempt","updateRequest","put","onerror","syncPlatoUsingAlternativeMethod","preparedPlato","retryCount","maxRetries","xhr","XMLHttpRequest","timeout","onreadystatechange","readyState","status","dbError","retryError","Math","pow","ontimeout","open","setRequestHeader","send","JSON","stringify","syncPlatoToServer","prepError","platoJsonString","platoSize","length","updateError","processSyncQueue","syncItems","item","syncSuccess","type","entityType","data","pendingPlatos","initSyncService","setInterval"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/syncService.js"],"sourcesContent":["// src/services/syncService.js\r\n\r\n// Servicio para gestionar la sincronizaci√≥n y el estado de la conexi√≥n\r\nimport { \r\n  getPendingPlatos, \r\n  updatePlatoSyncStatus, \r\n  getSyncQueue, \r\n  removeFromSyncQueue,\r\n  preparePlatoForSync,\r\n  openDB\r\n} from './indexedDBService';\r\n\r\n// Constantes desde el servicio IndexedDB\r\nconst PLATOS_STORE = 'platos';\r\nconst API_URL = 'http://localhost:3000/api';\r\n\r\n// Estado de la sincronizaci√≥n\r\nlet isSyncing = false;\r\nlet _isOnline = navigator.onLine;\r\n\r\n// Alternativa m√°s simple para verificar la conexi√≥n\r\nconst isOnline = async () => {\r\n  // Primero comprobamos el estado de navigator.onLine\r\n  if (!navigator.onLine) {\r\n    return false;\r\n  }\r\n  \r\n  // Intentamos hacer un fetch a un recurso peque√±o (como un favicon)\r\n  try {\r\n    const response = await fetch(`${API_URL}/favicon.ico`, {\r\n      method: 'HEAD', // Solo pedimos las cabeceras, no el contenido\r\n      mode: 'no-cors', // Modo no-cors para evitar problemas de CORS\r\n      cache: 'no-store',\r\n      credentials: 'omit'\r\n    });\r\n    \r\n    return true; // Si no hay excepci√≥n, asumimos que estamos en l√≠nea\r\n  } catch (error) {\r\n    console.error('Error al verificar estado de conexi√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Configurar escuchas para eventos de conexi√≥n\r\nconst setupConnectionListeners = () => {\r\n  window.addEventListener('online', async () => {\r\n    console.log('Evento online detectado');\r\n    _isOnline = await isOnline();\r\n    if (_isOnline) {\r\n      console.log('Conexi√≥n a Internet restablecida');\r\n      // Sincronizar cuando se recupera la conexi√≥n\r\n      syncData();\r\n    }\r\n  });\r\n  \r\n  window.addEventListener('offline', () => {\r\n    console.log('Evento offline detectado');\r\n    _isOnline = false;\r\n    console.log('Conexi√≥n a Internet perdida');\r\n  });\r\n  \r\n  // Verificar estado inicial\r\n  isOnline().then(online => {\r\n    console.log(`Estado inicial de conexi√≥n: ${online ? 'En l√≠nea' : 'Fuera de l√≠nea'}`);\r\n  });\r\n};\r\n\r\n// Crear versi√≥n minimalista de un plato para sincronizaci√≥n de emergencia\r\nconst createMinimalPlato = (plato) => {\r\n  return {\r\n    id: plato.id,\r\n    name: plato.name?.substring(0, 50) || 'Plato sin nombre',\r\n    price: Number(plato.price) || 0,\r\n    description: (plato.description?.substring(0, 100) || '') + '...',\r\n    includesDrink: Boolean(plato.includesDrink),\r\n    availableQuantity: Number(plato.availableQuantity) || 0,\r\n    is_available: true,\r\n    createdAt: plato.createdAt || new Date().toISOString(),\r\n    updatedAt: new Date().toISOString(),\r\n    minimal_sync: true  // Marca para indicar que es una versi√≥n minimalista\r\n  };\r\n};\r\n\r\n// Verificar si el servidor est√° realmente disponible\r\nconst checkServerAvailability = async () => {\r\n  try {\r\n    // Intentar una petici√≥n simple para verificar disponibilidad\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\r\n    \r\n    const response = await fetch(`${API_URL}/health`, {\r\n      method: 'GET',\r\n      signal: controller.signal,\r\n      cache: 'no-store'\r\n    });\r\n    \r\n    clearTimeout(timeoutId);\r\n    return response.ok;\r\n  } catch (error) {\r\n    console.warn('‚ö†Ô∏è Error al verificar disponibilidad del servidor:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Marcar un plato como problem√°tico para evitar intentos continuos\r\nconst markPlatoAsSyncProblematic = async (platoId) => {\r\n  try {\r\n    // Actualizar el estado del plato en IndexedDB\r\n    const db = await openDB();\r\n    const transaction = db.transaction([PLATOS_STORE], 'readwrite');\r\n    const store = transaction.objectStore(PLATOS_STORE);\r\n    \r\n    // Obtener el plato\r\n    const getRequest = store.get(platoId);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      getRequest.onsuccess = (event) => {\r\n        const plato = event.target.result;\r\n        \r\n        if (!plato) {\r\n          reject(new Error(`Plato ID ${platoId} no encontrado`));\r\n          return;\r\n        }\r\n        \r\n        // Marcar como problem√°tico y cambiar estado de sincronizaci√≥n\r\n        plato.sync_problematic = true;\r\n        plato.syncStatus = 'sync_error';\r\n        plato.lastSyncAttempt = new Date().toISOString();\r\n        \r\n        // Guardar los cambios\r\n        const updateRequest = store.put(plato);\r\n        \r\n        updateRequest.onsuccess = () => {\r\n          console.log(`‚úÖ Plato ID ${platoId} marcado como problem√°tico para sincronizaci√≥n`);\r\n          resolve(true);\r\n        };\r\n        \r\n        updateRequest.onerror = (event) => {\r\n          reject(new Error(`Error al actualizar plato: ${event.target.error}`));\r\n        };\r\n      };\r\n      \r\n      getRequest.onerror = (event) => {\r\n        reject(new Error(`Error al obtener plato: ${event.target.error}`));\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('‚ùå Error al marcar plato como problem√°tico:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// M√©todo alternativo de sincronizaci√≥n con opciones m√°s resilientes\r\nconst syncPlatoUsingAlternativeMethod = async (preparedPlato, platoId, retryCount = 0) => {\r\n  const maxRetries = 3;\r\n  \r\n  try {\r\n    console.log('üì° Usando m√©todo alternativo de sincronizaci√≥n...');\r\n    \r\n    // Usar XMLHttpRequest para mayor control sobre la conexi√≥n\r\n    return new Promise((resolve, reject) => {\r\n      const xhr = new XMLHttpRequest();\r\n      \r\n      // Configurar timeout largo\r\n      xhr.timeout = 60000; // 60 segundos\r\n      \r\n      xhr.onreadystatechange = async function() {\r\n        if (xhr.readyState === 4) {\r\n          if (xhr.status >= 200 && xhr.status < 300) {\r\n            console.log('‚úÖ Sincronizaci√≥n exitosa usando m√©todo alternativo');\r\n            \r\n            try {\r\n              // Actualizar estado en la base de datos\r\n              await updatePlatoSyncStatus(platoId, 'synced');\r\n            } catch (dbError) {\r\n              console.error('‚ö†Ô∏è Error al actualizar estado en BD:', dbError);\r\n            }\r\n            \r\n            resolve(true);\r\n          } else {\r\n            console.error(`‚ùå Error en sincronizaci√≥n alternativa: ${xhr.status}`);\r\n            \r\n            // Si hay error 500 y a√∫n tenemos reintentos\r\n            if (xhr.status === 500 && retryCount < maxRetries) {\r\n              console.warn(`‚ö†Ô∏è Reintentando (${retryCount+1}/${maxRetries})...`);\r\n              \r\n              // Espera exponencial entre reintentos\r\n              setTimeout(async () => {\r\n                try {\r\n                  const result = await syncPlatoUsingAlternativeMethod(\r\n                    preparedPlato, platoId, retryCount + 1\r\n                  );\r\n                  resolve(result);\r\n                } catch (retryError) {\r\n                  reject(retryError);\r\n                }\r\n              }, 5000 * Math.pow(2, retryCount));\r\n            } else {\r\n              reject(new Error(`Error HTTP: ${xhr.status}`));\r\n            }\r\n          }\r\n        }\r\n      };\r\n      \r\n      xhr.ontimeout = function() {\r\n        console.error('‚ùå Timeout en la solicitud alternativa');\r\n        reject(new Error('Timeout en la solicitud'));\r\n      };\r\n      \r\n      xhr.onerror = function() {\r\n        console.error('‚ùå Error de red en solicitud alternativa');\r\n        \r\n        // Reintento con backoff si todav√≠a hay intentos disponibles\r\n        if (retryCount < maxRetries) {\r\n          console.warn(`‚ö†Ô∏è Error de red, reintentando (${retryCount+1}/${maxRetries})...`);\r\n          \r\n          setTimeout(async () => {\r\n            try {\r\n              const result = await syncPlatoUsingAlternativeMethod(\r\n                preparedPlato, platoId, retryCount + 1\r\n              );\r\n              resolve(result);\r\n            } catch (retryError) {\r\n              reject(retryError);\r\n            }\r\n          }, 5000 * Math.pow(2, retryCount));\r\n        } else {\r\n          reject(new Error('Error de red persistente'));\r\n        }\r\n      };\r\n      \r\n      // Abrir conexi√≥n con m√©todo POST\r\n      xhr.open('POST', `${API_URL}/platos`, true);\r\n      \r\n      // Establecer headers\r\n      xhr.setRequestHeader('Content-Type', 'application/json');\r\n      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\r\n      \r\n      // Enviar los datos\r\n      xhr.send(JSON.stringify(preparedPlato));\r\n    });\r\n  } catch (error) {\r\n    console.error('‚ùå Error en m√©todo alternativo de sincronizaci√≥n:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Sincronizar un plato con el servidor\r\nconst syncPlatoToServer = async (plato, retryCount = 0) => {\r\n  const maxRetries = 3; // N√∫mero m√°ximo de reintentos\r\n  \r\n  // Si el plato est√° marcado como problem√°tico, omitirlo\r\n  if (plato.sync_problematic) {\r\n    console.warn(`‚ö†Ô∏è Omitiendo plato ${plato.id} marcado como problem√°tico para sincronizaci√≥n`);\r\n    return false;\r\n  }\r\n  \r\n  console.log(`Sincronizando plato ${plato.id} con el servidor (intento ${retryCount + 1}/${maxRetries + 1})...`);\r\n  \r\n  try {\r\n    // Verificar si el servidor est√° realmente disponible antes de intentar sincronizar\r\n    if (!(await checkServerAvailability())) {\r\n      console.error('‚ùå El servidor no est√° disponible. Posponiendo sincronizaci√≥n.');\r\n      return false;\r\n    }\r\n    \r\n    // Preparar el plato para sincronizaci√≥n (reducir tama√±o de im√°genes, etc.)\r\n    let preparedPlato;\r\n    try {\r\n      preparedPlato = preparePlatoForSync(plato);\r\n    } catch (prepError) {\r\n      console.error('‚ùå Error al preparar plato para sincronizaci√≥n:', prepError);\r\n      \r\n      // Si hay un error en la preparaci√≥n, intentar con una versi√≥n minimalista\r\n      preparedPlato = createMinimalPlato(plato);\r\n    }\r\n    \r\n    // Verificar el tama√±o final del objeto serializado\r\n    const platoJsonString = JSON.stringify(preparedPlato);\r\n    const platoSize = platoJsonString.length;\r\n    \r\n    console.log(`üìä Tama√±o de datos a enviar: ${platoSize} bytes`);\r\n    \r\n    // Verificar si el tama√±o es razonable - ser mucho m√°s estricto\r\n    if (platoSize > 100000) { // 100KB m√°ximo\r\n      console.error(`‚ùå ERROR: Datos demasiado grandes (${platoSize} bytes). Usando versi√≥n minimal.`);\r\n      preparedPlato = createMinimalPlato(plato);\r\n    }\r\n    \r\n    // Usar m√©todo alternativo de sincronizaci√≥n\r\n    return await syncPlatoUsingAlternativeMethod(preparedPlato, plato.id, retryCount);\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Error general al sincronizar plato con el servidor:', error);\r\n    \r\n    // Si hemos agotado los reintentos o es un error que no debemos reintentar\r\n    if (retryCount >= maxRetries) {\r\n      console.warn('‚ö†Ô∏è No se pudo sincronizar despu√©s de m√∫ltiples intentos');\r\n      \r\n      // Marcar el plato como problem√°tico para evitar intentos continuos\r\n      try {\r\n        await markPlatoAsSyncProblematic(plato.id);\r\n      } catch (updateError) {\r\n        console.error('Error al marcar plato como problem√°tico:', updateError);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n};\r\n\r\n// Procesar la cola de sincronizaci√≥n\r\nconst processSyncQueue = async () => {\r\n  if (!await isOnline() || isSyncing) {\r\n    console.log(`No se puede procesar la cola. En l√≠nea: ${_isOnline}, Sincronizando: ${isSyncing}`);\r\n    return false;\r\n  }\r\n  \r\n  isSyncing = true;\r\n  console.log('Iniciando procesamiento de cola de sincronizaci√≥n...');\r\n  \r\n  try {\r\n    const syncItems = await getSyncQueue();\r\n    \r\n    if (syncItems.length === 0) {\r\n      console.log('No hay elementos en la cola de sincronizaci√≥n');\r\n      isSyncing = false;\r\n      return true;\r\n    }\r\n    \r\n    console.log(`Procesando ${syncItems.length} elementos en la cola de sincronizaci√≥n`);\r\n    \r\n    // Procesar cada elemento de la cola\r\n    for (const item of syncItems) {\r\n      let syncSuccess = false;\r\n      \r\n      if (item.type === 'create' && item.entityType === 'plato') {\r\n        syncSuccess = await syncPlatoToServer(item.data);\r\n      }\r\n      // Aqu√≠ pueden agregarse m√°s tipos de sincronizaci√≥n seg√∫n sea necesario\r\n      \r\n      if (syncSuccess) {\r\n        // Eliminar de la cola si la sincronizaci√≥n fue exitosa\r\n        await removeFromSyncQueue(item.id);\r\n        console.log(`Elemento ${item.id} eliminado de la cola de sincronizaci√≥n`);\r\n      } else {\r\n        // Corregir el error de sintaxis aqu√≠:\r\n        console.log(`No se pudo sincronizar el elemento ${item.id}, se reintentar√° m√°s tarde`);\r\n      }\r\n    }\r\n    \r\n    console.log('Procesamiento de cola de sincronizaci√≥n completado');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error al procesar cola de sincronizaci√≥n:', error);\r\n    return false;\r\n  } finally {\r\n    isSyncing = false;\r\n  }\r\n};\r\n\r\n// Funci√≥n principal para sincronizar datos\r\nconst syncData = async () => {\r\n  if (!await isOnline()) {\r\n    console.log('Sin conexi√≥n a Internet, la sincronizaci√≥n no es posible');\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    console.log('Iniciando sincronizaci√≥n de datos...');\r\n    \r\n    // Procesar la cola de sincronizaci√≥n\r\n    await processSyncQueue();\r\n    \r\n    // Sincronizar platos pendientes que no est√©n en la cola\r\n    const pendingPlatos = await getPendingPlatos();\r\n    console.log(`Encontrados ${pendingPlatos.length} platos pendientes de sincronizaci√≥n`);\r\n    \r\n    for (const plato of pendingPlatos) {\r\n      await syncPlatoToServer(plato);\r\n    }\r\n    \r\n    console.log('Sincronizaci√≥n completada con √©xito');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error durante la sincronizaci√≥n:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Inicializar el servicio de sincronizaci√≥n\r\nconst initSyncService = () => {\r\n  // Configurar escuchas para eventos de conexi√≥n\r\n  setupConnectionListeners();\r\n  \r\n  // Realizar sincronizaci√≥n inicial si hay conexi√≥n\r\n  isOnline().then(online => {\r\n    if (online) {\r\n      syncData();\r\n    }\r\n  });\r\n  \r\n  // Configurar sincronizaci√≥n peri√≥dica (cada minuto)\r\n  setInterval(async () => {\r\n    if (await isOnline() && !isSyncing) {\r\n      syncData();\r\n    }\r\n  }, 60000);\r\n  \r\n  console.log('Servicio de sincronizaci√≥n inicializado');\r\n};\r\n\r\nexport {\r\n  initSyncService,\r\n  syncData,\r\n  isOnline,\r\n  _isOnline\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}