{"ast":null,"code":"// src/services/platoService.js\n\nimport { savePlato, getAllPlatos, updatePlatoSyncStatus, deletePlato as deleteFromDB } from './indexedDBService';\nimport { isOnline } from './syncService';\nimport { adaptPlatoData } from '../utils/dataAdapters';\n\n// API URL ahora con puerto correcto\nconst API_URL = 'http://localhost:3000/api';\n\n// Crear un nuevo plato\nconst createPlato = async platoData => {\n  console.log('Datos originales recibidos:', platoData);\n\n  // Adaptar datos si es necesario\n  const adaptedData = adaptPlatoData(platoData);\n  console.log('Datos adaptados para creación:', adaptedData);\n  console.log('Estructura del objeto platoData:', Object.keys(platoData));\n  console.log('Tipo de datos de platoData:', typeof platoData);\n  try {\n    // Una sola verificación de conexión\n    const online = await isOnline();\n\n    // Si estamos en línea, intentamos guardar en el servidor\n    if (online) {\n      console.log('Conexión a internet detectada, intentando guardar en servidor...');\n      try {\n        const response = await fetch(`${API_URL}/platos`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(adaptedData)\n        });\n        console.log('Respuesta del servidor:', response.status);\n        if (response.ok) {\n          const data = await response.json();\n          console.log('Plato creado en el servidor:', data);\n          return data;\n        } else {\n          console.error(`Error del servidor: ${response.status}`);\n          const errorText = await response.text();\n          console.error('Detalles del error:', errorText);\n          // No lanzamos excepción, continuamos con guardado local\n          console.log('Continuando con guardado local debido a error del servidor...');\n        }\n      } catch (error) {\n        console.error('Error detallado al crear plato en el servidor:', error);\n        console.log('Continuando con guardado local debido a error de red...');\n      }\n    } else {\n      console.log('Sin conexión a internet, procediendo con guardado local...');\n    }\n\n    // Guardado local (tanto si estamos offline como si hubo error en el servidor)\n    console.log('Guardando plato en IndexedDB...');\n    const savedPlato = await savePlato(adaptedData);\n    console.log('Plato guardado localmente:', savedPlato);\n    console.log('Estructura final del platoToSave:', Object.keys(savedPlato));\n    return savedPlato;\n  } catch (error) {\n    console.error('Error detallado en createPlato:', error);\n    throw new Error('No se pudo crear el plato. Por favor intente nuevamente: ' + error.message);\n  }\n};\n\n// src/services/platoService.js (continuación)\n\n// Obtener todos los platos\nconst getPlatos = async () => {\n  console.log('Obteniendo platos...');\n  try {\n    // Intentamos obtener del servidor si hay conexión\n    if (await isOnline()) {\n      console.log('Conexión a internet detectada, intentando obtener del servidor...');\n      try {\n        const response = await fetch(`${API_URL}/platos`);\n        console.log('Respuesta del servidor:', response.status);\n        if (!response.ok) {\n          console.error(`Error del servidor: ${response.status}`);\n          throw new Error(`Error al obtener platos: ${response.status}`);\n        }\n        const data = await response.json();\n        console.log('Platos obtenidos del servidor:', data);\n        return data;\n      } catch (error) {\n        console.error('Error al obtener platos del servidor:', error);\n        console.log('Continuando con obtención local...');\n      }\n    } else {\n      console.log('Sin conexión a internet, obteniendo localmente...');\n    }\n\n    // Si no hay conexión o falló la petición al servidor, obtenemos de IndexedDB\n    console.log('Obteniendo platos de IndexedDB...');\n    const localPlatos = await getAllPlatos();\n    console.log('Platos obtenidos localmente:', localPlatos);\n    return localPlatos;\n  } catch (error) {\n    console.error('Error general al obtener platos:', error);\n    throw new Error('No se pudieron obtener los platos. Por favor intente nuevamente.');\n  }\n};\n\n// src/services/platoService.js (continuación)\n\n// Sincronizar platos pendientes con el servidor\nconst syncPlatosWithServer = async () => {\n  if (!(await isOnline())) {\n    console.log('Sin conexión a internet. Intentando más tarde...');\n    return;\n  }\n  console.log('Iniciando sincronización de platos con el servidor...');\n  try {\n    const platosLocales = await getAllPlatos(); // Obtener platos de IndexedDB\n\n    if (platosLocales.length === 0) {\n      console.log('No hay platos locales para sincronizar');\n      return;\n    }\n    console.log(`Sincronizando ${platosLocales.length} platos...`);\n    for (const plato of platosLocales) {\n      // Manejar platos pendientes para crear/actualizar\n      if (plato.syncStatus === 'pending') {\n        try {\n          console.log(`Sincronizando plato ID ${plato.id} (${plato.name})...`);\n          const response = await fetch(`${API_URL}/platos`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              name: plato.name,\n              description: plato.description,\n              price: plato.price,\n              category: plato.category,\n              image_url: plato.image_url,\n              is_available: plato.is_available\n            })\n          });\n          if (response.ok) {\n            const responseData = await response.json();\n            console.log(`Plato ID ${plato.id} sincronizado con éxito:`, responseData);\n\n            // Actualizar estado de sincronización en IndexedDB\n            await updatePlatoSyncStatus(plato.id, 'synced');\n          } else {\n            console.error(`Error al sincronizar plato ID ${plato.id}: ${response.status}`);\n            const errorText = await response.text();\n            console.error('Detalles del error:', errorText);\n          }\n        } catch (error) {\n          console.error(`Error de red al sincronizar plato ID ${plato.id}:`, error);\n        }\n      }\n      // Manejar platos pendientes para eliminación\n      else if (plato.syncStatus === 'pending_deletion') {\n        try {\n          console.log(`Sincronizando eliminación de plato ID ${plato.id} (${plato.name})...`);\n\n          // Si el plato tiene un ID de servidor, intentamos eliminarlo\n          if (plato.serverId) {\n            const response = await fetch(`${API_URL}/platos/${plato.serverId}`, {\n              method: 'DELETE'\n            });\n            if (response.ok) {\n              console.log(`Plato ID ${plato.id} eliminado del servidor con éxito`);\n              // Ahora podemos eliminarlo localmente\n              await deleteFromIndexedDB(plato.id);\n            } else {\n              console.error(`Error al eliminar plato ID ${plato.id} del servidor: ${response.status}`);\n              const errorText = await response.text();\n              console.error('Detalles del error:', errorText);\n            }\n          } else {\n            // Si no tiene ID de servidor, solo lo eliminamos localmente\n            console.log(`Plato ID ${plato.id} nunca se sincronizó con el servidor, eliminando localmente`);\n            await deleteFromIndexedDB(plato.id);\n          }\n        } catch (error) {\n          console.error(`Error de red al eliminar plato ID ${plato.id}:`, error);\n        }\n      } else {\n        console.log(`Plato ID ${plato.id} ya está sincronizado, omitiendo...`);\n      }\n    }\n    console.log('Sincronización completada');\n  } catch (error) {\n    console.error('Error general durante la sincronización:', error);\n  }\n};\n\n// src/services/platoService.js (continuación)\n\n// Mejorado para evitar múltiples intentos de sincronización simultáneos\nlet isSyncing = false;\nconst safeSync = async () => {\n  if (isSyncing) {\n    console.log('Ya hay una sincronización en progreso, omitiendo...');\n    return;\n  }\n  isSyncing = true;\n  try {\n    await syncPlatosWithServer();\n  } catch (error) {\n    console.error('Error en sincronización segura:', error);\n  } finally {\n    isSyncing = false;\n  }\n};\n\n// Configurar sincronización periódica con mejor manejo\nconst syncInterval = setInterval(safeSync, 60000); // Cada 60 segundos\n\n// Función para iniciar sincronización manual\nconst startManualSync = () => {\n  console.log('Iniciando sincronización manual...');\n  safeSync();\n};\n\n// Borrar un plato\nconst deletePlato = async id => {\n  console.log(`Iniciando borrado de plato ID ${id}...`);\n  try {\n    // Primero intentamos borrar en el servidor si hay conexión\n    if (await isOnline()) {\n      console.log('Conexión a internet detectada, intentando borrar en servidor...');\n      try {\n        const response = await fetch(`${API_URL}/platos/${id}`, {\n          method: 'DELETE'\n        });\n        if (!response.ok) {\n          console.error(`Error del servidor al borrar: ${response.status}`);\n          throw new Error(`Error al borrar plato: ${response.status}`);\n        }\n        console.log(`Plato ID ${id} borrado en el servidor`);\n\n        // Si se borró correctamente en el servidor, también lo borramos localmente\n        await deleteFromIndexedDB(id);\n        return true;\n      } catch (error) {\n        console.error('Error al borrar plato en el servidor:', error);\n        // Continuamos para marcarlo como pendiente de borrado localmente\n      }\n    }\n\n    // Si no hay conexión o falló el borrado en el servidor, lo marcamos como pendiente\n    console.log(`Marcando plato ID ${id} como pendiente de borrado...`);\n    await markPlatoForDeletion(id);\n    return true;\n  } catch (error) {\n    console.error('Error general al borrar plato:', error);\n    throw new Error('No se pudo borrar el plato. Por favor intente nuevamente.');\n  }\n};\n\n// Implementar la función deleteFromIndexedDB\nconst deleteFromIndexedDB = async id => {\n  console.log(`Eliminando plato ID ${id} de IndexedDB...`);\n  try {\n    await deleteFromDB(id); // Usar la función importada de indexedDBService\n    console.log(`Plato ID ${id} eliminado de IndexedDB`);\n    return true;\n  } catch (error) {\n    console.error(`Error al eliminar plato ID ${id} de IndexedDB:`, error);\n    throw error;\n  }\n};\n\n// Implementar la función markPlatoForDeletion\nconst markPlatoForDeletion = async id => {\n  console.log(`Marcando plato ID ${id} para eliminación futura...`);\n  try {\n    await updatePlatoSyncStatus(id, 'pending_deletion');\n    console.log(`Plato ID ${id} marcado para eliminación`);\n    return true;\n  } catch (error) {\n    console.error(`Error al marcar plato ID ${id} para eliminación:`, error);\n    throw error;\n  }\n};\n\n// Agregar función para detener la sincronización\nconst stopSync = () => {\n  if (syncInterval) {\n    clearInterval(syncInterval);\n    console.log('Sincronización periódica detenida');\n  }\n};\n\n// Exportar funciones\nexport { createPlato, getPlatos, syncPlatosWithServer, startManualSync, deletePlato, deleteFromIndexedDB, markPlatoForDeletion, stopSync };","map":{"version":3,"names":["savePlato","getAllPlatos","updatePlatoSyncStatus","deletePlato","deleteFromDB","isOnline","adaptPlatoData","API_URL","createPlato","platoData","console","log","adaptedData","Object","keys","online","response","fetch","method","headers","body","JSON","stringify","status","ok","data","json","error","errorText","text","savedPlato","Error","message","getPlatos","localPlatos","syncPlatosWithServer","platosLocales","length","plato","syncStatus","id","name","description","price","category","image_url","is_available","responseData","serverId","deleteFromIndexedDB","isSyncing","safeSync","syncInterval","setInterval","startManualSync","markPlatoForDeletion","stopSync","clearInterval"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/platoService.js"],"sourcesContent":["// src/services/platoService.js\r\n\r\nimport { savePlato, getAllPlatos, updatePlatoSyncStatus, deletePlato as deleteFromDB } from './indexedDBService';\r\nimport { isOnline } from './syncService';\r\nimport { adaptPlatoData } from '../utils/dataAdapters';\r\n\r\n// API URL ahora con puerto correcto\r\nconst API_URL = 'http://localhost:3000/api';\r\n\r\n// Crear un nuevo plato\r\nconst createPlato = async (platoData) => {\r\n  console.log('Datos originales recibidos:', platoData);\r\n  \r\n  // Adaptar datos si es necesario\r\n  const adaptedData = adaptPlatoData(platoData);\r\n  console.log('Datos adaptados para creación:', adaptedData);\r\n  \r\n  console.log('Estructura del objeto platoData:', Object.keys(platoData));\r\n  console.log('Tipo de datos de platoData:', typeof platoData);\r\n  \r\n  try {\r\n    // Una sola verificación de conexión\r\n    const online = await isOnline();\r\n    \r\n    // Si estamos en línea, intentamos guardar en el servidor\r\n    if (online) {\r\n      console.log('Conexión a internet detectada, intentando guardar en servidor...');\r\n      try {\r\n        const response = await fetch(`${API_URL}/platos`, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify(adaptedData)\r\n        });\r\n        \r\n        console.log('Respuesta del servidor:', response.status);\r\n        \r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          console.log('Plato creado en el servidor:', data);\r\n          return data;\r\n        } else {\r\n          console.error(`Error del servidor: ${response.status}`);\r\n          const errorText = await response.text();\r\n          console.error('Detalles del error:', errorText);\r\n          // No lanzamos excepción, continuamos con guardado local\r\n          console.log('Continuando con guardado local debido a error del servidor...');\r\n        }\r\n      } catch (error) {\r\n        console.error('Error detallado al crear plato en el servidor:', error);\r\n        console.log('Continuando con guardado local debido a error de red...');\r\n      }\r\n    } else {\r\n      console.log('Sin conexión a internet, procediendo con guardado local...');\r\n    }\r\n    \r\n    // Guardado local (tanto si estamos offline como si hubo error en el servidor)\r\n    console.log('Guardando plato en IndexedDB...');\r\n    const savedPlato = await savePlato(adaptedData);\r\n    console.log('Plato guardado localmente:', savedPlato);\r\n    console.log('Estructura final del platoToSave:', Object.keys(savedPlato));\r\n    return savedPlato;\r\n  } catch (error) {\r\n    console.error('Error detallado en createPlato:', error);\r\n    throw new Error('No se pudo crear el plato. Por favor intente nuevamente: ' + error.message);\r\n  }\r\n};\r\n\r\n// src/services/platoService.js (continuación)\r\n\r\n// Obtener todos los platos\r\nconst getPlatos = async () => {\r\n  console.log('Obteniendo platos...');\r\n  \r\n  try {\r\n    // Intentamos obtener del servidor si hay conexión\r\n    if (await isOnline()) {\r\n      console.log('Conexión a internet detectada, intentando obtener del servidor...');\r\n      try {\r\n        const response = await fetch(`${API_URL}/platos`);\r\n        \r\n        console.log('Respuesta del servidor:', response.status);\r\n        \r\n        if (!response.ok) {\r\n          console.error(`Error del servidor: ${response.status}`);\r\n          throw new Error(`Error al obtener platos: ${response.status}`);\r\n        }\r\n        \r\n        const data = await response.json();\r\n        console.log('Platos obtenidos del servidor:', data);\r\n        return data;\r\n      } catch (error) {\r\n        console.error('Error al obtener platos del servidor:', error);\r\n        console.log('Continuando con obtención local...');\r\n      }\r\n    } else {\r\n      console.log('Sin conexión a internet, obteniendo localmente...');\r\n    }\r\n    \r\n    // Si no hay conexión o falló la petición al servidor, obtenemos de IndexedDB\r\n    console.log('Obteniendo platos de IndexedDB...');\r\n    const localPlatos = await getAllPlatos();\r\n    console.log('Platos obtenidos localmente:', localPlatos);\r\n    return localPlatos;\r\n  } catch (error) {\r\n    console.error('Error general al obtener platos:', error);\r\n    throw new Error('No se pudieron obtener los platos. Por favor intente nuevamente.');\r\n  }\r\n};\r\n\r\n// src/services/platoService.js (continuación)\r\n\r\n// Sincronizar platos pendientes con el servidor\r\nconst syncPlatosWithServer = async () => {\r\n  if (!await isOnline()) {\r\n    console.log('Sin conexión a internet. Intentando más tarde...');\r\n    return;\r\n  }\r\n\r\n  console.log('Iniciando sincronización de platos con el servidor...');\r\n  \r\n  try {\r\n    const platosLocales = await getAllPlatos(); // Obtener platos de IndexedDB\r\n    \r\n    if (platosLocales.length === 0) {\r\n      console.log('No hay platos locales para sincronizar');\r\n      return;\r\n    }\r\n    \r\n    console.log(`Sincronizando ${platosLocales.length} platos...`);\r\n\r\n    for (const plato of platosLocales) {\r\n      // Manejar platos pendientes para crear/actualizar\r\n      if (plato.syncStatus === 'pending') {\r\n        try {\r\n          console.log(`Sincronizando plato ID ${plato.id} (${plato.name})...`);\r\n          \r\n          const response = await fetch(`${API_URL}/platos`, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n              name: plato.name,\r\n              description: plato.description,\r\n              price: plato.price,\r\n              category: plato.category,\r\n              image_url: plato.image_url,\r\n              is_available: plato.is_available\r\n            })\r\n          });\r\n\r\n          if (response.ok) {\r\n            const responseData = await response.json();\r\n            console.log(`Plato ID ${plato.id} sincronizado con éxito:`, responseData);\r\n            \r\n            // Actualizar estado de sincronización en IndexedDB\r\n            await updatePlatoSyncStatus(plato.id, 'synced');\r\n          } else {\r\n            console.error(`Error al sincronizar plato ID ${plato.id}: ${response.status}`);\r\n            const errorText = await response.text();\r\n            console.error('Detalles del error:', errorText);\r\n          }\r\n        } catch (error) {\r\n          console.error(`Error de red al sincronizar plato ID ${plato.id}:`, error);\r\n        }\r\n      } \r\n      // Manejar platos pendientes para eliminación\r\n      else if (plato.syncStatus === 'pending_deletion') {\r\n        try {\r\n          console.log(`Sincronizando eliminación de plato ID ${plato.id} (${plato.name})...`);\r\n          \r\n          // Si el plato tiene un ID de servidor, intentamos eliminarlo\r\n          if (plato.serverId) {\r\n            const response = await fetch(`${API_URL}/platos/${plato.serverId}`, {\r\n              method: 'DELETE'\r\n            });\r\n            \r\n            if (response.ok) {\r\n              console.log(`Plato ID ${plato.id} eliminado del servidor con éxito`);\r\n              // Ahora podemos eliminarlo localmente\r\n              await deleteFromIndexedDB(plato.id);\r\n            } else {\r\n              console.error(`Error al eliminar plato ID ${plato.id} del servidor: ${response.status}`);\r\n              const errorText = await response.text();\r\n              console.error('Detalles del error:', errorText);\r\n            }\r\n          } else {\r\n            // Si no tiene ID de servidor, solo lo eliminamos localmente\r\n            console.log(`Plato ID ${plato.id} nunca se sincronizó con el servidor, eliminando localmente`);\r\n            await deleteFromIndexedDB(plato.id);\r\n          }\r\n        } catch (error) {\r\n          console.error(`Error de red al eliminar plato ID ${plato.id}:`, error);\r\n        }\r\n      } else {\r\n        console.log(`Plato ID ${plato.id} ya está sincronizado, omitiendo...`);\r\n      }\r\n    }\r\n    \r\n    console.log('Sincronización completada');\r\n  } catch (error) {\r\n    console.error('Error general durante la sincronización:', error);\r\n  }\r\n};\r\n\r\n// src/services/platoService.js (continuación)\r\n\r\n// Mejorado para evitar múltiples intentos de sincronización simultáneos\r\nlet isSyncing = false;\r\nconst safeSync = async () => {\r\n  if (isSyncing) {\r\n    console.log('Ya hay una sincronización en progreso, omitiendo...');\r\n    return;\r\n  }\r\n  \r\n  isSyncing = true;\r\n  try {\r\n    await syncPlatosWithServer();\r\n  } catch (error) {\r\n    console.error('Error en sincronización segura:', error);\r\n  } finally {\r\n    isSyncing = false;\r\n  }\r\n};\r\n\r\n// Configurar sincronización periódica con mejor manejo\r\nconst syncInterval = setInterval(safeSync, 60000); // Cada 60 segundos\r\n\r\n// Función para iniciar sincronización manual\r\nconst startManualSync = () => {\r\n  console.log('Iniciando sincronización manual...');\r\n  safeSync();\r\n};\r\n\r\n// Borrar un plato\r\nconst deletePlato = async (id) => {\r\n  console.log(`Iniciando borrado de plato ID ${id}...`);\r\n  \r\n  try {\r\n    // Primero intentamos borrar en el servidor si hay conexión\r\n    if (await isOnline()) {\r\n      console.log('Conexión a internet detectada, intentando borrar en servidor...');\r\n      try {\r\n        const response = await fetch(`${API_URL}/platos/${id}`, {\r\n          method: 'DELETE'\r\n        });\r\n        \r\n        if (!response.ok) {\r\n          console.error(`Error del servidor al borrar: ${response.status}`);\r\n          throw new Error(`Error al borrar plato: ${response.status}`);\r\n        }\r\n        \r\n        console.log(`Plato ID ${id} borrado en el servidor`);\r\n        \r\n        // Si se borró correctamente en el servidor, también lo borramos localmente\r\n        await deleteFromIndexedDB(id);\r\n        \r\n        return true;\r\n      } catch (error) {\r\n        console.error('Error al borrar plato en el servidor:', error);\r\n        // Continuamos para marcarlo como pendiente de borrado localmente\r\n      }\r\n    }\r\n    \r\n    // Si no hay conexión o falló el borrado en el servidor, lo marcamos como pendiente\r\n    console.log(`Marcando plato ID ${id} como pendiente de borrado...`);\r\n    await markPlatoForDeletion(id);\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error general al borrar plato:', error);\r\n    throw new Error('No se pudo borrar el plato. Por favor intente nuevamente.');\r\n  }\r\n};\r\n\r\n// Implementar la función deleteFromIndexedDB\r\nconst deleteFromIndexedDB = async (id) => {\r\n  console.log(`Eliminando plato ID ${id} de IndexedDB...`);\r\n  try {\r\n    await deleteFromDB(id); // Usar la función importada de indexedDBService\r\n    console.log(`Plato ID ${id} eliminado de IndexedDB`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`Error al eliminar plato ID ${id} de IndexedDB:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Implementar la función markPlatoForDeletion\r\nconst markPlatoForDeletion = async (id) => {\r\n  console.log(`Marcando plato ID ${id} para eliminación futura...`);\r\n  try {\r\n    await updatePlatoSyncStatus(id, 'pending_deletion');\r\n    console.log(`Plato ID ${id} marcado para eliminación`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(`Error al marcar plato ID ${id} para eliminación:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Agregar función para detener la sincronización\r\nconst stopSync = () => {\r\n  if (syncInterval) {\r\n    clearInterval(syncInterval);\r\n    console.log('Sincronización periódica detenida');\r\n  }\r\n};\r\n\r\n// Exportar funciones\r\nexport {\r\n  createPlato,\r\n  getPlatos,\r\n  syncPlatosWithServer,\r\n  startManualSync,\r\n  deletePlato,\r\n  deleteFromIndexedDB,\r\n  markPlatoForDeletion,\r\n  stopSync\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}