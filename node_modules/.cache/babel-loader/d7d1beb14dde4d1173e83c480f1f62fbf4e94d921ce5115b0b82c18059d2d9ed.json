{"ast":null,"code":"const DB_NAME = 'websapDatabase';\nconst DB_VERSION = 1;\nconst USERS_STORE = 'users';\n\n// Abrir la conexión a la base de datos\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      reject('Error al abrir la base de datos: ' + event.target.errorCode);\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n\n      // Crear almacén para usuarios si no existe\n      if (!db.objectStoreNames.contains(USERS_STORE)) {\n        db.createObjectStore(USERS_STORE, {\n          keyPath: 'id'\n        });\n      }\n    };\n  });\n}\n\n/**\r\n * Obtiene la lista de usuarios desde IndexedDB\r\n * @returns {Promise<Array>} - Lista de usuarios\r\n */\nexport async function getUsersFromDB() {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([USERS_STORE], 'readonly');\n    const store = transaction.objectStore(USERS_STORE);\n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => {\n        resolve(request.result || []);\n      };\n      request.onerror = event => {\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al obtener usuarios de IndexedDB:', error);\n    return []; // Devolver array vacío en caso de error\n  }\n}\n\n/**\r\n * Guardar un único usuario en IndexedDB\r\n * @param {Object} user - El usuario a guardar\r\n * @returns {Promise<boolean>} - Éxito de la operación\r\n */\nexport async function saveUserToDB(user) {\n  try {\n    if (!user || typeof user !== 'object') {\n      throw new Error('Se requiere un objeto de usuario válido');\n    }\n\n    // Crear un nuevo objeto con solo las propiedades necesarias\n    // Esto evita propiedades no serializables o referencias circulares\n    const cleanUser = {\n      id: String(user.id || Date.now()),\n      name: String(user.name || ''),\n      email: String(user.email || ''),\n      password: String(user.password || '')\n    };\n\n    // Verificar que el objeto es serializable\n    try {\n      // Intentar serializar a JSON y deserializar para verificar\n      const testSerialize = JSON.parse(JSON.stringify(cleanUser));\n\n      // Si hay diferencias entre el original y el deserializado, hay un problema\n      if (testSerialize.id !== cleanUser.id || testSerialize.name !== cleanUser.name || testSerialize.email !== cleanUser.email || testSerialize.password !== cleanUser.password) {\n        console.warn('Posible problema de serialización con el usuario:', cleanUser);\n      }\n    } catch (e) {\n      console.error('Error al verificar serializabilidad del usuario:', e);\n      throw new Error('El objeto usuario no es serializable para IndexedDB');\n    }\n    const db = await openDatabase();\n    const transaction = db.transaction([USERS_STORE], 'readwrite');\n    const store = transaction.objectStore(USERS_STORE);\n    return new Promise((resolve, reject) => {\n      const addRequest = store.add(cleanUser);\n      addRequest.onsuccess = () => {\n        resolve(true);\n      };\n      addRequest.onerror = event => {\n        console.error('Error específico al guardar usuario:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar usuario único en IndexedDB:', error);\n    throw error; // Propagar el error para que se maneje en el componente\n  }\n}\n\n/**\r\n * Guardar múltiples usuarios en IndexedDB\r\n * @param {Array} users - Lista de usuarios a guardar\r\n * @returns {Promise<boolean>} - Éxito de la operación\r\n */\nexport async function saveUsersToDB(users) {\n  if (!Array.isArray(users)) {\n    throw new Error('La lista de usuarios debe ser un array');\n  }\n  try {\n    // Guardar cada usuario individualmente para mayor control\n    for (const user of users) {\n      await saveUserToDB(user);\n    }\n    return true;\n  } catch (error) {\n    console.error('Error al guardar múltiples usuarios en IndexedDB:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["DB_NAME","DB_VERSION","USERS_STORE","openDatabase","Promise","resolve","reject","request","indexedDB","open","onerror","event","target","errorCode","onsuccess","db","result","onupgradeneeded","objectStoreNames","contains","createObjectStore","keyPath","getUsersFromDB","transaction","store","objectStore","getAll","error","console","saveUserToDB","user","Error","cleanUser","id","String","Date","now","name","email","password","testSerialize","JSON","parse","stringify","warn","e","addRequest","add","saveUsersToDB","users","Array","isArray"],"sources":["F:/Driver google/VUE.JS-2/temp/websap/src/services/userService.js"],"sourcesContent":["const DB_NAME = 'websapDatabase';\r\nconst DB_VERSION = 1;\r\nconst USERS_STORE = 'users';\r\n\r\n// Abrir la conexión a la base de datos\r\nfunction openDatabase() {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    request.onerror = (event) => {\r\n      reject('Error al abrir la base de datos: ' + event.target.errorCode);\r\n    };\r\n    \r\n    request.onsuccess = (event) => {\r\n      const db = event.target.result;\r\n      resolve(db);\r\n    };\r\n    \r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      \r\n      // Crear almacén para usuarios si no existe\r\n      if (!db.objectStoreNames.contains(USERS_STORE)) {\r\n        db.createObjectStore(USERS_STORE, { keyPath: 'id' });\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Obtiene la lista de usuarios desde IndexedDB\r\n * @returns {Promise<Array>} - Lista de usuarios\r\n */\r\nexport async function getUsersFromDB() {\r\n  try {\r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([USERS_STORE], 'readonly');\r\n    const store = transaction.objectStore(USERS_STORE);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const request = store.getAll();\r\n      \r\n      request.onsuccess = () => {\r\n        resolve(request.result || []);\r\n      };\r\n      \r\n      request.onerror = (event) => {\r\n        reject(event.target.error);\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error al obtener usuarios de IndexedDB:', error);\r\n    return []; // Devolver array vacío en caso de error\r\n  }\r\n}\r\n\r\n/**\r\n * Guardar un único usuario en IndexedDB\r\n * @param {Object} user - El usuario a guardar\r\n * @returns {Promise<boolean>} - Éxito de la operación\r\n */\r\nexport async function saveUserToDB(user) {\r\n  try {\r\n    if (!user || typeof user !== 'object') {\r\n      throw new Error('Se requiere un objeto de usuario válido');\r\n    }\r\n    \r\n    // Crear un nuevo objeto con solo las propiedades necesarias\r\n    // Esto evita propiedades no serializables o referencias circulares\r\n    const cleanUser = {\r\n      id: String(user.id || Date.now()),\r\n      name: String(user.name || ''),\r\n      email: String(user.email || ''),\r\n      password: String(user.password || '')\r\n    };\r\n    \r\n    // Verificar que el objeto es serializable\r\n    try {\r\n      // Intentar serializar a JSON y deserializar para verificar\r\n      const testSerialize = JSON.parse(JSON.stringify(cleanUser));\r\n      \r\n      // Si hay diferencias entre el original y el deserializado, hay un problema\r\n      if (testSerialize.id !== cleanUser.id || \r\n          testSerialize.name !== cleanUser.name || \r\n          testSerialize.email !== cleanUser.email ||\r\n          testSerialize.password !== cleanUser.password) {\r\n        console.warn('Posible problema de serialización con el usuario:', cleanUser);\r\n      }\r\n    } catch (e) {\r\n      console.error('Error al verificar serializabilidad del usuario:', e);\r\n      throw new Error('El objeto usuario no es serializable para IndexedDB');\r\n    }\r\n    \r\n    const db = await openDatabase();\r\n    const transaction = db.transaction([USERS_STORE], 'readwrite');\r\n    const store = transaction.objectStore(USERS_STORE);\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      const addRequest = store.add(cleanUser);\r\n      \r\n      addRequest.onsuccess = () => {\r\n        resolve(true);\r\n      };\r\n      \r\n      addRequest.onerror = (event) => {\r\n        console.error('Error específico al guardar usuario:', event.target.error);\r\n        reject(event.target.error);\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('Error al guardar usuario único en IndexedDB:', error);\r\n    throw error; // Propagar el error para que se maneje en el componente\r\n  }\r\n}\r\n\r\n/**\r\n * Guardar múltiples usuarios en IndexedDB\r\n * @param {Array} users - Lista de usuarios a guardar\r\n * @returns {Promise<boolean>} - Éxito de la operación\r\n */\r\nexport async function saveUsersToDB(users) {\r\n  if (!Array.isArray(users)) {\r\n    throw new Error('La lista de usuarios debe ser un array');\r\n  }\r\n  \r\n  try {\r\n    // Guardar cada usuario individualmente para mayor control\r\n    for (const user of users) {\r\n      await saveUserToDB(user);\r\n    }\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error al guardar múltiples usuarios en IndexedDB:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}