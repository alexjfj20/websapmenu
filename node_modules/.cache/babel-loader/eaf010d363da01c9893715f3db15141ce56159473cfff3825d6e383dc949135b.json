{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nconst DB_NAME = 'websapDatabase';\n// Incrementar la versión de la base de datos para forzar la actualización\nconst DB_VERSION = 3; // Incrementado a 3 para forzar upgradeneeded\nconst MENU_STORE = 'menuItems';\nconst IMAGE_STORE = 'menuImages';\nconst SOLD_ITEMS_STORE = 'soldItems';\nconst BUSINESS_INFO_STORE = 'businessInfo';\nconst USERS_STORE = 'users';\nconst SHARED_MENU_STORE = 'sharedMenus';\n\n// Abrir la conexión a la base de datos con manejo mejorado de errores\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = event => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      request.onsuccess = event => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n\n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        resolve(db);\n      };\n      request.onupgradeneeded = event => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n\n        // Crear todos los almacenes necesarios si no existen\n        const requiredStores = [{\n          name: USERS_STORE,\n          keyPath: 'id'\n        }, {\n          name: MENU_STORE,\n          keyPath: 'id'\n        }, {\n          name: IMAGE_STORE,\n          keyPath: 'id'\n        }, {\n          name: SOLD_ITEMS_STORE,\n          keyPath: 'id'\n        }, {\n          name: BUSINESS_INFO_STORE,\n          keyPath: 'id'\n        }, {\n          name: SHARED_MENU_STORE,\n          keyPath: 'id'\n        }];\n\n        // Crear cada almacén\n        requiredStores.forEach(store => {\n          if (!db.objectStoreNames.contains(store.name)) {\n            console.log(`Creando almacén: ${store.name}`);\n            db.createObjectStore(store.name, {\n              keyPath: store.keyPath\n            });\n          }\n        });\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Guardar elementos del menú\nexport async function saveMenuItems(items, areSpecial = false) {\n  try {\n    // Primero procesamos todas las imágenes y creamos copias de los objetos\n    const processedItems = [];\n    for (const item of items) {\n      // Crear una copia del elemento\n      const itemToStore = {\n        ...item\n      };\n\n      // Asegurarse de que el elemento tiene un id\n      if (!itemToStore.id) {\n        itemToStore.id = Date.now() + Math.random().toString(36).substring(2, 10);\n      }\n\n      // Añadir la propiedad isSpecial (asumiendo que viene del formulario)\n      itemToStore.isSpecial = item.isSpecial || false; // Valor por defecto: false\n\n      // Si tiene imagen, guardarla por separado antes de la transacción principal\n      if (itemToStore.image && typeof itemToStore.image === 'string' && itemToStore.image.length > 0) {\n        try {\n          await saveMenuImage(itemToStore.id, itemToStore.image);\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = true;\n        } catch (imageError) {\n          console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n          // Si hay error al guardar la imagen, continuamos sin ella\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = false;\n        }\n      }\n      processedItems.push(itemToStore);\n    }\n\n    // Ahora guardamos todos los items en una sola transacción\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n\n    // Usamos Promise.all para manejar todas las operaciones put juntas\n    const putPromises = processedItems.map(item => {\n      return new Promise((resolve, reject) => {\n        const request = store.put(item);\n        request.onsuccess = () => resolve();\n        request.onerror = e => reject(e.target.error);\n      });\n    });\n\n    // Esperamos a que se completen todas las operaciones put\n    await Promise.all(putPromises);\n\n    // Esperamos a que se complete la transacción\n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos del menú:', error);\n    throw error;\n  }\n}\n\n// Guardar imagen de un elemento del menú\nexport async function saveMenuImage(itemId, imageData) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readwrite');\n    const store = transaction.objectStore(IMAGE_STORE);\n    store.put({\n      id: itemId,\n      data: imageData\n    });\n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar imagen:', error);\n    throw error;\n  }\n}\n\n// Obtener todos los elementos del menú\nexport async function getMenuItems() {\n  try {\n    const db = await openDatabase();\n\n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(MENU_STORE)) {\n      console.error(`El almacén ${MENU_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    const request = store.getAll();\n    return new Promise((resolve, reject) => {\n      request.onsuccess = async () => {\n        let items = request.result;\n\n        // Verificar que todos los elementos tengan IDs únicos\n        const uniqueItems = [];\n        const seenIds = new Set();\n        for (const item of items) {\n          // Si el elemento no tiene ID o es un ID duplicado, generamos uno nuevo\n          if (!item.id || seenIds.has(item.id)) {\n            item.id = Date.now() + '-' + Math.random().toString(36).substring(2, 10);\n          }\n\n          // Marcar este ID como visto\n          seenIds.add(item.id);\n          uniqueItems.push(item);\n        }\n\n        // Recuperar imágenes para cada elemento\n        for (const item of uniqueItems) {\n          if (item.hasStoredImage) {\n            item.image = await getMenuImage(item.id);\n          }\n        }\n        resolve(uniqueItems);\n      };\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    return []; // Devolver array vacío en caso de error\n  }\n}\n\n// Eliminar un elemento del menú - RENOMBRANDO LA FUNCIÓN\nexport async function deleteMenuItemFromDB(itemId) {\n  try {\n    console.log(`Intentando eliminar elemento con ID: ${itemId}`);\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE, IMAGE_STORE], 'readwrite');\n    const menuStore = transaction.objectStore(MENU_STORE);\n    const imageStore = transaction.objectStore(IMAGE_STORE);\n\n    // Verificar primero si el elemento existe\n    const getRequest = menuStore.get(itemId);\n    return new Promise((resolve, reject) => {\n      getRequest.onsuccess = () => {\n        if (!getRequest.result) {\n          console.warn(`No se encontró el elemento con ID: ${itemId}`);\n          // Resolver con éxito incluso si el elemento no existe\n          resolve(true);\n          return;\n        }\n\n        // Eliminar el elemento\n        const deleteRequest = menuStore.delete(itemId);\n        deleteRequest.onsuccess = () => {\n          console.log(`Elemento con ID ${itemId} eliminado correctamente`);\n\n          // Intentar eliminar la imagen asociada (no falla si no existe)\n          const imageRequest = imageStore.delete(itemId);\n          imageRequest.onsuccess = () => {\n            console.log(`Imagen para elemento ${itemId} eliminada (si existía)`);\n            resolve(true);\n          };\n          imageRequest.onerror = e => {\n            // No fallar si la imagen no existe\n            console.warn(`Error al eliminar imagen para ${itemId}:`, e.target.error);\n            resolve(true);\n          };\n        };\n        deleteRequest.onerror = e => {\n          console.error(`Error al eliminar elemento ${itemId}:`, e.target.error);\n          reject(e.target.error);\n        };\n      };\n      getRequest.onerror = event => {\n        console.error(`Error al verificar existencia del elemento ${itemId}:`, event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al eliminar elemento del menú:', error);\n    throw error;\n  }\n}\n\n// Mantener la función original por compatibilidad, pero que use la nueva\nexport async function deleteMenuItem(itemId) {\n  console.warn('La función deleteMenuItem está obsoleta, use deleteMenuItemFromDB en su lugar');\n  return deleteMenuItemFromDB(itemId);\n}\n\n// Obtener imagen de un elemento del menú\nexport async function getMenuImage(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\n    const store = transaction.objectStore(IMAGE_STORE);\n    const request = store.get(itemId);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.data);\n        } else {\n          resolve(null);\n        }\n      };\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener imagen:', error);\n    throw error;\n  }\n}\n\n// Guardar información del negocio - MEJORADA\nexport async function saveBusinessInfo(businessInfo) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction(['businessInfo'], 'readwrite');\n    const store = transaction.objectStore('businessInfo');\n\n    // Crear una copia limpia del objeto sin referencias circulares o propiedades no serializables\n    const cleanBusinessInfo = {\n      id: businessInfo.id || 'business_info_1',\n      // Usar un ID consistente\n      name: businessInfo.name || '',\n      description: businessInfo.description || '',\n      contact: businessInfo.contact || '',\n      address: businessInfo.address || '',\n      logo: businessInfo.logo || ''\n    };\n\n    // Manejar información de pago por separado si existe\n    if (businessInfo.paymentInfo) {\n      cleanBusinessInfo.paymentInfo = {\n        qrTitle: businessInfo.paymentInfo.qrTitle || '',\n        qrImage: businessInfo.paymentInfo.qrImage || '',\n        nequiNumber: businessInfo.paymentInfo.nequiNumber || '',\n        nequiImage: businessInfo.paymentInfo.nequiImage || '',\n        bankInfo: businessInfo.paymentInfo.bankInfo || '',\n        otherPaymentMethods: businessInfo.paymentInfo.otherPaymentMethods || ''\n      };\n    }\n\n    // Para debugging, verificamos que es serializable\n    try {\n      JSON.stringify(cleanBusinessInfo);\n    } catch (e) {\n      console.error('El objeto businessInfo no es serializable:', e);\n      throw new Error('El objeto businessInfo no es serializable');\n    }\n\n    // Guardar el objeto limpio\n    const request = store.put(cleanBusinessInfo);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = event => {\n        console.error('Error específico al guardar businessInfo:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar información del negocio:', error);\n    throw error;\n  }\n}\n\n// Obtener información del negocio\nexport async function getBusinessInfo() {\n  try {\n    const db = await openDatabase();\n\n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(BUSINESS_INFO_STORE)) {\n      console.error(`El almacén ${BUSINESS_INFO_STORE} no existe en la base de datos`);\n      return {}; // Devolver objeto vacío en lugar de fallar\n    }\n    const transaction = db.transaction([BUSINESS_INFO_STORE], 'readonly');\n    const store = transaction.objectStore(BUSINESS_INFO_STORE);\n    const request = store.get('business_info_1');\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve(request.result || {});\n      };\n      request.onerror = event => {\n        console.error('Error en request:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al obtener información del negocio:', error);\n    // Devolvemos un objeto vacío en lugar de fallar\n    return {};\n  }\n}\n\n// Guardar elementos vendidos\nexport async function saveSoldItems(items) {\n  try {\n    // Asegurarse de que items sea un array y que cada elemento sea serializable\n    if (!Array.isArray(items)) {\n      console.warn('saveSoldItems recibió un valor que no es array:', items);\n      items = [];\n    }\n\n    // Limpiar los objetos para asegurar que sean serializables\n    const cleanItems = items.map(item => {\n      // Si el item no es un objeto, crear uno básico\n      if (!item || typeof item !== 'object') {\n        return {\n          name: 'Producto desconocido',\n          quantity: 1,\n          price: 0,\n          includesDrink: false\n        };\n      }\n\n      // Crear una copia limpia con solo las propiedades necesarias\n      return {\n        name: String(item.name || 'Producto desconocido'),\n        quantity: Number(item.quantity) || 1,\n        price: Number(item.price) || 0,\n        includesDrink: Boolean(item.includesDrink)\n      };\n    });\n    const db = await openDatabase();\n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readwrite');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n\n    // Asegurarnos de que estamos guardando un objeto serializable\n    const soldItemsObject = {\n      id: 'sold_items_1',\n      items: cleanItems\n    };\n\n    // Verificar que el objeto es serializable antes de guardarlo\n    try {\n      // Esto lanzará error si el objeto no es serializable\n      JSON.stringify(soldItemsObject);\n    } catch (e) {\n      console.error('El objeto soldItems no es serializable:', e);\n      throw new Error('El objeto soldItems no es serializable');\n    }\n    const request = store.put(soldItemsObject);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = event => {\n        console.error('Error específico al guardar soldItems:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos vendidos:', error);\n    throw error;\n  }\n}\n\n// Obtener elementos vendidos\nexport async function getSoldItems() {\n  try {\n    const db = await openDatabase();\n\n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(SOLD_ITEMS_STORE)) {\n      console.error(`El almacén ${SOLD_ITEMS_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readonly');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n    const request = store.get('sold_items_1');\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.items);\n        } else {\n          resolve([]);\n        }\n      };\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    return [];\n  }\n}\n\n// Eliminar completamente la función migrateFromLocalStorage ya que no queremos usar localStorage\nexport async function migrateFromLocalStorage() {\n  console.log(\"Función migrateFromLocalStorage en desuso - no se utilizará localStorage\");\n  return true; // Solo para mantener la compatibilidad con el código existente\n}\n\n// Comprimir imagen\nexport function compressImage(base64Image, maxWidth = 800, maxHeight = 600, quality = 0.7) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.onload = () => {\n      // Crear un canvas para comprimir la imagen\n      const canvas = document.createElement('canvas');\n      let width = img.width;\n      let height = img.height;\n\n      // Calcular nuevas dimensiones manteniendo proporción\n      if (width > height) {\n        if (width > maxWidth) {\n          height = Math.round(height * maxWidth / width);\n          width = maxWidth;\n        }\n      } else {\n        if (height > maxHeight) {\n          width = Math.round(width * maxHeight / height);\n          height = maxHeight;\n        }\n      }\n      canvas.width = width;\n      canvas.height = height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n\n      // Obtener imagen comprimida como JPEG con calidad reducida\n      const compressedImage = canvas.toDataURL('image/jpeg', quality);\n      resolve(compressedImage);\n    };\n    img.src = base64Image;\n  });\n}\n\n// Mejorar la función resetDatabase para asegurarnos de que no use localStorage\nexport async function resetDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Iniciando proceso de eliminación de la base de datos...\");\n      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);\n      deleteRequest.onsuccess = () => {\n        console.log(\"Base de datos eliminada con éxito\");\n        console.log(\"Limpieza completa. La aplicación está lista para comenzar de nuevo.\");\n        resolve(true);\n      };\n      deleteRequest.onerror = event => {\n        console.error(\"Error al eliminar la base de datos:\", event.target.error);\n        reject(event.target.error);\n      };\n    } catch (error) {\n      console.error(\"Error al intentar resetear la base de datos:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Añadir nueva función para validar disponibilidad\nexport async function checkItemAvailability(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    const item = await store.get(itemId);\n    return {\n      isAvailable: item && item.availableQuantity > 0,\n      quantity: item ? item.availableQuantity : 0\n    };\n  } catch (error) {\n    console.error('Error al verificar disponibilidad:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza la cantidad disponible de un plato en el inventario.\n * @param {string} itemId - ID del plato a actualizar\n * @param {number|string} newQuantity - Nueva cantidad disponible\n * @returns {Promise<boolean>} - Resultado de la operación\n */\nexport async function updateItemAvailability(itemId, newQuantity) {\n  try {\n    // Validar parámetros de entrada\n    if (!itemId) {\n      console.error('Error: ID del item no proporcionado');\n      return false;\n    }\n\n    // Asegurarse de que newQuantity sea un número\n    const quantity = parseInt(newQuantity);\n    if (isNaN(quantity)) {\n      console.error('Error: La cantidad proporcionada no es un número válido:', newQuantity);\n      return false;\n    }\n\n    // Usar una transacción específica solo para este item\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    return new Promise((resolve, reject) => {\n      // Primero obtenemos el item actual\n      const getRequest = store.get(itemId);\n      getRequest.onsuccess = event => {\n        const item = event.target.result;\n        if (!item) {\n          console.error(`No se encontró el elemento con ID: ${itemId}`);\n          resolve(false);\n          return;\n        }\n\n        // Actualizar la cantidad disponible\n        item.availableQuantity = quantity;\n\n        // Guardar el item actualizado\n        const putRequest = store.put(item);\n        putRequest.onsuccess = () => {\n          console.log(`Disponibilidad actualizada para ${item.name} (ID: ${itemId}): nueva cantidad = ${quantity}`);\n\n          // Intentar sincronizar con el backend (opcional, no bloquea)\n          try {\n            fetch('http://localhost:3000/actualizar-disponibilidad', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify({\n                id: itemId,\n                availableQuantity: quantity\n              })\n            }).catch(syncError => {\n              // Simplemente registrar el error, no bloqueamos la operación principal\n              console.warn('Error al sincronizar con backend:', syncError);\n            });\n          } catch (syncError) {\n            console.warn('Error al sincronizar con el backend:', syncError);\n            // No bloqueamos la función principal por errores de sincronización\n          }\n          resolve(true);\n        };\n        putRequest.onerror = error => {\n          console.error(`Error al actualizar disponibilidad para ${itemId}:`, error);\n          reject(error);\n        };\n      };\n      getRequest.onerror = error => {\n        console.error(`Error al obtener elemento ${itemId}:`, error);\n        reject(error);\n      };\n\n      // Manejar errores de transacción\n      transaction.onerror = error => {\n        console.error('Error en transacción de actualización:', error);\n        reject(error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al actualizar disponibilidad:', error);\n    return false;\n  }\n}\n\n// Guardar un elemento del menú individual\nexport async function saveMenuItem(item) {\n  try {\n    // Validar que el item sea un objeto y tenga id\n    if (!item || typeof item !== 'object') {\n      throw new Error('El item no es un objeto válido');\n    }\n    if (!item.id) {\n      item.id = Date.now() + Math.random().toString(36).substring(2, 10);\n    }\n\n    // Si tiene imagen y es un string largo, procesarla\n    if (item.image && typeof item.image === 'string' && item.image.length > 0 && !item.hasStoredImage) {\n      try {\n        await saveMenuImage(item.id, item.image);\n        item.image = null;\n        item.hasStoredImage = true;\n      } catch (imageError) {\n        console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n        item.image = null;\n        item.hasStoredImage = false;\n      }\n    }\n\n    // Guardar el item en la base de datos\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    return new Promise((resolve, reject) => {\n      const request = store.put(item);\n      request.onsuccess = () => resolve(true);\n      request.onerror = event => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elemento del menú:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["DB_NAME","DB_VERSION","MENU_STORE","IMAGE_STORE","SOLD_ITEMS_STORE","BUSINESS_INFO_STORE","USERS_STORE","SHARED_MENU_STORE","openDatabase","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","event","error","target","errorCode","onsuccess","db","result","version","existingStores","Array","from","objectStoreNames","onupgradeneeded","newVersion","requiredStores","name","keyPath","forEach","store","contains","createObjectStore","saveMenuItems","items","areSpecial","processedItems","item","itemToStore","id","Date","now","Math","random","toString","substring","isSpecial","image","length","saveMenuImage","hasStoredImage","imageError","warn","push","transaction","objectStore","putPromises","map","put","e","all","oncomplete","itemId","imageData","data","getMenuItems","includes","getAll","uniqueItems","seenIds","Set","has","add","getMenuImage","deleteMenuItemFromDB","menuStore","imageStore","getRequest","get","deleteRequest","delete","imageRequest","deleteMenuItem","saveBusinessInfo","businessInfo","cleanBusinessInfo","description","contact","address","logo","paymentInfo","qrTitle","qrImage","nequiNumber","nequiImage","bankInfo","otherPaymentMethods","JSON","stringify","Error","getBusinessInfo","saveSoldItems","isArray","cleanItems","quantity","price","includesDrink","String","Number","Boolean","soldItemsObject","getSoldItems","migrateFromLocalStorage","compressImage","base64Image","maxWidth","maxHeight","quality","img","Image","onload","canvas","document","createElement","width","height","round","ctx","getContext","drawImage","compressedImage","toDataURL","src","resetDatabase","deleteDatabase","checkItemAvailability","isAvailable","availableQuantity","updateItemAvailability","newQuantity","parseInt","isNaN","putRequest","fetch","method","headers","body","catch","syncError","saveMenuItem"],"sources":["F:/Driver google/VUE.JS-2/VUE-JS/websap/src/services/storageService.js"],"sourcesContent":["const DB_NAME = 'websapDatabase';\n// Incrementar la versión de la base de datos para forzar la actualización\nconst DB_VERSION = 3; // Incrementado a 3 para forzar upgradeneeded\nconst MENU_STORE = 'menuItems';\nconst IMAGE_STORE = 'menuImages';\nconst SOLD_ITEMS_STORE = 'soldItems'; \nconst BUSINESS_INFO_STORE = 'businessInfo';\nconst USERS_STORE = 'users';\nconst SHARED_MENU_STORE = 'sharedMenus';\n\n// Abrir la conexión a la base de datos con manejo mejorado de errores\nfunction openDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Intentando abrir la base de datos con versión:\", DB_VERSION);\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error(\"Error al abrir la base de datos:\", event.target.error);\n        reject('Error al abrir la base de datos: ' + event.target.errorCode);\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log(\"Base de datos abierta con éxito, versión:\", db.version);\n        \n        // Verificar que todos los almacenes necesarios existen\n        const existingStores = Array.from(db.objectStoreNames);\n        console.log(\"Almacenes existentes:\", existingStores);\n        \n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log(\"Actualizando estructura de la base de datos a versión:\", event.newVersion);\n        const db = event.target.result;\n        \n        // Crear todos los almacenes necesarios si no existen\n        const requiredStores = [\n          { name: USERS_STORE, keyPath: 'id' },\n          { name: MENU_STORE, keyPath: 'id' },\n          { name: IMAGE_STORE, keyPath: 'id' },\n          { name: SOLD_ITEMS_STORE, keyPath: 'id' },\n          { name: BUSINESS_INFO_STORE, keyPath: 'id' },\n          { name: SHARED_MENU_STORE, keyPath: 'id' }\n        ];\n        \n        // Crear cada almacén\n        requiredStores.forEach(store => {\n          if (!db.objectStoreNames.contains(store.name)) {\n            console.log(`Creando almacén: ${store.name}`);\n            db.createObjectStore(store.name, { keyPath: store.keyPath });\n          }\n        });\n      };\n    } catch (error) {\n      console.error(\"Error crítico en IndexedDB:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Guardar elementos del menú\nexport async function saveMenuItems(items, areSpecial = false) {\n  try {\n    // Primero procesamos todas las imágenes y creamos copias de los objetos\n    const processedItems = [];\n    for (const item of items) {\n      // Crear una copia del elemento\n      const itemToStore = { ...item };\n      \n      // Asegurarse de que el elemento tiene un id\n      if (!itemToStore.id) {\n        itemToStore.id = Date.now() + Math.random().toString(36).substring(2, 10);\n      }\n      \n      // Añadir la propiedad isSpecial (asumiendo que viene del formulario)\n      itemToStore.isSpecial = item.isSpecial || false; // Valor por defecto: false\n      \n      // Si tiene imagen, guardarla por separado antes de la transacción principal\n      if (itemToStore.image && typeof itemToStore.image === 'string' && itemToStore.image.length > 0) {\n        try {\n          await saveMenuImage(itemToStore.id, itemToStore.image);\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = true;\n        } catch (imageError) {\n          console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n          // Si hay error al guardar la imagen, continuamos sin ella\n          itemToStore.image = null;\n          itemToStore.hasStoredImage = false;\n        }\n      }\n      \n      processedItems.push(itemToStore);\n    }\n    \n    // Ahora guardamos todos los items en una sola transacción\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    // Usamos Promise.all para manejar todas las operaciones put juntas\n    const putPromises = processedItems.map(item => {\n      return new Promise((resolve, reject) => {\n        const request = store.put(item);\n        request.onsuccess = () => resolve();\n        request.onerror = (e) => reject(e.target.error);\n      });\n    });\n    \n    // Esperamos a que se completen todas las operaciones put\n    await Promise.all(putPromises);\n    \n    // Esperamos a que se complete la transacción\n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos del menú:', error);\n    throw error;\n  }\n}\n\n// Guardar imagen de un elemento del menú\nexport async function saveMenuImage(itemId, imageData) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readwrite');\n    const store = transaction.objectStore(IMAGE_STORE);\n    \n    store.put({ id: itemId, data: imageData });\n    \n    return new Promise((resolve, reject) => {\n      transaction.oncomplete = () => resolve(true);\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar imagen:', error);\n    throw error;\n  }\n}\n\n// Obtener todos los elementos del menú\nexport async function getMenuItems() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(MENU_STORE)) {\n      console.error(`El almacén ${MENU_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    const request = store.getAll();\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = async () => {\n        let items = request.result;\n        \n        // Verificar que todos los elementos tengan IDs únicos\n        const uniqueItems = [];\n        const seenIds = new Set();\n        \n        for (const item of items) {\n          // Si el elemento no tiene ID o es un ID duplicado, generamos uno nuevo\n          if (!item.id || seenIds.has(item.id)) {\n            item.id = Date.now() + '-' + Math.random().toString(36).substring(2, 10);\n          }\n          \n          // Marcar este ID como visto\n          seenIds.add(item.id);\n          uniqueItems.push(item);\n        }\n        \n        // Recuperar imágenes para cada elemento\n        for (const item of uniqueItems) {\n          if (item.hasStoredImage) {\n            item.image = await getMenuImage(item.id);\n          }\n        }\n        \n        resolve(uniqueItems);\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos del menú:', error);\n    return []; // Devolver array vacío en caso de error\n  }\n}\n\n// Eliminar un elemento del menú - RENOMBRANDO LA FUNCIÓN\nexport async function deleteMenuItemFromDB(itemId) {\n  try {\n    console.log(`Intentando eliminar elemento con ID: ${itemId}`);\n    \n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE, IMAGE_STORE], 'readwrite');\n    const menuStore = transaction.objectStore(MENU_STORE);\n    const imageStore = transaction.objectStore(IMAGE_STORE);\n    \n    // Verificar primero si el elemento existe\n    const getRequest = menuStore.get(itemId);\n    \n    return new Promise((resolve, reject) => {\n      getRequest.onsuccess = () => {\n        if (!getRequest.result) {\n          console.warn(`No se encontró el elemento con ID: ${itemId}`);\n          // Resolver con éxito incluso si el elemento no existe\n          resolve(true);\n          return;\n        }\n        \n        // Eliminar el elemento\n        const deleteRequest = menuStore.delete(itemId);\n        deleteRequest.onsuccess = () => {\n          console.log(`Elemento con ID ${itemId} eliminado correctamente`);\n          \n          // Intentar eliminar la imagen asociada (no falla si no existe)\n          const imageRequest = imageStore.delete(itemId);\n          imageRequest.onsuccess = () => {\n            console.log(`Imagen para elemento ${itemId} eliminada (si existía)`);\n            resolve(true);\n          };\n          imageRequest.onerror = (e) => {\n            // No fallar si la imagen no existe\n            console.warn(`Error al eliminar imagen para ${itemId}:`, e.target.error);\n            resolve(true);\n          };\n        };\n        \n        deleteRequest.onerror = (e) => {\n          console.error(`Error al eliminar elemento ${itemId}:`, e.target.error);\n          reject(e.target.error);\n        };\n      };\n      \n      getRequest.onerror = (event) => {\n        console.error(`Error al verificar existencia del elemento ${itemId}:`, event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al eliminar elemento del menú:', error);\n    throw error;\n  }\n}\n\n// Mantener la función original por compatibilidad, pero que use la nueva\nexport async function deleteMenuItem(itemId) {\n  console.warn('La función deleteMenuItem está obsoleta, use deleteMenuItemFromDB en su lugar');\n  return deleteMenuItemFromDB(itemId);\n}\n\n// Obtener imagen de un elemento del menú\nexport async function getMenuImage(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([IMAGE_STORE], 'readonly');\n    const store = transaction.objectStore(IMAGE_STORE);\n    \n    const request = store.get(itemId);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.data);\n        } else {\n          resolve(null);\n        }\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener imagen:', error);\n    throw error;\n  }\n}\n\n// Guardar información del negocio - MEJORADA\nexport async function saveBusinessInfo(businessInfo) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction(['businessInfo'], 'readwrite');\n    const store = transaction.objectStore('businessInfo');\n\n    // Crear una copia limpia del objeto sin referencias circulares o propiedades no serializables\n    const cleanBusinessInfo = {\n      id: businessInfo.id || 'business_info_1', // Usar un ID consistente\n      name: businessInfo.name || '',\n      description: businessInfo.description || '',\n      contact: businessInfo.contact || '',\n      address: businessInfo.address || '',\n      logo: businessInfo.logo || ''\n    };\n\n    // Manejar información de pago por separado si existe\n    if (businessInfo.paymentInfo) {\n      cleanBusinessInfo.paymentInfo = {\n        qrTitle: businessInfo.paymentInfo.qrTitle || '',\n        qrImage: businessInfo.paymentInfo.qrImage || '',\n        nequiNumber: businessInfo.paymentInfo.nequiNumber || '',\n        nequiImage: businessInfo.paymentInfo.nequiImage || '',\n        bankInfo: businessInfo.paymentInfo.bankInfo || '',\n        otherPaymentMethods: businessInfo.paymentInfo.otherPaymentMethods || ''\n      };\n    }\n\n    // Para debugging, verificamos que es serializable\n    try {\n      JSON.stringify(cleanBusinessInfo);\n    } catch (e) {\n      console.error('El objeto businessInfo no es serializable:', e);\n      throw new Error('El objeto businessInfo no es serializable');\n    }\n\n    // Guardar el objeto limpio\n    const request = store.put(cleanBusinessInfo);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => {\n        console.error('Error específico al guardar businessInfo:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar información del negocio:', error);\n    throw error;\n  }\n}\n\n// Obtener información del negocio\nexport async function getBusinessInfo() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(BUSINESS_INFO_STORE)) {\n      console.error(`El almacén ${BUSINESS_INFO_STORE} no existe en la base de datos`);\n      return {}; // Devolver objeto vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([BUSINESS_INFO_STORE], 'readonly');\n    const store = transaction.objectStore(BUSINESS_INFO_STORE);\n    \n    const request = store.get('business_info_1');\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve(request.result || {});\n      };\n      request.onerror = (event) => {\n        console.error('Error en request:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al obtener información del negocio:', error);\n    // Devolvemos un objeto vacío en lugar de fallar\n    return {};\n  }\n}\n\n// Guardar elementos vendidos\nexport async function saveSoldItems(items) {\n  try {\n    // Asegurarse de que items sea un array y que cada elemento sea serializable\n    if (!Array.isArray(items)) {\n      console.warn('saveSoldItems recibió un valor que no es array:', items);\n      items = [];\n    }\n    \n    // Limpiar los objetos para asegurar que sean serializables\n    const cleanItems = items.map(item => {\n      // Si el item no es un objeto, crear uno básico\n      if (!item || typeof item !== 'object') {\n        return {\n          name: 'Producto desconocido',\n          quantity: 1,\n          price: 0,\n          includesDrink: false\n        };\n      }\n      \n      // Crear una copia limpia con solo las propiedades necesarias\n      return {\n        name: String(item.name || 'Producto desconocido'),\n        quantity: Number(item.quantity) || 1,\n        price: Number(item.price) || 0,\n        includesDrink: Boolean(item.includesDrink)\n      };\n    });\n    \n    const db = await openDatabase();\n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readwrite');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n    \n    // Asegurarnos de que estamos guardando un objeto serializable\n    const soldItemsObject = { \n      id: 'sold_items_1', \n      items: cleanItems\n    };\n    \n    // Verificar que el objeto es serializable antes de guardarlo\n    try {\n      // Esto lanzará error si el objeto no es serializable\n      JSON.stringify(soldItemsObject);\n    } catch (e) {\n      console.error('El objeto soldItems no es serializable:', e);\n      throw new Error('El objeto soldItems no es serializable');\n    }\n    \n    const request = store.put(soldItemsObject);\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => {\n        console.error('Error específico al guardar soldItems:', event.target.error);\n        reject(event.target.error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al guardar elementos vendidos:', error);\n    throw error;\n  }\n}\n\n// Obtener elementos vendidos\nexport async function getSoldItems() {\n  try {\n    const db = await openDatabase();\n    \n    // Verificar que el almacén existe\n    if (!Array.from(db.objectStoreNames).includes(SOLD_ITEMS_STORE)) {\n      console.error(`El almacén ${SOLD_ITEMS_STORE} no existe en la base de datos`);\n      return []; // Devolver array vacío en lugar de fallar\n    }\n    \n    const transaction = db.transaction([SOLD_ITEMS_STORE], 'readonly');\n    const store = transaction.objectStore(SOLD_ITEMS_STORE);\n    \n    const request = store.get('sold_items_1');\n    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        if (request.result) {\n          resolve(request.result.items);\n        } else {\n          resolve([]);\n        }\n      };\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al obtener elementos vendidos:', error);\n    return [];\n  }\n}\n\n// Eliminar completamente la función migrateFromLocalStorage ya que no queremos usar localStorage\nexport async function migrateFromLocalStorage() {\n  console.log(\"Función migrateFromLocalStorage en desuso - no se utilizará localStorage\");\n  return true; // Solo para mantener la compatibilidad con el código existente\n}\n\n// Comprimir imagen\nexport function compressImage(base64Image, maxWidth = 800, maxHeight = 600, quality = 0.7) {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.onload = () => {\n      // Crear un canvas para comprimir la imagen\n      const canvas = document.createElement('canvas');\n      \n      let width = img.width;\n      let height = img.height;\n      \n      // Calcular nuevas dimensiones manteniendo proporción\n      if (width > height) {\n        if (width > maxWidth) {\n          height = Math.round((height * maxWidth) / width);\n          width = maxWidth;\n        }\n      } else {\n        if (height > maxHeight) {\n          width = Math.round((width * maxHeight) / height);\n          height = maxHeight;\n        }\n      }\n      \n      canvas.width = width;\n      canvas.height = height;\n      \n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n      \n      // Obtener imagen comprimida como JPEG con calidad reducida\n      const compressedImage = canvas.toDataURL('image/jpeg', quality);\n      resolve(compressedImage);\n    };\n    img.src = base64Image;\n  });\n}\n\n// Mejorar la función resetDatabase para asegurarnos de que no use localStorage\nexport async function resetDatabase() {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"Iniciando proceso de eliminación de la base de datos...\");\n      \n      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);\n      \n      deleteRequest.onsuccess = () => {\n        console.log(\"Base de datos eliminada con éxito\");\n        \n        console.log(\"Limpieza completa. La aplicación está lista para comenzar de nuevo.\");\n        resolve(true);\n      };\n      \n      deleteRequest.onerror = (event) => {\n        console.error(\"Error al eliminar la base de datos:\", event.target.error);\n        reject(event.target.error);\n      };\n    } catch (error) {\n      console.error(\"Error al intentar resetear la base de datos:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Añadir nueva función para validar disponibilidad\nexport async function checkItemAvailability(itemId) {\n  try {\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readonly');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    const item = await store.get(itemId);\n    \n    return {\n      isAvailable: item && item.availableQuantity > 0,\n      quantity: item ? item.availableQuantity : 0\n    };\n  } catch (error) {\n    console.error('Error al verificar disponibilidad:', error);\n    throw error;\n  }\n}\n\n/**\n * Actualiza la cantidad disponible de un plato en el inventario.\n * @param {string} itemId - ID del plato a actualizar\n * @param {number|string} newQuantity - Nueva cantidad disponible\n * @returns {Promise<boolean>} - Resultado de la operación\n */\nexport async function updateItemAvailability(itemId, newQuantity) {\n  try {\n    // Validar parámetros de entrada\n    if (!itemId) {\n      console.error('Error: ID del item no proporcionado');\n      return false;\n    }\n    \n    // Asegurarse de que newQuantity sea un número\n    const quantity = parseInt(newQuantity);\n    if (isNaN(quantity)) {\n      console.error('Error: La cantidad proporcionada no es un número válido:', newQuantity);\n      return false;\n    }\n    \n    // Usar una transacción específica solo para este item\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    return new Promise((resolve, reject) => {\n      // Primero obtenemos el item actual\n      const getRequest = store.get(itemId);\n      \n      getRequest.onsuccess = (event) => {\n        const item = event.target.result;\n        \n        if (!item) {\n          console.error(`No se encontró el elemento con ID: ${itemId}`);\n          resolve(false);\n          return;\n        }\n        \n        // Actualizar la cantidad disponible\n        item.availableQuantity = quantity;\n        \n        // Guardar el item actualizado\n        const putRequest = store.put(item);\n        \n        putRequest.onsuccess = () => {\n          console.log(`Disponibilidad actualizada para ${item.name} (ID: ${itemId}): nueva cantidad = ${quantity}`);\n          \n          // Intentar sincronizar con el backend (opcional, no bloquea)\n          try {\n            fetch('http://localhost:3000/actualizar-disponibilidad', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                id: itemId,\n                availableQuantity: quantity\n              })\n            }).catch(syncError => {\n              // Simplemente registrar el error, no bloqueamos la operación principal\n              console.warn('Error al sincronizar con backend:', syncError);\n            });\n          } catch (syncError) {\n            console.warn('Error al sincronizar con el backend:', syncError);\n            // No bloqueamos la función principal por errores de sincronización\n          }\n          \n          resolve(true);\n        };\n        \n        putRequest.onerror = (error) => {\n          console.error(`Error al actualizar disponibilidad para ${itemId}:`, error);\n          reject(error);\n        };\n      };\n      \n      getRequest.onerror = (error) => {\n        console.error(`Error al obtener elemento ${itemId}:`, error);\n        reject(error);\n      };\n      \n      // Manejar errores de transacción\n      transaction.onerror = (error) => {\n        console.error('Error en transacción de actualización:', error);\n        reject(error);\n      };\n    });\n  } catch (error) {\n    console.error('Error al actualizar disponibilidad:', error);\n    return false;\n  }\n}\n\n// Guardar un elemento del menú individual\nexport async function saveMenuItem(item) {\n  try {\n    // Validar que el item sea un objeto y tenga id\n    if (!item || typeof item !== 'object') {\n      throw new Error('El item no es un objeto válido');\n    }\n    \n    if (!item.id) {\n      item.id = Date.now() + Math.random().toString(36).substring(2, 10);\n    }\n    \n    // Si tiene imagen y es un string largo, procesarla\n    if (item.image && typeof item.image === 'string' && item.image.length > 0 && !item.hasStoredImage) {\n      try {\n        await saveMenuImage(item.id, item.image);\n        item.image = null;\n        item.hasStoredImage = true;\n      } catch (imageError) {\n        console.warn('Error al guardar imagen, continuando sin imagen:', imageError);\n        item.image = null;\n        item.hasStoredImage = false;\n      }\n    }\n    \n    // Guardar el item en la base de datos\n    const db = await openDatabase();\n    const transaction = db.transaction([MENU_STORE], 'readwrite');\n    const store = transaction.objectStore(MENU_STORE);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.put(item);\n      request.onsuccess = () => resolve(true);\n      request.onerror = (event) => reject(event.target.error);\n    });\n  } catch (error) {\n    console.error('Error al guardar elemento del menú:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}